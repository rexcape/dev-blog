<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java-notes-collection</title>
    <link href="/2021/02/18/java-notes-collection/"/>
    <url>/2021/02/18/java-notes-collection/</url>
    
    <content type="html"><![CDATA[<p>Java 笔记 - Collection</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一方面，面向对象语言对事物的体现都是以对象的形式,为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用 <code>Array</code> 存储对象方面具有一些弊端，而 Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。</p><p>数组在内存存储方面的特点：</p><ul><li>数组初始化以后，长度就确定了</li><li>数组声明的类型，就决定了进行元素初始化时的类型</li></ul><p>数组在存储数据方面的弊端：</p><ul><li>数组初始化以后，长度就不可变了，不便于扩展</li><li>数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的个数</li><li>数组存储的数据是有序的、可以重复的。存储数据的特点单一</li></ul><p>Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。</p><p>集合可以分为 Collection 和 Map 两种体系</p><ul><li>Collection 接口：单列数据，定义了存取一组对象的方法的集合<ul><li>List：元素有序，可重复的集合</li><li>Set：元素无需，不可重复的集合</li></ul></li><li>Map 接口：双列数据，保存具有映射关系的键值对集合</li></ul><p><img src="https://s3.ax1x.com/2021/02/18/yRjmMq.png" alt="Collection 接口的继承树"></p><p>Collection 接口的继承树</p><p><img src="https://s3.ax1x.com/2021/02/18/yRjJzR.png" alt="Map 接口的继承树"></p><p>Map 接口的继承树</p><h2 id="Collection-接口常用方法"><a href="#Collection-接口常用方法" class="headerlink" title="Collection 接口常用方法"></a>Collection 接口常用方法</h2><p>向 <code>Collection</code> 接口实现类的对象中添加数据时，要求数据所在的类要重写 <code>equals</code></p><ul><li><code>add(E e)</code>：将元素 e 添加到集合中</li><li><code>size()</code>：获取元素的个数</li><li><code>addAll(Collection&lt;? extends E&gt; coll)</code>：将 coll 中所有元素添加到集合中</li><li><code>isEmpty()</code>：判断当前集合是否为空</li><li><code>clear()</code>：清空集合元素</li><li><code>contains(E e)</code>：判断当前集合中是否包含 e（调用 e 的 <code>equals</code> 方法来判断）</li><li><code>containsAll(Collection&lt;?&gt; coll)</code>：判断 coll 中的所有元素是否都存在于当前集合中</li><li><code>remove(E e)</code>：从集合中移除 e，删除成功返回 <code>true</code>，删除失败返回 <code>false</code></li><li><code>removeAll(Collection&lt;?&gt; coll)</code>：从当前集合移除 coll 中的所有元素（差集）</li><li><code>retainAll(Collection&lt;?&gt; coll)</code>：交集，获取当前集合和 coll 集合的交集并返回给当前集合</li><li><code>equals(Object obj)</code>：判断当前集合和 obj 元素是否相同</li><li><code>hashCode()</code>：计算集合的哈希值</li><li><code>toArray()</code>：返回当前集合的 <code>Object</code> 数组</li></ul><p>扩展：数组到集合 <code>Arrays.asList(T... a)</code></p><ul><li><code>iterator()</code>：返回 <code>Iterator</code> 接口的实例，用于遍历集合元素。</li></ul><h2 id="使用-Iterator-遍历集合"><a href="#使用-Iterator-遍历集合" class="headerlink" title="使用 Iterator 遍历集合"></a>使用 <code>Iterator</code> 遍历集合</h2><p><code>Iterator</code> 对象称为迭代器（设计模式的一种），主要用于遍历 <code>Collection</code> 集合中的元素</p><p>GOF 给迭代器模式的定义为：提供一种方法访问一个容器（<code>container</code>）对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生</p><p><code>Collection</code> 接口继承了 <code>java.lang.Iterable</code> 接口，该接口有一个 <code>iterator</code> 方法，那么所有实现了 <code>Collection</code> 接口的集合类都有一个 <code>iterator</code> 方法，用以返回一个实现了 <code>Iterator</code> 接口的对象</p><p><code>Iterator</code> 仅用于遍历集合，<code>Iterator</code> 本身并不提供承装对象的能力。如果需要创建 <code>Iterator</code> 对象，则必须有一个被迭代的集合</p><p>集合对象每次调用 <code>iterator</code> 方法都得到一个全新的迭代器对象，默认游标都在<strong>集合的第一个元素之前</strong></p><p>方式一（不推荐）：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Iterator it = coll.iterator();<br>println(it.next());<br>println(it.next());<br><span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><p>方式二（不推荐）：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; coll.size(); i++) println(it.next());<br></code></pre></div></td></tr></table></figure><p>方式三（推荐）：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(it.hasNext()) println(it.next());<br></code></pre></div></td></tr></table></figure><h3 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h3><p><code>hasNext()</code>：判断是否还有下一个元素</p><p><code>next()</code>：指针下移 → 将下移以后集合位置上的元素返回</p><h3 id="迭代器中的-remove"><a href="#迭代器中的-remove" class="headerlink" title="迭代器中的 remove"></a>迭代器中的 <code>remove</code></h3><p><code>remove</code> 方法可以帮你在迭代的时候删除一些元素</p><p>删除集合中 Tom</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(it.hasNext()) &#123;<br>    println(it.next());<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Tom&quot;</span>.equals(it)) it.remove();<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>iterator</code> 可以删除集合的元素，但是是遍历过程中通过迭代器对象的 <code>remove</code> 方法，不是集合对象的 <code>remove</code> 方法<br>如果还未调用 <code>next</code> 或在上一次调用 next 之后已经调用了 <code>remove</code> 方法，再调用 <code>remove</code> 都会抛 <code>IllegalStateException</code></p><h2 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h2><p>Java5 提供了 foreach 循环迭代访问 Collection 和数组</p><p>遍历操作不需要获取 Collection 或数组的长度，无需使用索引访问元素</p><p>遍历集合的底层调用 Iterator 完成操作</p><p>foreach 可以用来遍历数组</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Person p : persons) println(p.getName());<br></code></pre></div></td></tr></table></figure><h2 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h2><p><code>List</code> 接口是 <code>Collection</code> 的子接口</p><p>鉴于 Java 中数组用来存储数据的局限性，通常用 <code>List</code> 替代数组</p><p><code>List</code> 集合类中元素<strong>有序</strong>且<strong>可重复</strong>，集合中每个元素都有其对应索引</p><p><code>List</code> 容器中的元素都对应一个整数型序号记载其在容器中的位置，可以根据序号存取容器中的元素</p><p>JDK API 中 <code>List</code> 接口的实现类常用的有：<code>ArrayList</code>、<code>LinkedList</code> 和 <code>Vector</code></p><p><code>ArrayList</code>、<code>LinkedList</code> 和 <code>Vector</code> 的异同：</p><p>相同：都是实现了 List 接口，存储数据的特点相同：存储有序的、可重复的数据</p><p>不同：</p><p><code>ArrayList</code>：作为 List 接口的主要实现类；线程不安全的，效率高；底层使用 <code>Object[]</code> 存储</p><p><code>LinkedList</code>：底层使用双向链表存储；对于频繁的插入和删除操作，使用此类效率比 <code>ArrayList</code> 高</p><p><code>Vector</code>：作为 List 接口的古老实现类；线程安全的，效率低；底层使用 <code>Object[]</code> 存储</p><h3 id="ArrayList-源码分析"><a href="#ArrayList-源码分析" class="headerlink" title="ArrayList 源码分析"></a>ArrayList 源码分析</h3><p>JDK7</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList list = <span class="hljs-keyword">new</span> ArrayList(); <span class="hljs-comment">// 创建了长度是 10 的 Object 数组 elementData</span><br>list.add(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// ...</span><br>list.add(<span class="hljs-number">11</span>); <span class="hljs-comment">// 如果添加导致底层 elementData 容量不够，则扩容</span><br><span class="hljs-comment">// 默认情况下扩容为原来的 1.5 倍</span><br><span class="hljs-comment">// 同时需要将原有数组中的数据复制到新的数组中</span><br><br></code></pre></div></td></tr></table></figure><p>建议开发中使用带参数的构造器：<code>new ArrayList(int initialCapacity)</code></p><p>JDK8</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList list = <span class="hljs-keyword">new</span> ArrayList(); <span class="hljs-comment">// 底层 Object 数组初始化为 &#123;&#125;</span><br><span class="hljs-comment">// 并没有创建长度为 10 的数组</span><br>list.add(<span class="hljs-number">1</span>); <span class="hljs-comment">// 第一次调用 add 方法，底层才创建了长度为 10 的数组，并将 1 添加进去</span><br><span class="hljs-comment">// 后续添加和扩容操作和 jdk7 相同</span><br></code></pre></div></td></tr></table></figure><p>JDK7 中的 ArrayList 的创建类似与单例饿汉式，JDK8 中 ArrayList 的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省了内存</p><h3 id="LinkedList-源码分析"><a href="#LinkedList-源码分析" class="headerlink" title="LinkedList 源码分析"></a>LinkedList 源码分析</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">LinkedList list = <span class="hljs-keyword">new</span> LinkedList(); <span class="hljs-comment">// 内部声明了 Node 类型的 first 和 last 属性</span><br><span class="hljs-comment">// 默认为 null</span><br>list.add(<span class="hljs-number">1</span>); <span class="hljs-comment">// 将 123 封装到 Node 中，创建 Node 对象</span><br></code></pre></div></td></tr></table></figure><p>Node 是普通双向链表的节点</p><h3 id="Vector-源码分析"><a href="#Vector-源码分析" class="headerlink" title="Vector 源码分析"></a>Vector 源码分析</h3><p>JDK7 和 8 中，通过 Vector() 创建对象时，底层都创建了长度为 10 的数组</p><p>在扩容方面，vector 默认扩容为原来数组长度的 2 倍</p><h3 id="List-接口中常用方法"><a href="#List-接口中常用方法" class="headerlink" title="List 接口中常用方法"></a>List 接口中常用方法</h3><ul><li><code>add(int inedx, E e)</code>：将 <code>e</code> 插入到 <code>index</code> 的位置</li><li><code>remove(int index)</code>：移除指定 <code>index</code> 位置的元素，并返回此元素</li><li><code>remove(E e)</code>：<code>Collection</code> 的方法</li><li><code>set(int index, E e)</code>：指定 <code>index</code> 位置的元素为 <code>e</code></li><li><code>get(int index)</code>：获取指定 <code>index</code> 位置的元素，如果越界则抛异常</li><li><code>size()</code>：返回长度</li><li><code>indexOf(E e)</code>：返回 <code>e</code> 在集合中首次出现的位置，如果不存在返回 -1</li><li><code>addAll(int index, Collection&lt;? extends E&gt; coll)</code>：从 <code>index</code> 位置开始将 <code>coll</code> 中的所有元素添加进来</li><li><code>lastIndexOf(E e)</code>：返回 <code>e</code> 在集合中末次出现的位置，如果不存在返回 -1</li><li><code>subList(int fromIndex, int toIndex)</code>：返回从 <code>fromIndex</code> 到 <code>toIndex</code> 位置（左闭右开）的子集合</li></ul><p>遍历：</p><ul><li>iterator 迭代器方式</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Iterator it = list.iterator();<br><span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>    println(iterator.next());<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>foreach 循环</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Object o : list) &#123;<br>    println(o);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>普通 for 循环</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>    println(list.get(i));<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h2><p><code>HashSet</code>：作为 Set 接口的主要实现类；线程不安全；可存储 <code>null</code> 值</p><p><code>LinkedHashSet</code>：作为 HashSet 的子类；遍历其数据时，可以按照添加的顺序遍历</p><p><code>TreeSet</code>：可以按照添加对象的指定属性进行排序</p><h3 id="对-Set-无序性，不可重复的理解"><a href="#对-Set-无序性，不可重复的理解" class="headerlink" title="对 Set 无序性，不可重复的理解"></a>对 Set 无序性，不可重复的理解</h3><p>无序性</p><p>不等于随机性。存储的数据在数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的</p><p>不可重复性</p><p>保证添加的元素按照 equals 方法判断时，不能返回 true</p><h3 id="HashSet-中元素添加过程"><a href="#HashSet-中元素添加过程" class="headerlink" title="HashSet 中元素添加过程"></a>HashSet 中元素添加过程</h3><p>向 HashSet 中添加元素 <code>a</code>，首先调用 <code>a</code> 所在类的 <code>hashCode</code> 方法计算 <code>a</code> 的哈希值</p><p>此哈希值接着通过某种算法计算出在 <code>HashSet</code> 底层数组中的存放位置（即为索引位置）</p><p>判断数组此位置上是否已经有元素</p><p>如果此位置没有其他元素，则元素 <code>a</code> 添加成功</p><p>如有其他元素 <code>b</code>（或以链表形式存在的多个元素），则比较元素 <code>a</code> 与元素 <code>b</code> 的哈希值：</p><p>如果哈希值不相同，则元素 <code>a</code> 添加成功。如果哈希值相同，进而需要调用 <code>a</code> 所在类的 equals 方法</p><p>如果 <code>equals</code> 方法返回 <code>true</code>，元素 <code>a</code> 添加失败</p><p>如果 <code>equals</code> 返回 <code>false</code>，元素 <code>a</code> 添加成功</p><p>对于添加成功的情况，元素 <code>a</code> 与已经存在于指定索引位置上的数据以链表的方式存储</p><p>JDK7：元素 <code>a</code> 放到数组中，指向原来的元素</p><p>JDK8：原来的元素不动，指向元素 <code>a</code></p><p>数据在 HashSet 存储的结果是哈希链表</p><h3 id="hashCode-和-equals-方法的重写"><a href="#hashCode-和-equals-方法的重写" class="headerlink" title="hashCode 和 equals 方法的重写"></a><code>hashCode</code> 和 <code>equals</code> 方法的重写</h3><p>为什么 IDEA 中重写 hashCode 方法有 31 这个数字</p><ul><li>选择系数要选择尽量大的系数，因为计算出来的 hash 地址越大，所谓的冲突就越少，查找起来效率就越高</li><li>31 只占用了 5 bits，相乘造成数据溢出的概率较小</li><li>31 可以由 <code>i * 31 == (i &lt;&lt; 5) - 1</code> 来表示，现在很多虚拟机里面都有做相关优化</li><li>31 是一个素数，一个数字乘以素数最终结果只能被素数本身和 1 来整除</li></ul><p>向 Set 中添加的数据，其所在的类一定要重写 <code>hashCode</code> 和 <code>equals</code> 方法</p><h3 id="LinkedHashSet-的使用"><a href="#LinkedHashSet-的使用" class="headerlink" title="LinkedHashSet 的使用"></a><code>LinkedHashSet</code> 的使用</h3><p><code>LinkedHashSet</code> 作为 <code>HashSet</code> 的子类，在添加数据的同时，每个数据还维护了两个引用，记录了此数据的前一个数据和后一个数据</p><p>对于频繁的遍历操作，<code>LinkedHashSet</code> 效率高于 <code>HashSet</code></p><h3 id="TreeSet-的自然排序"><a href="#TreeSet-的自然排序" class="headerlink" title="TreeSet 的自然排序"></a><code>TreeSet</code> 的自然排序</h3><p>向 <code>TreeSet</code> 中添加的数据，要求是相同类的对象</p><p>两种排序方式：自然排序（实现 <code>Comparable</code> 接口）和定制排序（实现 <code>Comparator</code> 接口）</p><p>自然排序中，比较两个对象是否相同的标准为 <code>compareTo</code> 方法返回 <code>0</code>，不再是 <code>equals</code></p><p>定制排序中，比较两个对象是否相同的标准为 <code>compare</code> 方法返回 <code>0</code></p><h2 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h2><p><code>Map</code> 用来存储 <code>key-value</code> 对的数据</p><p><code>HashMap</code>：主要的实现类，线程不安全，效率高；存储 <code>null</code> 的 <code>key</code> 和 <code>value</code></p><p><code>LinkedHashMap</code>：保证遍历 <code>map</code> 元素时可以按照添加的顺序实现遍历。原理：在原有的 <code>HashMap</code> 底层结构基础上，添加了一对指针指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于 <code>HashMap</code></p><p><code>TreeMap</code>：保证按照添加的 <code>key-value</code> 对进行排序，实现排序遍历。此时考虑 <code>key</code> 的自然排序或定制排序。底层使用红黑树</p><p><code>Hashtable</code>：古老的实现类，线程安全，效率低；不能存储 <code>null</code> 的 <code>key</code> 和 <code>value</code></p><p><code>Properties</code>：常用来处理配置文件。<code>key</code> 和 <code>value</code> 都是 <code>String</code> 类型</p><p><code>HashMap</code> 底层：数组+链表（JDK7）数组+链表+红黑树（JDK8）</p><p>面试题：</p><ul><li><code>HashMap</code> 的底层实现原理</li><li><code>HashMap</code> 和 <code>HashTable</code> 的异同</li><li><code>CurrentHashMap</code> 与 <code>HashTable</code> 的区别</li></ul><h3 id="Map-结构的理解"><a href="#Map-结构的理解" class="headerlink" title="Map 结构的理解"></a>Map 结构的理解</h3><p>Map 中的 key 不可重复，无序，使用 Set 存储所有的 key。key 所在的类要重写 equals 和 hashCode 方法（以 HashMap 为例）</p><p>Map 中的 value 可重复，无序，使用 Collection 存储所有的 value。value 所在的类要重写 equals 方法</p><p>一个键值对：key-value 构成了一个 entry 对象</p><p>Map 中的 entry：无序的，不可重复的</p><h3 id="HashMap-的底层实现原理"><a href="#HashMap-的底层实现原理" class="headerlink" title="HashMap 的底层实现原理"></a>HashMap 的底层实现原理</h3><p>JDK7</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">HashMap map = <span class="hljs-keyword">new</span> HashMap();<br><span class="hljs-comment">// 在实例化以后，创建了长度是 16 的一维数组 Entry[] table</span><br>map.put(key1, value1);<br><span class="hljs-comment">// 调用 key1 所在类的 hashCode 计算 key1 的哈希值</span><br><span class="hljs-comment">// 此哈希值经过某种算法以后，得到在 Entry 数组中存放的位置</span><br><span class="hljs-comment">// 如果此位置上的数据为空，此时的 key1-value1 添加成功</span><br><span class="hljs-comment">// 如果此位置上的数据不为空，意味着此位置上存在一个或多个数据，以链表的形式存储</span><br><span class="hljs-comment">// 比较 key1 和已经存在的一个或多个数据的哈希值：</span><br><span class="hljs-comment">//   如果 key1 的哈希值与已经存在的数据的哈希值不相同，此时 key1-value1 添加成功</span><br><span class="hljs-comment">//   如果 key1 的哈希值与已经存在的某一个数据的哈希值相同</span><br><span class="hljs-comment">//     继续比较：调用 key1 所在类的 equals 方法，比较</span><br><span class="hljs-comment">//       如果 equals 方法返回 false，则 key1-value1 添加成功</span><br><span class="hljs-comment">//       如果 equals 方法返回 true，使用 value1 替换相同 key 的 value</span><br><span class="hljs-comment">// ... put 操作</span><br><span class="hljs-comment">// 在不断的添加过程中，会涉及到扩容问题。</span><br><span class="hljs-comment">// 默认的扩容方式：扩容为原来容量的 2 倍，并将原有数据复制过来</span><br></code></pre></div></td></tr></table></figure><p>在不断的添加过程中，会涉及到扩容问题，当<strong>超出临界值</strong>且<strong>要存放的位置非空</strong>时进行扩容，默认扩容为原来容量的 2 倍，并将原有数据复制过来</p><p>JDK8</p><p>JDK8 相较于 JDK7 在底层实现方面的不同</p><ul><li><code>new HashMap()</code> 没有创建一个长度为 16 的数组</li><li>底层的数组是 <code>Node[]</code> 而非 <code>Entry[]</code></li><li>首次调用 <code>put</code> 方法时，底层创建长度为 16 的数组</li><li>JDK7 底层结构只有数组和链表。JDK8 中底层结构：数组+链表+红黑树</li><li>当数组某一个索引位置上的元素以链表形式存在的数据个数大于 8 且当前数组长度大于 64，此时此索引位置上的所有数据改为使用红黑树存储</li></ul><p>一些重要的常量和变量</p><p><code>DEFAULT_INITIAL_CAPACITY</code>：默认容量：16</p><p><code>DEFAULT_LOAD_FACTOR</code>：HashMap 的默认加载因子：0.75</p><p><code>threshold</code>：扩容的临界值，=容量 x 填充因子：默认为 16 x 0.75 = 12</p><p><code>TREEIFY_THRESHOLD</code>：Bucket 中链表长度大于该默认值，转化为红黑树</p><p><code>MIN_TREEIFY_CAPACITY</code>：桶中的 Node 被树化时最小的 hash 表容量：64</p><h3 id="LinkedHashMap-的底层实现"><a href="#LinkedHashMap-的底层实现" class="headerlink" title="LinkedHashMap 的底层实现"></a>LinkedHashMap 的底层实现</h3><p>源码中的节点添加了两个引用 before、after，能够记录元素添加的先后顺序</p><h3 id="Map-中常用方法"><a href="#Map-中常用方法" class="headerlink" title="Map 中常用方法"></a>Map 中常用方法</h3><p>添加、删除、修改</p><ul><li><code>put(K key, V value)</code>：将键值对添加到（或修改）当前 <code>map</code> 对象</li><li><code>putAll(Map&lt;K, V&gt; m)</code>：将 <code>m</code> 中的所有键值对添加到当前 <code>map</code> 中</li><li><code>remove(K key)</code>：移除指定 <code>key</code> 值的键值对，返回 <code>value</code></li><li><code>clear()</code>：清空当前 <code>map</code> 中所有的数据</li></ul><p>查询</p><ul><li><code>get(K key)</code>：获取指定 <code>key</code> 对应的 <code>value</code></li><li><code>containsKey(K key)</code>：是否包含指定的 <code>key</code></li><li><code>containsValue(V value)</code>：是否包含指定的 <code>value</code></li><li><code>size()</code>：返回 <code>map</code> 中键值对的个数</li><li><code>isEmpty()</code>：判断当前 <code>map</code> 是否为空</li><li><code>equals(Object obj)</code>：判断当前 <code>map</code> 和参数对象 <code>obj</code> 是否相等</li></ul><p>视图操作</p><ul><li><code>keySet()</code>：返回所有 <code>key</code> 构成的 <code>Set</code> 集合</li><li><code>values()</code>：返回所有 <code>value</code> 构成的 <code>Collection</code> 集合</li><li><code>Set entrySet()</code>：返回所有键值对构成的 <code>Set</code> 集合</li></ul><h3 id="TreeMap-两种添加方式的使用"><a href="#TreeMap-两种添加方式的使用" class="headerlink" title="TreeMap 两种添加方式的使用"></a>TreeMap 两种添加方式的使用</h3><p>向 TreeMap 中添加键值对，要求 key 必须是由同一个类创建的对象</p><p>因为要按照 key 进行排序：自然排序、定制排序</p><h3 id="Properties-处理属性文件"><a href="#Properties-处理属性文件" class="headerlink" title="Properties 处理属性文件"></a>Properties 处理属性文件</h3><p>Properties 类是 HashTable 的子类，该类用于处理属性文件</p><p>由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型</p><p>存取数据时，建议使用 <code>setProperty(String key, String value)</code> 方法和 <code>getProperty(String key)</code> 方法</p><p>默认情况配置文件放在项目的根目录下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>FileInputSystem in = <span class="hljs-keyword">new</span> FileInputSystem(<span class="hljs-string">&quot;jdbc.properties&quot;</span>);<br>props.load(in);<br>String name = props.getProperty(<span class="hljs-string">&quot;name&quot;</span>);<br>String pass = props.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br></code></pre></div></td></tr></table></figure><h2 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h2><p>Collections 是一个操作 Set、List、Map 等集合的工具类</p><p>Collections 中提供了一系列的静态方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</p><h3 id="排序操作的静态方法"><a href="#排序操作的静态方法" class="headerlink" title="排序操作的静态方法"></a>排序操作的静态方法</h3><ul><li><code>reverse(List)</code>：反转 <code>List</code> 中元素的顺序</li><li><code>shuffle(List)</code>：对 <code>List</code> 集合元素进行随机排序</li><li><code>sort(List)</code>：根据元素的自然顺序对指定 <code>List</code> 集合元素按升序排序</li><li><code>sort(List, Comparator)</code>：根据指定的 <code>Comparator</code> 产生的顺序对 <code>List</code> 集合元素进行排序</li><li><code>swap(List, int, int)</code>：将指定 <code>List</code> 集合中的 i 处元素和 j 处元素进行交换</li></ul><h3 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h3><ul><li><code>max(Collection)</code>：根据元素的自然排序，返回给定集合中的最大元素</li><li><code>max(Collection, Comparator)</code>：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li><li><code>min(Collection)</code>：最小</li><li><code>min(Collection, Comparator)</code>：最小</li><li><code>frequency(Collection, Object)</code>：返回指定集合中指定元素出现的次数</li><li><code>copy(List dest, List src)</code>：将 src 中的内容复制到 dest 中，dest 的 size 必须要大于等于 src 的 size，否则会抛异常</li><li><code>replaceAll(List list, Object oldVal, Object newVal)</code>：使用新值替换 List 对象的所有旧值</li></ul><h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h3><p>Collections 中提供了多个 <code>synchronizedXxx</code> 方法，该方法可将指定集合包装成线程同步的集合，从而解决多线程兵法访问集合时的线程安全问题</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java 集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 笔记 - 注解</title>
    <link href="/2021/02/17/java-notes-annoation/"/>
    <url>/2021/02/17/java-notes-annoation/</url>
    
    <content type="html"><![CDATA[<p>Java 注解的笔记</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>注解是代码里的特殊标记，这些标记可以在编译、类加载和运行时被读取并执行相应的处理。通过使用注解，程序员可以在不改变程序原有逻辑的情况下在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署</p><p>注解可以像修饰符一样被树勇，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在注解的 <code>name=value</code> 对中</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>生成文档相关的注解</p><p>在编译时进行格式检查</p><p>JDK 内置三个注解</p><ul><li><code>@Override</code>：重写父类<strong>方法</strong></li><li><code>@Deprecated</code>：表示所修饰的元素已经过时</li><li><code>@SuppressWarnings</code>：抑制编译器警告</li></ul><p>跟踪代码依赖性，实现替代配置文件的功能</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><ul><li>定义新的 <code>Annotation</code> 类型使用 <code>@interface</code> 关键字</li><li>自定义注解自动继承了 <code>java.lang.annotation.Annotation</code> 接口</li><li><code>Annotation</code> 的成员变量在 <code>Annotation</code> 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、 <code>String</code> 类型、<code>Class</code> 类型、<code>enum</code> 类型、 <code>Annotation</code> 类型以上所有类型的数组。</li><li>可以在定义 <code>Annotation</code> 的成员变量时为其指定初始值，指定成员变量的初始值可使用 <code>default</code> 关键字</li><li>如果只有一个参数成员，建议使用参数名为 <code>value</code></li><li>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是<code>参数名=参数值</code>，如果只有一个参数成员，且名称为 <code>value</code>，可以省略 <code>value=</code></li><li>没有成员定义的 <code>Annotation</code> 称为标记；包含成员变量的 <code>Annotation</code> 称为元数据 <code>Annotation</code></li><li>注意：自定义注解必须配上注解的信息处理流程（使用反射）才有意义</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;Hello&quot;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>JDK 的元注解对现有的注解进行解释</p><p>JDK5 提供了四个标准的元注解类型，分别是</p><ul><li><code>Retention</code>：只能用于修饰一个 <code>Annotation</code> 定义，用于指定该 <code>Annotation</code> 的生命周期，<code>@Rentention</code> 包含一个 <code>RetentionPolicy</code> 类型的成员变量,使用 <code>@Rentention</code> 时必须为该 <code>value</code>成员变量指定值<ul><li><code>RetentionPolicy.SOURCE</code>：在源文件中有效（即源文件保留），编译器直接丢弃这种策眳的注释</li><li><code>RetentionPolicy.CLASS</code>：在 <code>class</code> 文件中有效（即 <code>class</code> 保留），当运行 Java 程序时，JVM 不会保留注解。这是默认值</li><li><code>RetentionPolicy.RUNTIME</code>：在运行时有效（即运行时保留），当运行 Java 程序时，JVM 会保留注释。程序可以通过反射获取该注释</li></ul></li><li><code>Target</code>：用于指定被修饰的注解能用于修饰哪些元素，包含一个名为 value 的成员变量，类型为 <code>ElementType</code> 数组<ul><li><code>CONSTRUCTOR</code>：用于描述构造器</li><li><code>FIELD</code>：用于描述字段</li><li><code>LOCAL_VARIABLE</code>：用于描述局部变量</li><li><code>METHOD</code>：用于描述方法</li><li><code>PACKAGE</code>：用于描述包</li><li><code>PARAMETER</code>：用于描述参数</li><li><code>TYPE</code>：用于描述类、接口（包括注解类型）或 <code>enum</code> 声明</li></ul></li><li><code>Documented</code>：用于指定被该元注解修饰的注解类将被 javadoc 工具提取成文档。默认情况下，<code>javadoc</code> 是不包括注解的。定义为 <code>Document</code> 的注解必须设置 <code>Retention</code> 值为 <code>RUNTIME</code></li><li><code>Inherited</code>：被它修饰的类具有继承性，如果某个类使用了被 <code>Inherited</code> 修饰的注解，则其子类自动具有该注解，实际使用中使用较少</li></ul><p>自定义注解通常会指明两个元注解：<code>Retention</code> 和 <code>Target</code></p><h2 id="JDK8-注解新特性"><a href="#JDK8-注解新特性" class="headerlink" title="JDK8 注解新特性"></a>JDK8 注解新特性</h2><h3 id="可重复注解"><a href="#可重复注解" class="headerlink" title="可重复注解"></a>可重复注解</h3><p>如果想使用两个相同的注解</p><ul><li>在 <code>MyAnnotation</code> 声明 <code>@Repeatable</code>，成员值为 <code>MyAnnotations.class</code></li><li><code>MyAnnotation</code> 的 <code>Target</code>、<code>Retention</code> 和 <code>Inherited</code> 必须和 <code>MyAnnotations</code> 的相同</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// before jdk8</span><br><span class="hljs-comment">// err</span><br><span class="hljs-comment">// @MyAnnotation(&quot;hi&quot;)</span><br><span class="hljs-comment">// @Myannotation(&quot;abc&quot;)</span><br><span class="hljs-meta">@MyAnnotations(&#123;@MyAnnotation(&quot;hi&quot;), @Myannotation(&quot;abc&quot;)&#125;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span> </span>&#123; <span class="hljs-comment">/* ... */</span>&#125;<br><br><span class="hljs-meta">@interface</span> MyAnnotation &#123; <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;hello&quot;</span>; &#125;<br><br><span class="hljs-meta">@interface</span> MyAnnotations &#123; MyAnnotation[] value(); &#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// after jdk8</span><br><span class="hljs-meta">@MyAnnotation(&quot;hi&quot;)</span><br><span class="hljs-meta">@Myannotation(&quot;abc&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span> </span>&#123; <span class="hljs-comment">/* ... */</span>&#125;<br><br><span class="hljs-meta">@Repeatable(MyAnnotations.class)</span><br><span class="hljs-meta">@interface</span> MyAnnotation &#123; <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;hello&quot;</span>; &#125;<br><br><span class="hljs-meta">@interface</span> MyAnnotations &#123; MyAnnotation[] value(); &#125;<br></code></pre></div></td></tr></table></figure><h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><p><code>ElementType</code> 里面多了两个：<code>TYPE_PARAMETER</code>，<code>TYPE_USE</code></p><p>在 Java8 之前，注解只能是在声明的地方使用，Java8 开始，注解可以应用在任何地方</p><ul><li><code>TYPE_PARAMETER</code>：表示该注解能写在类型变量的声明语句中（如泛型声明）</li><li><code>TYPE_USE</code>：表示该注解能写在使用类型的任何语句中</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;@<span class="hljs-title">TypeDefine</span>() <span class="hljs-title">U</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> U u;<br>    <span class="hljs-keyword">public</span> &lt;<span class="hljs-meta">@TypeDefine()</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span> </span>&#123;&#125;<br>&#125;<br><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE_PARAMETER&#125;)</span><br><span class="hljs-meta">@interface</span> TypeDefine &#123;&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java 注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建 Docker 镜像</title>
    <link href="/2021/01/22/build-custom-docker-images/"/>
    <url>/2021/01/22/build-custom-docker-images/</url>
    
    <content type="html"><![CDATA[<p>构建 Docker 镜像的方法</p><a id="more"></a><p>构建 Docker 镜像可以让别人也可以构建出相同的环境</p><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><h3 id="查看更改"><a href="#查看更改" class="headerlink" title="查看更改"></a>查看更改</h3><p>在终端中输入 <code>docker diff CONTAINER</code> 来查看容器的变动，其中 A 是新增的文件，C 是修改的文件，D 是删除的文件</p><h3 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h3><p>在终端中输入 <code>docker commit CONTAINER username/image-name:tag</code> 来提交更改，username 是自己定义的用户名，image-name 是镜像名称，<code>tag</code> 是标签（版本号），可以是数字、字符串等</p><p>示例：<code>docker commit foobar mazixiang/foobar:0.1.0</code></p><p>之后就可以在本地看到提交的 Docker 镜像了</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>在项目文件夹下新建 Dockerfile 文件，然后添加字段</p><ul><li><code>FROM</code> 表示构建镜像的基础</li><li><code>RUN</code> 构建镜像时执行的命令</li><li><code>WORKDIR</code> 定义工作目录</li><li><code>COPY</code> 将本机文件拷贝到容器中</li><li><code>CMD</code> 指定容器运行时要执行什么命令，只能有一个</li></ul><p>在项目文件夹下执行 <code>docker build -t username/image-name:tag .</code> 来构建容器</p><p>例</p><figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> ubuntu<br><span class="hljs-keyword">RUN</span><span class="bash"> sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt install nodejs -y</span><br><span class="hljs-keyword">WORKDIR</span><span class="bash"> /app</span><br><span class="hljs-keyword">COPY</span><span class="bash"> . .</span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;test.js&quot;</span>]</span><br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile 参考文档</a></p><p><a href="https://www.bilibili.com/video/BV1v5411G7xc">BiliBili 自建 Docker 镜像 - CodingStartip</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础 Docker 命令</title>
    <link href="/2021/01/21/basic-docker-commands/"/>
    <url>/2021/01/21/basic-docker-commands/</url>
    
    <content type="html"><![CDATA[<p>介绍一些基础的 Docker 命令</p><a id="more"></a><h2 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a><code>docker ps</code></h2><p><code>ps</code> 命令用于查看正在运行的镜像的状态</p><p><code>ps -a</code> 命令可以查看所有容器</p><h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a><code>docker run</code></h2><p>run 命令用于建立并运行一个容器，常用参数有</p><ul><li><code>-i</code>：与这个容器互动</li><li><code>-t</code>：创建一个终端</li><li><code>--name 容器名称</code>：容器的名称</li><li><code>-p 本机端口:虚拟机端口</code>：容器的端口映射</li><li><code>-d</code>：启动为 detached 模式，不进入容器中</li><li><code>-v 本机路径:虚拟机路径</code>：将电脑中的文件映射到容器中，允许容器获取指定位置的文件</li></ul><p>例 <code>docker run -it --name ubuntu -p 8080:80 -v $(pwd):/app ubuntu:lts</code></p><h2 id="容器匹配"><a href="#容器匹配" class="headerlink" title="容器匹配"></a>容器匹配</h2><p>下面几个命令中的 CONTAINER 可以是：</p><ul><li>容器名称</li><li>容器 ID</li><li>容器 ID 的前几位，Docker 会进行模糊匹配</li></ul><h2 id="docker-start-CONTAINER"><a href="#docker-start-CONTAINER" class="headerlink" title="docker start CONTAINER"></a><code>docker start CONTAINER</code></h2><p><code>start</code> 命令用于启动一个已经停止的容器</p><h2 id="docker-stop-CONTAINER"><a href="#docker-stop-CONTAINER" class="headerlink" title="docker stop CONTAINER"></a><code>docker stop CONTAINER</code></h2><p><code>stop</code> 命令用于停止一个正在运行的容器</p><h2 id="docker-attach-CONTAINER"><a href="#docker-attach-CONTAINER" class="headerlink" title="docker attach CONTAINER"></a><code>docker attach CONTAINER</code></h2><p><code>attach</code> 命令用于进入到一个正在运行的容器中</p><h2 id="docker-rm-CONTAINER"><a href="#docker-rm-CONTAINER" class="headerlink" title="docker rm CONTAINER"></a><code>docker rm CONTAINER</code></h2><p><code>rm</code> 命令用于移除一个容器</p><h2 id="docker-image-ls"><a href="#docker-image-ls" class="headerlink" title="docker image ls"></a><code>docker image ls</code></h2><p><code>image ls</code> 命令可以查看所有本地镜像</p><h2 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a><code>docker rmi</code></h2><p><code>rmi</code> 命令可以删除指定的本地镜像，释放空间</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/BV1vD4y1X7ce">BiliBili 初探 Docker - CodingStartup</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 设置锐捷客户端为自启动</title>
    <link href="/2020/10/19/set-ruijie-client-to-self-start-on-ubuntu/"/>
    <url>/2020/10/19/set-ruijie-client-to-self-start-on-ubuntu/</url>
    
    <content type="html"><![CDATA[<p>如何用 Linux 的 systemd 让锐捷客户端自启动</p><a id="more"></a><h2 id="我为什么要换为-Ubuntu"><a href="#我为什么要换为-Ubuntu" class="headerlink" title="我为什么要换为 Ubuntu"></a>我为什么要换为 Ubuntu</h2><p>Windows 10 系统实在没法用来开发，最近遇到的问题：</p><ul><li>PowerShell Git 客户端显示 Git log 乱码，按照网上大多数教程都没用</li><li>PowerShell Python 下虚拟环境 Virtualenv 显示颜色过于鲜艳</li><li>没有原生 GCC、G++ 编译器，安装 MinGW 频繁报错</li><li>系统的大多数编程环境（如 Python）无法一键进行更新</li></ul><p>实在用不下去，添加了 Ubuntu 系统，和 Windows 10 组了一个双系统，总体来说兼容性很好，没有发生致命错误，小错误倒是一堆，而且还有很多必须要用但是不兼容的软件，例如本文章的锐捷客户端，所以来记录一下如何配置锐捷客户端并且设置为自启动</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>硬件环境：DELL G3 3579</p><p>操作系统：Ubuntu 20.04LTS</p><h2 id="官方客户端"><a href="#官方客户端" class="headerlink" title="官方客户端"></a>官方客户端</h2><p>锐捷的官方客户端需要网卡加载以后再运行，没法进行 <code>systemd</code> 配置，所以不使用官方客户端</p><h2 id="第三方客户端"><a href="#第三方客户端" class="headerlink" title="第三方客户端"></a>第三方客户端</h2><p>这里使用 minieap 作为认证客户端，minieap 的 <a href="https://github.com/updateing/minieap">GitHub 链接</a></p><p>首先，克隆仓库</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/updateing/minieap.git<br><span class="hljs-comment"># clone github repo</span><br></code></pre></div></td></tr></table></figure><p>转到仓库 <code>cd minieap</code></p><p>安装依赖 <code>sudo apt install gcc g++ cmake</code></p><p>进行编译 <code>make</code></p><p>可以直接使用 <code>$&#123;你的 minieap 目录路径&#125;/minieap -h</code> 来查看文档，说明基本命令</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-variable">$&#123;你的 minieap 目录路径&#125;</span>/minieap -u <span class="hljs-variable">$&#123;你的用户名&#125;</span> -p <span class="hljs-variable">$&#123;你的密码&#125;</span> -n <span class="hljs-variable">$&#123;你的网卡名&#125;</span> -b 1<br><span class="hljs-comment"># -b 1 是在后台运行的意思</span><br></code></pre></div></td></tr></table></figure><p>就可以使用基本的认证功能了</p><h2 id="设置开机自启动"><a href="#设置开机自启动" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h2><h3 id="新方案"><a href="#新方案" class="headerlink" title="新方案"></a>新方案</h3><p>使用一段事件之后，发现旧办法似乎只能在重新启动时生效，在纯开机时无法生效，这里介绍一种新的办法：通过 systemd 系统服务管理来设置开机启动，下面介绍步骤：</p><p>使用管理员权限在 <code>/lib/systemd/system/</code> 下建立新文件 <code>minieap.service</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo touch /lib/systemd/system/minieap.service<br><span class="hljs-comment"># create minieap.service in /lib/systemd/system/</span><br></code></pre></div></td></tr></table></figure><p>使用文本编辑器打开此文件，这里使用 vim 文本编辑器</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo vim /lib/systemd/system/minieap.service<br><span class="hljs-comment"># edit /lib/systemd/system/minieap.service with vim</span><br></code></pre></div></td></tr></table></figure><p>输入如下内容</p><figure class="highlight plain"><figcaption><span>text</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">[Unit]<br>Description&#x3D;Minieap authentication service<br>After&#x3D;etcd.service<br><br>[Service]<br>Type&#x3D;simple<br>ExecStart&#x3D;sudo &#x2F;opt&#x2F;minieap&#x2F;minieap<br>ExecStop&#x3D;sudo &#x2F;opt&#x2F;minieap&#x2F;minieap -k<br>RestartSec&#x3D;10<br>Restart&#x3D;on-failure<br><br>[Install]<br>WantedBy&#x3D;multi-user.target<br></code></pre></div></td></tr></table></figure><p>简单介绍一下各个字段</p><ul><li>Description：此服务单元的描述，可以随便写</li><li>After：在 etcd.service 服务之后启动</li><li>Type：此服务的类型，simple 是最普通的类型</li><li>ExecStart：启动此服务时候进行的脚本</li><li>ExecStop：停止此服务时候进行的脚本</li><li>RestartSec：systemd 重启服务之前，需要等待的秒数</li><li>Restart：sshd 退出知乎，systemd 的重启方式，on-failure 表示任何以外的失败，将重启 sshd，如果 sshd 正常停止，他就不会重启</li><li>WantedBy：表示该服务所在的 Target，systemd 的默认启动 Target 是 multi-user.target</li></ul><p>编辑完毕后执行 <code>sudo systemctl enable minieap.service</code> 命令设置开机自启动</p><h3 id="旧方案（可能会失效）"><a href="#旧方案（可能会失效）" class="headerlink" title="旧方案（可能会失效）"></a>旧方案（可能会失效）</h3><p>打开程序坞中的 <code>Startup Applications</code>，添加一条任务，名称是 minieap，命令是 <code>$&#123;你的 minieap 目录路径&#125;/minieap -u $&#123;你的用户名&#125; -p $&#123;你的密码&#125; -n $&#123;你的网卡名&#125; -b 1</code> 即可完成设置</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="minieap-用法"><a href="#minieap-用法" class="headerlink" title="minieap 用法"></a>minieap 用法</h3><p>minieap 的 <a href="https://github.com/updateing/minieap">GitHub 链接</a></p><h3 id="systemd-资料"><a href="#systemd-资料" class="headerlink" title="systemd 资料"></a>systemd 资料</h3><p><a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html">Systemd 入门教程：实战篇 - 阮一峰的网络日志</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PowerShell 快速复制文件内容到剪贴板</title>
    <link href="/2020/09/14/copy-file-content-with-powershell/"/>
    <url>/2020/09/14/copy-file-content-with-powershell/</url>
    
    <content type="html"><![CDATA[<p>介绍使用 Windows PowerShell 快速复制文件内容到剪贴板的方法</p><a id="more"></a><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>假设要复制当前目录下的 <code>file.txt</code>，打开 PowerShell，输入</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">&gt; <span class="hljs-built_in">Get-Content</span> file.txt | clip<br></code></pre></div></td></tr></table></figure><p>即可将 <code>file.txt</code> 的内容复制到剪贴板</p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PowerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL Server 8 的远程连接错误 ERROR 2003 解决办法</title>
    <link href="/2020/09/12/mysql-remote-connection-error-2003/"/>
    <url>/2020/09/12/mysql-remote-connection-error-2003/</url>
    
    <content type="html"><![CDATA[<p>简单介绍 MySQL Server 8 的远程连接错误 ERROR 2003 解决办法</p><a id="more"></a><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>购买了一台阿里云服务器，但是我的域名没法备案，无法用来存放网页，所以想将其作为数据库服务器，在服务器上运行了 MySQL Server 8.0 数据库软件，之后发现无法通过 DataGrip 软件连接，开始排查原因。</p><h2 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h2><p>服务器是阿里云的最低配服务器，安装的是 Ubuntu20.04 - LTS 系统，有基础的开发环境</p><h2 id="数据库用户问题"><a href="#数据库用户问题" class="headerlink" title="数据库用户问题"></a>数据库用户问题</h2><p>远程连接数据库并且通过 MySQL Shell 创建并授权一个用户</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;tone&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">identified</span> <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123123&#x27;</span>;<br><br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">on</span> *.* <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;tone&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">grant</span> <span class="hljs-keyword">option</span>;<br></code></pre></div></td></tr></table></figure><p>之后打开本地电脑上面的软件，发现 DataGrip 报错，输出</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Plain"><br>[08S01] Communications link failure<br><br>The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.<br>java.net.ConnectException: Connection refused: connect.<br></code></pre></div></td></tr></table></figure><p>怀疑是密码的问题，于是查看了一下，默认的密码格式为 <code>caching_sha2_password</code>，但 <code>root</code> 用户的密码格式为 <code>mysql_native_password</code>，所以进行了操作修改了密码格式</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;zhangsan&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">IDENTIFIED</span> <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;zhangsan111&#x27;</span>;<br></code></pre></div></td></tr></table></figure><p>发现仍然无法连接</p><h2 id="防火墙端口问题"><a href="#防火墙端口问题" class="headerlink" title="防火墙端口问题"></a>防火墙端口问题</h2><p>查阅网上对 <code>jdbc</code> 的 <code>java.net.ConnectException: Connection refused: connect.</code> 的说明，可能是端口问题，于是开始排查服务器的防火墙。</p><p>首先，打开阿里云控制台的安全组，将 MySQL 运行的端口（默认为 3306）对所有 IP 地址开放，还是无法连接，然后在 Linux 上安装 nmap 软件查看开放的端口</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo apt install nmap<br>...<br>$ nmap localhost<br>Starting Nmap 7.80 ( https://nmap.org ) at 2020-09-12 22:22 CST<br>Nmap scan report <span class="hljs-keyword">for</span> localhost (127.0.0.1)<br>Host is up (0.0000030s latency).<br>Other addresses <span class="hljs-keyword">for</span> localhost (not scanned): ::1<br>Not shown: 997 closed ports<br>PORT     STATE SERVICE<br>22/tcp   open  ssh<br>80/tcp   open  http<br>3306/tcp open  mysql<br><br>Nmap <span class="hljs-keyword">done</span>: 1 IP address (1 host up) scanned <span class="hljs-keyword">in</span> 0.05 seconds<br></code></pre></div></td></tr></table></figure><p>发现所有端口均开放正常，也没有防火墙之类的问题，于是继续排查问题</p><h2 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h2><p>为了更加精确地排查错误，我使用了 Ubuntu - WSL 安装了 MySQL-Client-8.0</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo apt install mysql-client-8.0<br>...<br></code></pre></div></td></tr></table></figure><p>使用本地的 MySQL 客户端连接服务器后，才精准地定位到了错误：</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Plain">Enter password:<br>ERROR 2003 (HY000): Can&#39;t connect to MySQL server on &#39;47.101.58.125&#39; (111)<br></code></pre></div></td></tr></table></figure><p>于是开始上网查找 ERROR 2003 的解决方法，发现了提示：ERROR 2003 有可能和服务器端的配置有关系，马上找到 <code>/etc/mysql/my.cnf</code></p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Plain">!includedir &#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;<br>!includedir &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;<br></code></pre></div></td></tr></table></figure><p>发现有两个目录：</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Plain">&#x2F;etc&#x2F;mysql&#x2F;conf.d<br>├── mysql.cnf<br>└── mysqldump.cnf<br><br>&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d<br>├── mysql.cnf<br>└── mysqld.cnf<br></code></pre></div></td></tr></table></figure><p>分别查看这四个文件，发现只有 <code>/etc/mysql/mysql.conf.d/mysqld.cnf</code> 有一些内容，其中，网上的资料说可能与 <code>bind-address=127.0.0.1</code> 有关系，而这个文件正好有一行，所以尝试修改为我的服务器的 IP 地址，发现不行。于是去查了一下有关这个属性的资料，得知，这个属性是指定 TCP/IP 的配置，将其注释掉，重启 MySQL 服务，DataGrip 连接成功，MySQL 客户端连接成功。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我本以为远程连接服务器上的数据库是非常简单的，只需要一个用户和密码就可以连接了。但是，实际操作服务器时，还是有很多的细节没有注意，导致了多次的失败，所以对于任何事情一定要多去实践，只有多实践才能知道有哪些不足。纸上得来终觉浅，绝知此事要躬行。</p><p>许多事情，不要觉得简单就去用图形界面，拿这次举例，DataGrip 是 JetBrains 公司推出的带有图形界面的数据库管理软件，但是他连接失败只报出了 <code>java.net.ConnectException</code> 错误，导致我排查错误的方向不对，而命令行上面的 <code>mysql-client</code> 直接报告了错误的详细信息，让我有了更精准的排查方式。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="数据库用户"><a href="#数据库用户" class="headerlink" title="数据库用户"></a>数据库用户</h3><p>创建用户并授权：<a href="http://netsite.win/2018/06/13/mysql/mysql8%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%8F%8A%E6%8E%88%E6%9D%83-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5-%E5%9D%91/">mysql8 创建用户及授权-远程连接(坑) | 永无止境</a></p><p>修改密码格式：<a href="https://blog.csdn.net/qq_22860341/article/details/85061819">mysql8 创建用户并授权_飞奔的波大爷的博客-CSDN 博客</a></p><h3 id="防火墙和端口"><a href="#防火墙和端口" class="headerlink" title="防火墙和端口"></a>防火墙和端口</h3><p>对 <code>java.net.ConnectException: Connection refused: connect.</code> 错误的解决方法：<a href="https://blog.csdn.net/u011314442/article/details/80926682">解决： java.net.ConnectException: Connection refused: connect_愿我如星君如月 … 夜夜流光相皎洁 …-CSDN 博客</a></p><p>查看正在使用的端口：<a href="https://blog.csdn.net/q361239731/article/details/53180126">linux 如何查看正在使用的端口_萝卜 Master 的博客-CSDN 博客</a></p><p>查看开放的端口：<a href="https://www.cnblogs.com/kerrycode/p/5609010.html">Linux 查看服务器开放的端口号 - 潇湘隐者 - 博客园</a></p><h3 id="服务器端配置问题"><a href="#服务器端配置问题" class="headerlink" title="服务器端配置问题"></a>服务器端配置问题</h3><p>ERROR 2003 解决方法：<a href="https://blog.csdn.net/qustdjx/article/details/26937325">MySQL 远程连接 ERROR 2003 (HY000):Cant connect to MySQL server onXXXXX(111) 的问题_qustdjx 的博客-CSDN 博客</a></p><p>ERROR 2003 解决方法：<a href="https://blog.csdn.net/a5nan/article/details/72864249">MySQL 远程访问报错 ERROR 2003 (HY000):Cant connect to MySQL server onXXXXX(111)_没事就写点-CSDN 博客</a></p><h3 id="对-bind-address-属性的解释"><a href="#对-bind-address-属性的解释" class="headerlink" title="对 bind-address 属性的解释"></a>对 bind-address 属性的解释</h3><p>官方：<a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_tmpdir">MySQL :: MySQL 8.0 Reference Manual :: 5.1.8 Server System Variables</a>，Chrome 80 以上点击 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#docs-body:~:text=a-,bind_address%20system">此链接</a>，可以直达 <code>bind-address</code> 处</p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vimium 的介绍和使用</title>
    <link href="/2020/08/22/introduction-to-vimium/"/>
    <url>/2020/08/22/introduction-to-vimium/</url>
    
    <content type="html"><![CDATA[<p>介绍 Vimium 以及基本用法</p><a id="more"></a><h2 id="介绍-Vimium"><a href="#介绍-Vimium" class="headerlink" title="介绍 Vimium"></a>介绍 Vimium</h2><p>Vimium <a href="https://vimium.github.io/">官网链接</a></p><p><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb">插件 Chrome 商店地址</a></p><p>官网介绍：Vimium 是 Google Chrome 浏览器的扩展程序，它提供了 Vim 精神用于导航和控制的键盘快捷键。</p><p>对于一部分熟练使用 Vim 文本编辑器的程序员而言，这款插件可以极为简化浏览网页的过程。</p><p>你也可以自定义 Vimium 的所有快捷键</p><h2 id="默认快捷键表"><a href="#默认快捷键表" class="headerlink" title="默认快捷键表"></a>默认快捷键表</h2><p><img src="https://s1.ax1x.com/2020/08/23/dwEY2d.png" alt="Vimium 默认快捷键表"></p><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>介绍 Vimium 插件的基础使用</p><div class="note note-warning">            <p>注意：以下说明全部基于 Vimium 的默认快捷键，所有快捷键区分大小写</p>          </div><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>使用 <code>h</code>、<code>j</code>、<code>k</code>、<code>l</code> 来作为左、下、上、右的基础移动，使用 <code>gg</code>、<code>G</code>来访问网页的开头和结尾（和 <code>Vim</code> 编辑器相同）。</p><p>使用 <code>u</code> 和 <code>d</code> 来进行半页的向上、向下滚动。</p><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><p>使用 <code>H</code>、<code>L</code> 来进行页面的后退和前进</p><p>使用 <code>f</code> 来显示当前页面所有可跳转的 URL，选择后在当前页面跳转</p><p>使用 <code>F</code> 来显示当前页面所有可跳转的 URL，选择后在新标签页跳转</p><h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><p>使用 <code>t</code> 来新建标签页</p><p>使用 <code>J</code>（或者 <code>gT</code>）、<code>K</code>（或者 <code>gt</code>）来向左右选择标签页</p><p>使用 <code>x</code> 来关闭标签页</p><p>使用 <code>X</code> 来恢复上一个关闭的标签页</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>使用 <code>o</code> 来在当前页面打开 URL、书签或者历史</p><p>使用 <code>O</code> 来在新标签页打开 URL、书签或者历史</p><p>使用 <code>b</code> 来在当前页面打开书签</p><p>使用 <code>B</code> 来在新标签页打开书签</p><p>使用 <code>T</code> 来在已经打开的页面中搜索</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>使用 <code>/</code> 来进入查找模式</p><p>使用 <code>n</code> 来查看下一个匹配结果</p><p>使用 <code>N</code> 来查看上一个匹配结果</p><h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><p>使用 <code>r</code> 来刷新页面</p><h2 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h2><p>打开插件选项可以看到一系列配置</p><p><code>Excluded URLs and keys</code> 是在指定 URL 排除指定的按键</p><p><code>Custom key mappings</code> 是重新定义按键映射，示例如下</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vimscript">&quot; 这是注释<br># 这也是注释<br><br># 将 j 键映射到向下滚动<br>map j scrollDown<br># 解除 j 键的绑定<br>unmap j<br># 解除所有键的绑定<br>unmapAll<br></code></pre></div></td></tr></table></figure><p>更多配置请自行探索</p><h2 id="另外的浏览器"><a href="#另外的浏览器" class="headerlink" title="另外的浏览器"></a>另外的浏览器</h2><p>QuteBrowser 同样是用 vim 的思想设计的浏览器，相关资料请移步其<a href="https://qutebrowser.org/">官方网站</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
      <tag>Chrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Cat 命令</title>
    <link href="/2020/07/30/linux-cat/"/>
    <url>/2020/07/30/linux-cat/</url>
    
    <content type="html"><![CDATA[<p>介绍 cat 命令的用法</p><a id="more"></a><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p><code>Linux</code> 中的 <code>cat</code> 命令用于输出文件内容，基础用法如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">cat ([args]) [filename]<br></code></pre></div></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><table><thead><tr><th align="center">短参数</th><th align="center">长参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>-A</code></td><td align="center"><code>--show-all</code></td><td align="center">等价于 <code>-vET</code></td></tr><tr><td align="center"><code>-b</code></td><td align="center"><code>--number-nonblank</code></td><td align="center">对非空行输出行编号</td></tr><tr><td align="center"><code>-e</code></td><td align="center"></td><td align="center">等价于 <code>-vE</code></td></tr><tr><td align="center"><code>-E</code></td><td align="center"><code>--show-ends</code></td><td align="center">在每行的结束处显示 <code>$</code></td></tr><tr><td align="center"><code>-n</code></td><td align="center"><code>--number</code></td><td align="center">输出所有的行的编号</td></tr><tr><td align="center"><code>-s</code></td><td align="center"><code>--sqeeze-black</code></td><td align="center">不输出多行空行</td></tr><tr><td align="center"><code>-t</code></td><td align="center"></td><td align="center">等价于 <code>-vT</code></td></tr><tr><td align="center"><code>-T</code></td><td align="center"><code>--show-tabs</code></td><td align="center">将跳格字符显示为 <code>^I</code></td></tr><tr><td align="center"><code>-V</code></td><td align="center"><code>--show-nonprinting</code></td><td align="center">使用 <code>^</code> 和 <code>M-</code> 引用，除了 <code>LFD</code> 和 <code>TAB</code> 之外</td></tr></tbody></table><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="输出文件内容"><a href="#输出文件内容" class="headerlink" title="输出文件内容"></a>输出文件内容</h3><p>显示文件 <code>FILE</code> 的内容</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">cat FILE<br></code></pre></div></td></tr></table></figure><p>显示文件 <code>FILE</code> 的内容加上行号，需要加上参数 <code>-n</code>。行号从 <code>1</code> 开始。使用 <code>-n</code> 参数时，所有空行也会显示行号</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">cat -n FILE<br></code></pre></div></td></tr></table></figure><p>忽略掉空行，用 <code>-b</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">cat -b FILE<br></code></pre></div></td></tr></table></figure><p>当遇到有连续两行以上的空白行，就代换为一行的空白行，可以使用 <code>-s</code> 参数</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">cat -s FILE<br></code></pre></div></td></tr></table></figure><h3 id="保存内容"><a href="#保存内容" class="headerlink" title="保存内容"></a>保存内容</h3><p>将标准输入保存到文件 <code>FILE</code> 中，如果文件已经存在，则覆盖掉原来的</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">cat &gt; FILE<br></code></pre></div></td></tr></table></figure><p>将标准输入追加到文件 <code>FILE</code> 末尾</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">cat &gt;&gt; FILE<br></code></pre></div></td></tr></table></figure><h3 id="合并文件"><a href="#合并文件" class="headerlink" title="合并文件"></a>合并文件</h3><p>将两个文件 <code>FILE1</code> 和 <code>FILE2</code> 的内容合并为一个文件 <code>FILE</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">cat FILE1 FILE2 &gt; FILE<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://my.oschina.net/HJCui/blog/756476">HJCui,HJCui,Linux 中 用 cat 输出文件内容 - HJCui 嘀咕屋,OSCHINA 博客</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim 关闭自动插入注释</title>
    <link href="/2020/07/26/disable-auto-comments-in-vim/"/>
    <url>/2020/07/26/disable-auto-comments-in-vim/</url>
    
    <content type="html"><![CDATA[<p>介绍如何关闭 Vim 编辑器的自动插入注释功能</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><code>Vim</code> 编辑器下，当你输入了一整行注释</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// This is the comment</span><br></code></pre></div></td></tr></table></figure><p>再按下回车，<code>Vim</code> 编辑器会自动给你在新的一行加上 <code>//</code>，这在有的时候非常不方便，我希望关闭这一项功能</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在你的 <code>.vimrc</code> 中加入</p><figure class="highlight vim"><figcaption><span>script</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">autocmd</span> FileType * <span class="hljs-keyword">setlocal</span> formatoptions-=<span class="hljs-keyword">c</span> formatoptions-=r formatoptions-=<span class="hljs-keyword">o</span><br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://vim.fandom.com/wiki/Disable_automatic_comment_insertion">Disable automatic comment insertion | Vim Tips Wiki | Fandom</a></p><p>给出了更多种解决方案，包括针对单种编程语言</p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美化 PowerShell</title>
    <link href="/2020/07/20/beautify-powershell/"/>
    <url>/2020/07/20/beautify-powershell/</url>
    
    <content type="html"><![CDATA[<p>最近重装了一遍系统，记录一下每次重装系统反复配置的软件，本文记录如何用 oh-my-posh 美化 PowerShell</p><a id="more"></a><h2 id="开放许可"><a href="#开放许可" class="headerlink" title="开放许可"></a>开放许可</h2><p>首次在计算机上启动 <code>Windows PowerShell</code> 时，现用执行策略很可能是 Restricted（默认设置），这个策略是禁止运行任何脚本的，要想打开，只需在<strong>有管理员权限的</strong> <code>PowerShell</code> 下输入 <code>set-executionpolicy remotesigned</code>即可。</p><h2 id="安装-oh-my-posh"><a href="#安装-oh-my-posh" class="headerlink" title="安装 oh-my-posh"></a>安装 oh-my-posh</h2><p>根据 <a href="https://github.com/JanDeDobbeleer/oh-my-posh#installation">oh-my-posh 的说明</a>，执行以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">&gt; <span class="hljs-built_in">Install-Module</span> posh<span class="hljs-literal">-git</span> <span class="hljs-literal">-Scope</span> CurrentUser<br>&gt; <span class="hljs-built_in">Install-Module</span> <span class="hljs-built_in">oh</span><span class="hljs-literal">-my</span><span class="hljs-literal">-posh</span> <span class="hljs-literal">-Scope</span> CurrentUser<br></code></pre></div></td></tr></table></figure><p>如果有选项全通过就可以了</p><h2 id="配置-oh-my-posh"><a href="#配置-oh-my-posh" class="headerlink" title="配置 oh-my-posh"></a>配置 oh-my-posh</h2><p>在 powershell 中输入 <code>notepad $PROFILE</code>，用记事本打开配置文件，将如下文本添加到其中即可成功配置。</p><figure class="highlight plain"><figcaption><span>posh-git</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershellImport-Module">Import-Module oh-my-posh<br>Set-Theme Paradox<br></code></pre></div></td></tr></table></figure><h2 id="安装-PowerLine-字体"><a href="#安装-PowerLine-字体" class="headerlink" title="安装 PowerLine 字体"></a>安装 PowerLine 字体</h2><p>此时通过 Windows Terminal 等软件打开会出现无法显示字符的情况，需要从 <a href="https://github.com/microsoft/cascadia-code/releases">microsoft/cascadia-code</a> 或者其他途径安装 <code>PowerLine</code> 字体，最后将终端软件（如 <code>Windows Terminal</code> 的字体配置改为你下载的那个字体。</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&quot;defaults&quot;:<br>&#123;<br>    <span class="hljs-comment">// Put settings here that you want to apply to all profiles.</span><br>    <span class="hljs-attr">&quot;colorScheme&quot;</span>: <span class="hljs-string">&quot;Dracula&quot;</span>,<br>    <span class="hljs-attr">&quot;startingDirectory&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>,<br>    <span class="hljs-attr">&quot;fontFace&quot;</span>: <span class="hljs-string">&quot;Cascadia Mono PL&quot;</span><br>&#125;,<br></code></pre></div></td></tr></table></figure><p>这里推荐一个字体网站 <a href="https://www.nerdfonts.com/">Nerd Fonts</a>，有很多 <code>PowerLine</code> 字体。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/zhaozhan/archive/2012/06/01/2529384.html">PowerShell 因为在此系统中禁止执行脚本解决方法 - Asharp - 博客园</a></p><p><a href="https://github.com/JanDeDobbeleer/oh-my-posh">JanDeDobbeleer/oh-my-posh</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows/terminal/tutorials/powerline-setup">Microsoft - 教程：在 Windows 终端中设置 Powerline</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>美化</tag>
      
      <tag>PowerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Travis CI 的构建目录中添加文件</title>
    <link href="/2020/07/19/add-custom-files-in-travisci-building-directory/"/>
    <url>/2020/07/19/add-custom-files-in-travisci-building-directory/</url>
    
    <content type="html"><![CDATA[<p>在 Travis CI 的构建目录中添加文件的方法</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><code>GitHub Pages</code> 中，要自定义域名需要添加一个 <code>CNAME</code> 文件，内容是你的域名，但是 <code>Travis CI</code> 自动构建每次都是把所有文件删除再更新库，每次我都要手动添加 <code>CNAME</code> 文件？所以开始寻找构建目录添加自己的文件的方法</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><code>Travis CI</code> 的构建环境里面有一个环境变量 <code>$TRAVIS_BUILD_DIR</code>，这个环境变量就是构建的文件夹，首先我用 <code>ls</code> 命令查看了该文件夹下的内容，发现是博客 <code>GitHub</code> 仓库的 <code>source</code> 分支的文件</p><p>得出结论：CI 系统把构建目录下的 <code>public</code> 目录部署到 <code>GitHub Pages</code> 的主分支</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在 <code>.travis.yml</code> 文件的 <code>script</code> 项下添加命令即可，本例是 <code>Hexo</code> 的博客，要在生成目录也就是 <code>public</code> 文件夹下添加<code>CNAME</code> 文件，将 <code>script</code> 项改为如下所示即可达到目的</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">script:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">&#x27;blog.mazixiang.me&#x27;</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-string">$TRAVIS_BUILD_DIR/public/CNAME</span><br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kb.kutu66.com/travis-ci/post_1642424">emmby - travis-ci - Travis yml，我如何得到 Travis 的工作目录？</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Travis CI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置 Windows Terminal</title>
    <link href="/2020/07/18/configure-windows-terminal/"/>
    <url>/2020/07/18/configure-windows-terminal/</url>
    
    <content type="html"><![CDATA[<p>最近重装了一遍系统，记录一下每次重装系统反复配置的软件，本文记录如何配置与美化 Windows Terminal</p><a id="more"></a><h2 id="打开-Windows-Terminal-配置文件"><a href="#打开-Windows-Terminal-配置文件" class="headerlink" title="打开 Windows Terminal 配置文件"></a>打开 Windows Terminal 配置文件</h2><p>在 <code>Windows Terminal</code> 窗口下按 <code>Ctrl + ,</code> （或者点击新建标签页旁边的向下箭头-设置）来用编辑器打开配置文件，我的电脑中是用 <code>VS Code</code> 打开的</p><h2 id="Dracula-主题"><a href="#Dracula-主题" class="headerlink" title="Dracula 主题"></a>Dracula 主题</h2><p>去 <a href="https://draculatheme.com/windows-terminal">Dracula 主题网站的 Windows Terminal 页面</a>，将主题的配置复制到 <code>schemes</code> 项下面</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&quot;schemes&quot;: [<br>    &#123;<br>        <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;Dracula&quot;</span>,<br>        <span class="hljs-attr">&quot;background&quot;</span> : <span class="hljs-string">&quot;#272935&quot;</span>,<br>        <span class="hljs-attr">&quot;black&quot;</span> : <span class="hljs-string">&quot;#21222C&quot;</span>,<br>        <span class="hljs-attr">&quot;blue&quot;</span> : <span class="hljs-string">&quot;#BD93F9&quot;</span>,<br>        <span class="hljs-attr">&quot;cyan&quot;</span> : <span class="hljs-string">&quot;#8BE9FD&quot;</span>,<br>        <span class="hljs-attr">&quot;foreground&quot;</span> : <span class="hljs-string">&quot;#F8F8F2&quot;</span>,<br>        <span class="hljs-attr">&quot;green&quot;</span> : <span class="hljs-string">&quot;#50FA7B&quot;</span>,<br>        <span class="hljs-attr">&quot;purple&quot;</span> : <span class="hljs-string">&quot;#FF79C6&quot;</span>,<br>        <span class="hljs-attr">&quot;red&quot;</span> : <span class="hljs-string">&quot;#FF5555&quot;</span>,<br>        <span class="hljs-attr">&quot;white&quot;</span> : <span class="hljs-string">&quot;#F8F8F2&quot;</span>,<br>        <span class="hljs-attr">&quot;yellow&quot;</span> : <span class="hljs-string">&quot;#FFB86C&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlack&quot;</span> : <span class="hljs-string">&quot;#6272A4&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlue&quot;</span> : <span class="hljs-string">&quot;#D6ACFF&quot;</span>,<br>        <span class="hljs-attr">&quot;brightCyan&quot;</span> : <span class="hljs-string">&quot;#A4FFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;brightGreen&quot;</span> : <span class="hljs-string">&quot;#69FF94&quot;</span>,<br>        <span class="hljs-attr">&quot;brightPurple&quot;</span> : <span class="hljs-string">&quot;#FF92DF&quot;</span>,<br>        <span class="hljs-attr">&quot;brightRed&quot;</span> : <span class="hljs-string">&quot;#FF6E6E&quot;</span>,<br>        <span class="hljs-attr">&quot;brightWhite&quot;</span> : <span class="hljs-string">&quot;#F8F8F2&quot;</span>,<br>        <span class="hljs-attr">&quot;brightYellow&quot;</span> : <span class="hljs-string">&quot;#FFFFA5&quot;</span><br>    &#125;<br>]<br></code></pre></div></td></tr></table></figure><p>之后在 <code>Profiles</code> 中的 <code>defaults</code> 下配置默认主题</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&quot;defaults&quot;:<br>&#123;<br>    <span class="hljs-attr">&quot;colorScheme&quot;</span>: <span class="hljs-string">&quot;Dracula&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="添加到右键菜单"><a href="#添加到右键菜单" class="headerlink" title="添加到右键菜单"></a>添加到右键菜单</h2><h3 id="自动添加注册表"><a href="#自动添加注册表" class="headerlink" title="自动添加注册表"></a>自动添加注册表</h3><p>新建 <code>wt.reg</code> 文件，用记事本打开，将如下代码拷贝到其中</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reg">Windows Registry Editor Version 5.00<br><br>[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]<br>@&#x3D;&quot;Windows Terminal Here&quot;<br>&quot;Extended&quot;&#x3D;&quot;&quot;<br><br>[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\command]<br>@&#x3D;&quot;C:\\Users\\你的用户名\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;<br></code></pre></div></td></tr></table></figure><h3 id="手动添加注册表"><a href="#手动添加注册表" class="headerlink" title="手动添加注册表"></a>手动添加注册表</h3><p>按下 <code>Win + R</code> 打开运行，输入 <code>regedit</code> 打开注册表编辑器，找到 <code>HKEY_CLASSES_ROOT\Directory\Background\shell</code>，新建一项（名字随便起，这里叫做 wt）</p><p><img src="https://s1.ax1x.com/2020/07/19/UW3rz4.png" alt="新建 wt 项"></p><p>wt 项的默认值的数据就是右键菜单的文本内容，我将其配置为“通过 Terminal 打开”</p><p>再新建一个字符串值，名称为 <code>Icon</code>，数据是 Windows Terminal 图标的绝对路径（可以通过网上下载到 <code>Windows Terminal</code> 的图标</p><p>我的 wt 项配置如下</p><p><img src="https://s1.ax1x.com/2020/07/19/UW82cQ.png" alt="wt 项配置"></p><div class="note note-primary">            <p>如果想添加快捷键，新建的项默认值是 <code>通过 Terminal 打开 (&amp;T)</code>，其中， <code>&amp;</code> 后面是你想添加的快捷键</p>          </div><p>再在 wt 项下建立 command 项，默认值的数据是到达你的 <code>wt.exe</code> 的绝对路径，一般来说是 <code>C:\Users\[你的用户名]\AppData\Local\Microsoft\WindowsApps\wt.exe</code></p><h2 id="更改启动路径"><a href="#更改启动路径" class="headerlink" title="更改启动路径"></a>更改启动路径</h2><p>经过以上操作，完成了右键菜单的添加，这部分介绍如何更改默认的启动路径</p><p>在配置文件 <code>settings.json</code> 中，<code>Profiles</code> 下面的 <code>defaults</code> 下配置默认启动路径，让每次的启动路径都是右键点击的路径</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&quot;defaults&quot;:<br>&#123;<br>    <span class="hljs-attr">&quot;colorScheme&quot;</span>: <span class="hljs-string">&quot;Dracula&quot;</span>,<br>    <span class="hljs-attr">&quot;startingDirectory&quot;</span>: <span class="hljs-string">&quot;.&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样 <code>Windows Terminal</code> 的美化和配置就完成了</p><h2 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h2><p>更多配置信息可以通过 <a href="https://docs.microsoft.com/zh-cn/windows/terminal/">Microsoft - Windows 终端</a> 去了解</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="draculatheme.com">Dracula 主题网站</a></p><p>自动添加注册表</p><p><a href="https://gist.github.com/Garwih/b4ec0d853e0f3093874e919ace7fce2f">Garwih - 将 Windows Terminal 添加到右键菜单</a></p><p>手动添加注册表</p><p><a href="https://blog.csdn.net/u011532601/article/details/106305373">Huelse - 将 Windows Terminal 添加到右键菜单</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows Terminal</tag>
      
      <tag>美化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我安装的 VSCode 插件</title>
    <link href="/2020/07/14/my-vscode-extensions/"/>
    <url>/2020/07/14/my-vscode-extensions/</url>
    
    <content type="html"><![CDATA[<p>我安装的 VSCode 插件及主要功能</p><a id="more"></a><h2 id="功能插件"><a href="#功能插件" class="headerlink" title="功能插件"></a>功能插件</h2><table><thead><tr><th align="center">插件</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=kevinkyang.auto-comment-blocks">Auto Comment Blocks</a></td><td align="center">自动生成注释块</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=aaron-bond.better-comments">Better Comments</a></td><td align="center">代码中的人性化注释，比如警告、质疑、高亮、TODO 等</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer-2">Bracket Pair Colorizer 2</a></td><td align="center">括号颜色高亮</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C/C++</a></td><td align="center">C/C++语法扩展</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=softwaredotcom.swdc-vscode">Code Time</a></td><td align="center">统计写代码的时间</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=ExodiusStudios.comment-anchors">Comment Anchors</a></td><td align="center">在评论或字符串中放置锚点,从而使导航大型文件更加容易。</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=stackbreak.comment-divider">Comment Divider</a></td><td align="center">快速分隔注释</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=RandomFractalsInc.vscode-data-preview">Data Preview</a></td><td align="center">用表格、文本、图标方式预览 json 等数据文件</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=docsmsft.docs-markdown">docs-markdown</a></td><td align="center">Markdown 写作帮助</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">ESLint</a></td><td align="center">ECMAScript 代码提示</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph">Git Graph</a></td><td align="center">Git 可视化显示</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens">GitLens</a></td><td align="center">Git 加强</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.jshint">jshint</a></td><td align="center">JavaScript 语言提示</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer">Live Server</a></td><td align="center">实时预览 Web 页面</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=MS-vsliveshare.vsliveshare">Live Share</a></td><td align="center">共享代码</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">Markdown All in One</a></td><td align="center">Markdown 写作工具</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced">Markdown Preview Enhanced</a></td><td align="center">更强力的 Markdown 预览</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint">markdownlint</a></td><td align="center">Markdown 写作提示</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense">npm Intellisense</a></td><td align="center">可自动完成导入语句中的 npm 模块</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense">Path Intellisense</a></td><td align="center">路径自动补全</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=pnp.polacode">Polacode</a></td><td align="center">将代码转换为图片</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">Prettier</a></td><td align="center">前端代码美化工具</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh">Remote - SSH</a></td><td align="center">SSH 远程开发</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl">Remote - WSL</a></td><td align="center">WSL 开发</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">Rust</a></td><td align="center">Rust 语言工具</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=Remisa.shellman">shellman</a></td><td align="center">Shell 脚本自动补全</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=Gruntfuggly.todo-tree">Todo Tree</a></td><td align="center">快速查看代码中的 TODO</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=shardulm94.trailing-spaces">Trailing Spaces</a></td><td align="center">突出显示代码后面多余的空格</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=WASTeamAccount.WebTemplateStudio-dev-nightly">Web Template Studio</a></td><td align="center">互联网应用框架脚手架，会捆绑安装 Azure 相关插件</td></tr></tbody></table><h2 id="主题插件"><a href="#主题插件" class="headerlink" title="主题插件"></a>主题插件</h2><table><thead><tr><th align="center">插件</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=dracula-theme.theme-dracula">Dracula Official</a></td><td align="center">Dracula 主题</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme">Material Icon Theme</a></td><td align="center">Material 图标风格</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一个 ns3 脚本</title>
    <link href="/2020/06/28/first-ns3-script/"/>
    <url>/2020/06/28/first-ns3-script/</url>
    
    <content type="html"><![CDATA[<p>你的第一个 ns3 脚本</p><a id="more"></a><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>这个脚本是 <code>ns-*/examples/first.cc</code>，是官方示例，本文对于这个脚本进行讲解，大部分是 Google 翻译的，来源见<a href="#%E5%8F%82%E8%80%83">参考</a></p><p>本文的 <code>ns3</code> 版本为 3.30.1，<strong>不同版本的脚本可能会不相同</strong>，请参考官方的最新文档</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>请确认你已经完成了 <code>./waf -d debug --enable-examples --enable-tests configure</code></p><p>为了配置项目以执行包含示例和测试的调试版本。还需要执行 <code>./waf</code> 来建立项目。因此，现在如果您查看目录 <code>../../build/debug/ns3</code>，您将找到<a href="#%E6%A8%A1%E5%9D%97%E5%8C%85%E5%90%AB">模块包含</a>中的四个模块包含文件。您可以查看这些文件的内容，发现它们确实在其各自的模块中包含了所有公共包含文件。</p><h2 id="模块包含"><a href="#模块包含" class="headerlink" title="模块包含"></a>模块包含</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ns3/core-module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ns3/network-module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ns3/internet-module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ns3/point-to-point-module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ns3/applications-module.h&quot;</span></span><br></code></pre></div></td></tr></table></figure><p>为了帮助我们的高级脚本用户处理系统中存在的大量包含文件，我们根据相对较大的模块对包含进行分组。我们提供了一个包含文件，该文件将递归加载每个模块中使用的所有包含文件。不必精确地查找所需的头文件，也不必正确地获取许多依赖关系，而是使您能够以较大的粒度加载一组文件。这不是最有效的方法，但是它无疑使编写脚本变得更加容易。</p><p>在构建过程中，每个 ns3 包含文件都放置在一个名为 <code>ns3</code> 的目录中（在构建目录下），以帮助避免包含文件名冲突。<code>ns3/core-module.h</code>文件与 ns3 模块相对应，您可以在下载的发行版本的 <code>src/core</code> 目录中找到该文件。如果列出此目录，则会发现大量的头文件。进行构建时，<code>Waf</code> 会根据您的配置将公共头文件放在相应的 <code>build/debug</code> 或 <code>build/optimized</code> 目录下的 <code>ns3</code> 目录中。<code>Waf</code> 还将自动生成一个模块包含文件，以加载所有公共头文件。</p><h2 id="ns3-命名空间"><a href="#ns3-命名空间" class="headerlink" title="ns3 命名空间"></a>ns3 命名空间</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ns3;<br></code></pre></div></td></tr></table></figure><p><code>ns3</code> 的实现是在 <code>ns3</code> 的命名空间实现的，所以先导入命名空间，之后就不使用复杂的 <code>ns3::</code> 了。如果你不明白这个请参考 c++ 的 <code>using namespace std;</code></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">NS_LOG_COMPONENT_DEFINE (<span class="hljs-string">&quot;FirstScriptExample&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>可以查阅官方文档来了解函数的作用，这条语句是通过引用特定名称来启用和禁用控制台消息日志记录</p><h2 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h2><p>首先声明 main 函数，就像其他的 c++ 文件一样</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span><br>main (<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])<br>&#123;<br></code></pre></div></td></tr></table></figure><p>将时间分辨率设置为 1 纳秒，同时 1 纳秒也是默认值</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Time::SetResolution (Time::NS);<br></code></pre></div></td></tr></table></figure><p>分辨率是可以表示的最小时间值（以及两个时间值之间的最小可表示差异）。您可以只更改一次分辨率。实现这种灵活性的机制有点占用内存，因此，在明确设置分辨率后，我们将释放内存，以防止进一步的更新。（如果未明确设置分辨率，则默认为一纳秒，并且在模拟开始时会释放内存。）</p><p>下两行用于启用 <code>Echo Client</code> 和 <code>Echo Server</code> 应用程序中内置的两个日志记录组件：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">LogComponentEnable(<span class="hljs-string">&quot;UdpEchoClientApplication&quot;</span>, LOG_LEVEL_INFO);<br>LogComponentEnable(<span class="hljs-string">&quot;UdpEchoServerApplication&quot;</span>, LOG_LEVEL_INFO);<br></code></pre></div></td></tr></table></figure><p>如果阅读了日志记录组件文档，会发现可以在每个组件上启用许多级别的日志记录详细程度/详细信息。这两行代码为回显客户端和服务器启用了 INFO 级别的调试日志记录。这将让应用程序在仿真期间发送和接收数据包时打印出消息。</p><p>接下来，我们将直接从事创建拓扑和运行仿真的工作。我们使用拓扑帮助器对象使这项工作尽可能容易。</p><h2 id="拓补助手"><a href="#拓补助手" class="headerlink" title="拓补助手"></a>拓补助手</h2><h3 id="NodeContainer"><a href="#NodeContainer" class="headerlink" title="NodeContainer"></a>NodeContainer</h3><p>接下来两行代码实际上将创建 ns-3 Node 对象，该对象代表模拟中的计算机。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">NodeContainer nodes;<br>nodes.Create (<span class="hljs-number">2</span>);<br></code></pre></div></td></tr></table></figure><p>在继续之前，让我们找到 <code>NodeContainer</code> 类的文档。进入给定类的文档的另一种方法是通过 <code>Doxygen</code> 页面中的 <code>Classes</code> 选项卡。应该看到出现了一组新的选项卡，其中一个是“类列表”。在该选项卡下，您将看到所有 ns-3 类的列表。向下滚动，找到 <code>ns3::NodeContainer</code>。</p><p>节点是我们的关键抽象之一。这表示一类的计算机，我们将向其中添加协议栈，应用程序和外围设备卡。<code>NodeContainer</code> 拓扑帮助器提供了一种方便的方法来创建，管理和访问我们为运行模拟而创建的任何 <code>Node</code> 对象。上面的第一行只声明了一个 <code>NodeContainer</code>，我们称之为节点。第二行在节点对象上调用 <code>Create</code> 方法，并要求容器创建两个节点。如文档中所述，这个容器将调用 <code>ns3</code> 系统，以适当地创建两个 <code>Node</code> 对象，并在内部存储指向这些对象的指针。</p><p>脚本中的节点不执行任何操作。构建拓扑的下一步是将我们的节点连接到网络中。我们支持的最简单的网络形式是两个节点之间的单点对点链接。我们将在此处构建这些链接之一。</p><h3 id="PointToPointHelper"><a href="#PointToPointHelper" class="headerlink" title="PointToPointHelper"></a>PointToPointHelper</h3><p>我们正在以一种您会非常熟悉的模式构建点对点连接，使用拓扑帮助器对象来完成将链接放在一起所需的低级工作。回想一下，我们的两个关键抽象是 <code>NetDevice</code> 和 <code>Channel</code>。在现实世界中，这些术语大致对应于外围卡和网络电缆。通常，这两件事紧密地绑在一起，不能互换，例如，以太网设备和无线通道。我们的拓扑助手遵循这种紧密的联系，因此您将使用单个 <code>PointToPointHelper</code> 在此脚本中配置和连接 <code>ns-3 PointToPointNetDevice</code> 和 <code>PointToPointChannel</code> 对象。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">PointToPointHelper pointToPoint;<br>pointToPoint.SetDeviceAttribute (<span class="hljs-string">&quot;DataRate&quot;</span>, StringValue (<span class="hljs-string">&quot;5Mbps&quot;</span>));<br>pointToPoint.SetChannelAttribute (<span class="hljs-string">&quot;Delay&quot;</span>, StringValue (<span class="hljs-string">&quot;2ms&quot;</span>));<br></code></pre></div></td></tr></table></figure><p>第一行，实例化堆栈上的 <code>PointToPointHelper</code> 对象。</p><p>第二行，告诉 <code>PointToPointHelper</code> 对象在创建 <code>PointToPointNetDevice</code> 对象时将值“5Mbps”（每秒 5 兆位）用作 <code>DataRate</code>。</p><p>从更详细的角度来看，字符串 <code>DataRate</code> 对应于我们所谓的 <code>PointToPointNetDevice</code> 的 <code>Attribute</code>。如果查看类 <code>ns3::PointToPointNetDevice</code> 的文档并找到 <code>GetTypeId</code> 方法的文档，则会找到为设备定义的属性列表。其中包括 <code>DataRate</code> 属性。大多数用户可见的 <code>ns3</code> 对象都有相似的属性列表。我们将使用此机制轻松配置仿真而无需重新编译。</p><p>第三行就是指定延迟属性，告诉 <code>PointToPointHelper</code> 使用值“2ms”（两毫秒）作为其随后创建的每个点对点通道的传播延迟的值。</p><h3 id="NetDeviceContainer"><a href="#NetDeviceContainer" class="headerlink" title="NetDeviceContainer"></a>NetDeviceContainer</h3><p>在脚本的这一点上，我们有一个包含两个节点的 <code>NodeContainer</code>。我们有一个准备好的 <code>PointToPointHelper</code>，可以用来制作 <code>PointToPointNetDevices</code> 并在它们之间连接 <code>PointToPointChannel</code> 对象。就像我们使用 <code>NodeContainer</code> 拓扑帮助对象创建用于仿真的节点一样，我们将要求 <code>PointToPointHelper</code> 完成为我们创建，配置和安装设备的工作。我们将需要具有所有已创建的 <code>NetDevice</code> 对象的列表，因此我们使用 <code>NetDeviceContainer</code> 来保存它们，就像使用 <code>NodeContainer</code> 来保存所创建的节点一样。以下两行代码，</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">NetDeviceContainer devices;<br>devices = pointToPoint.Install (nodes);<br></code></pre></div></td></tr></table></figure><p>将完成设备和通道的配置。第一行声明上述设备容器，第二行进行繁重的操作。<code>PointToPointHelper</code> 的 <code>Install</code> 方法将 <code>NodeContainer</code> 作为参数。在内部，将创建一个 <code>NetDeviceContainer</code>。对于 <code>NodeContainer</code> 中的每个节点（点对点链接必须恰好有两个），将创建一个 <code>PointToPointNetDevice</code> 并将其保存在设备容器中。创建一个 <code>PointToPointChannel</code> 并连接了两个 <code>PointToPointNetDevices</code>。当由 <code>PointToPointHelper</code> 创建对象时，先前在帮助器中设置的属性用于初始化创建的对象中的相应属性。</p><p>执行 <code>pointToPoint.Install (nodes)</code> 调用之后，我们将有两个节点，每个节点都具有一个已安装的点对点网络设备以及它们之间的单个点对点通道。两个设备都将配置为以每秒 5 兆位的速度在具有 2 毫秒传输延迟的通道上传输数据。</p><h3 id="InternetStackHelper"><a href="#InternetStackHelper" class="headerlink" title="InternetStackHelper"></a>InternetStackHelper</h3><p>现在，我们已经配置了节点和设备，但是我们的节点上没有安装任何协议栈。接下来的两行代码将解决这一问题。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">InternetStackHelper <span class="hljs-built_in">stack</span>;<br><span class="hljs-built_in">stack</span>.Install (nodes);<br></code></pre></div></td></tr></table></figure><p><code>InternetStackHelper</code> 是一个拓扑帮助程序，它用于 <code>Internet</code> 堆栈，而 <code>PointToPointHelper</code> 则是点对点网络设备。<code>Install</code> 方法将 <code>NodeContainer</code> 作为参数。执行后，它将在节点容器中的每个节点上安装 Internet 堆栈（TCP，UDP，IP 等）。</p><h3 id="Ipv4AddressHelper"><a href="#Ipv4AddressHelper" class="headerlink" title="Ipv4AddressHelper"></a>Ipv4AddressHelper</h3><p>接下来，我们需要将节点上的设备与 IP 地址相关联。我们提供了一个拓扑助手来管理 IP 地址的分配。唯一用户可见的 API 是设置在执行实际地址分配时使用的基本 IP 地址和网络掩码（这是在助手内部的较低级别完成的）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Ipv4AddressHelper address;<br>address.SetBase (<span class="hljs-string">&quot;10.1.1.0&quot;</span>, <span class="hljs-string">&quot;255.255.255.0&quot;</span>);<br>Ipv4InterfaceContainer interfaces = address.Assign (devices);<br></code></pre></div></td></tr></table></figure><p>声明一个 <code>Ipv4AddressHelper</code> 对象，并告诉它应该开始使用掩码 <code>255.255.255.0</code> 从网络 <code>10.1.1.0</code> 分配 IP 地址，以定义可分配的位。默认情况下，分配的地址将从 1 开始并单调增加，因此从该基址分配的第一个地址将是 <code>10.1.1.1</code>，然后是 <code>10.1.1.2</code>，依此类推。底层 <code>ns3</code> 系统实际上会记住分配的所有 IP 地址，如果您不小心使同一地址产生两次，将会产生致命错误（顺便说一句，这很难调试）。</p><p>下一行，执行实际的地址分配。在 <code>ns3</code> 中，我们使用 <code>Ipv4Interface</code> 对象在 IP 地址和设备之间建立关联。就像有时我们需要由助手创建的网络设备列表以供将来参考时，有时我们也需要 <code>Ipv4Interface</code> 对象的列表。<code>Ipv4InterfaceContainer</code> 提供了此功能。</p><p>现在，我们已经建立了一个点对点网络，安装了堆栈并分配了 IP 地址。此时，我们需要生成流量的应用程序。</p><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><p>ns3 系统的另一个核心抽象是应用程序。在此脚本中，我们使用 ns3 核心应用程序类 <code>UdpEchoServerApplication</code> 和 <code>UdpEchoClientApplication</code> 的两个特化。就像前面的解释一样，我们使用辅助对象来帮助配置和管理基础对象。在这里，我们使用 <code>UdpEchoServerHelper</code> 和 <code>UdpEchoClientHelper</code> 对象来让模拟更简单。</p><h3 id="UdpEchoServerHelper"><a href="#UdpEchoServerHelper" class="headerlink" title="UdpEchoServerHelper"></a>UdpEchoServerHelper</h3><p>示例脚本 <code>first.cc</code> 中的以下代码行用于在我们先前创建的节点之一上设置 UDP 回显服务器应用程序（Udp echo server application）。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">UdpEchoServerHelper <span class="hljs-title">echoServer</span> <span class="hljs-params">(<span class="hljs-number">9</span>)</span></span>;<br><br>ApplicationContainer serverApps = echoServer.Install (nodes.Get (<span class="hljs-number">1</span>));<br>serverApps.Start (Seconds (<span class="hljs-number">1.0</span>));<br>serverApps.Stop (Seconds (<span class="hljs-number">10.0</span>));<br></code></pre></div></td></tr></table></figure><p>上面代码段的第一行代码声明了 <code>UdpEchoServerHelper</code>。和往常一样，这不是应用程序本身，而是用于帮助我们创建实际应用程序的对象。我们的约定之一是将必需的属性放在辅助构造函数中。在这种情况下，除非提供了客户端也知道端口号，否则该帮助程序将无济于事。我们需要将端口号作为构造函数的参数，而不是只是选择一个并希望一切都能解决。反过来，构造函数只对传递的值执行 <code>SetAttribute</code>。如果需要，可以稍后使用 <code>SetAttribute</code> 将 <code>Port</code> 属性设置为另一个值。</p><p>与许多其他帮助器对象相似，<code>UdpEchoServerHelper</code> 对象具有 <code>Install</code> 方法。正是此方法的执行实际上导致实例化基础回显服务器应用程序并将其附加到节点。有趣的是，就像我们已经看到的其他 <code>Install</code> 方法一样，<code>Install</code> 方法将 <code>NodeContainter</code> 作为参数。这实际上是传递给方法的内容，即使在这种情况下看起来也不是这样。这里有一个 C++隐式转换正在工作，该转换获取 <code>node.Get(1)</code>的结果（返回指向节点对象的智能指针— <code>Ptr &lt;Node&gt;</code>），并将其用于构造函数中，然后传递给未命名的 <code>NodeContainer</code>。安装。如果您不知所措地在 C++代码中找到了可以编译并运行得很好的特定方法签名，请寻找这些隐式转换。</p><p>现在，我们看到 <code>echoServer.Install</code> 将在用于管理节点的 <code>NodeContainer</code> 的索引号为 1 的节点上安装 <code>UdpEchoServerApplication</code>。<code>Install</code> 将返回一个容器，该容器保存由助手创建的所有应用程序的指针（在本例中，因为我们传递了一个包含一个节点的 <code>NodeContainer</code>，所以指向一个应用程序）。</p><p>应用程序需要一些时间来“开始”生成流量，并且可能需要花费一些时间来“停止”。我们都提供。这些时间是使用 <code>ApplicationContainer</code> 方法 <code>Start</code> 和 <code>Stop</code> 设置的。这些方法采用时间参数。在这种情况下，我们使用显式的 C++ 转换序列获取 C++ 浮点数 1.0，并使用 <code>Seconds</code> 强制转换将其转换为 <code>ns3</code> 的 <code>Time</code>对象。请注意，转换规则可能由模型作者控制，并且 C++ 有其自己的规则，因此您不能总是仅假设参数将为您自动地转换。</p><p>第四行和第五行将导致回显服务器应用程序在仿真中的一秒钟启动（启用自身），并在仿真中的十秒钟停止（禁用自身）。由于我们已经声明了要在十秒执行的模拟事件（应用程序停止事件），因此模拟将至少持续十秒钟。</p><h3 id="UdpEchoClientHelper"><a href="#UdpEchoClientHelper" class="headerlink" title="UdpEchoClientHelper"></a>UdpEchoClientHelper</h3><p>回显客户端应用程序的建立方法与服务器类似。有一个由 <code>UdpEchoClientHelper</code> 管理的基础<code>UdpEchoClientApplication</code>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">UdpEchoClientHelper <span class="hljs-title">echoClient</span> <span class="hljs-params">(interfaces.GetAddress (<span class="hljs-number">1</span>), <span class="hljs-number">9</span>)</span></span>;<br>echoClient.SetAttribute (<span class="hljs-string">&quot;MaxPackets&quot;</span>, UintegerValue (<span class="hljs-number">1</span>));<br>echoClient.SetAttribute (<span class="hljs-string">&quot;Interval&quot;</span>, TimeValue (Seconds (<span class="hljs-number">1.0</span>)));<br>echoClient.SetAttribute (<span class="hljs-string">&quot;PacketSize&quot;</span>, UintegerValue (<span class="hljs-number">1024</span>));<br><br>ApplicationContainer clientApps = echoClient.Install (nodes.Get (<span class="hljs-number">0</span>));<br>clientApps.Start (Seconds (<span class="hljs-number">2.0</span>));<br>clientApps.Stop (Seconds (<span class="hljs-number">10.0</span>));<br></code></pre></div></td></tr></table></figure><p>但是，对于回显应用程序的客户端，我们需要设置五个不同的属性。前两个属性是在构造 <code>UdpEchoClientHelper</code> 时设置的。我们将传递的参数（用于内部）传递给助手，以根据我们的约定设置 <code>RemoteAddress</code> 和 <code>RemotePort</code> 属性，以在助手构造函数中创建所需的 <code>Attributes</code> 参数。</p><p>我们已经使用了 <code>Ipv4InterfaceContainer</code> 来跟踪分配给设备的 IP 地址。接口容器中的第 0 个接口将与节点容器中的第 0 个节点的 IP 地址相对应。接口容器中的第一接口对应于节点容器中第一节点的 IP 地址。因此，在第一行代码中（从上面开始），我们正在创建帮助程序并告诉它，因此将客户端的远程地址设置为分配给服务器所在节点的 IP 地址。我们还告诉它安排将数据包发送到端口 9。</p><p><code>MaxPackets</code> 属性告诉客户端我们允许其在模拟过程中发送的最大数据包数。<code>Interval</code> 属性告诉客户端在数据包之间等待多长时间，<code>PacketSize</code> 属性告诉客户端其数据包有效载荷应该有多大。通过这种特殊的属性组合，我们告诉客户端发送一个 1024 字节的数据包。</p><p>与回显服务器端一样，我们告诉回显客户端启动和停止，但是在这里，我们在启用服务器后一秒钟（在仿真两秒钟后）启动客户端。</p><h2 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h2><p>此时，我们需要做的是实际运行仿真。这是使用全局函数 <code>Simulator::Run</code> 完成的。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Simulator::Run ();<br></code></pre></div></td></tr></table></figure><p>当我们之前调用方法 <code>serverApps.Start</code> <code>serverApps.Stop</code> <code>clientApps.Start</code> <code>clientApps.Stop</code> 时，我们实际上将模拟器中的事件开始时间安排为 1.0 秒，2.0 秒，将两个事件安排为 10.0 秒。调用 <code>Simulator::Run</code> 时，系统将开始浏览预定事件列表并执行它们。首先，它将在 1.0 秒处运行事件，这将启用回显服务器应用程序（此事件可能进而安排许多其他事件）。然后它将运行安排在 t = 2.0 秒内的事件，这将启动回显客户端应用程序。同样，此事件可以安排更多事件。回显客户端应用程序中的开始事件实现将通过向服务器发送数据包来开始模拟的数据传输阶段。</p><p>将数据包发送到服务器的操作将触发一系列事件，这些事件将在后台自动安排，并将根据我们在脚本中设置的各种定时参数执行数据包回显的机制。</p><p>最终，由于我们只发送一个数据包（将 <code>MaxPackets</code> 属性设置为一个），因此由单个客户端回显请求触发的事件链将逐渐减少，并且模拟将进入空闲状态。一旦发生这种情况，剩下的事件将是服务器和客户端的 <code>Stop</code> 事件。当执行这些事件时，没有其他事件可处理，并且 <code>Simulator::Run</code> 返回。仿真完成。</p><p>剩下的就是清理。这是通过调用全局函数 <code>Simulator::Destroy</code> 来完成的。在执行辅助函数（或低级 <code>ns3</code> 代码）时，他们进行了排列，以便将钩子插入模拟器中以销毁所有已创建的对象。您不必自己跟踪任何这些对象-您要做的就是调用 <code>Simulator::Destroy</code> 并退出。<code>ns3</code> 系统为您处理了最困难的部分。我们第一个 <code>ns3</code> 脚本剩余的行 first.cc 就是这样做的：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">  Simulator::Destroy ();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="模拟器什么时候会停止"><a href="#模拟器什么时候会停止" class="headerlink" title="模拟器什么时候会停止"></a>模拟器什么时候会停止</h2><p><code>ns3</code> 是离散事件（DE）模拟器。在这种模拟器中，每个事件都与其执行时间相关联，并且通过以模拟时间的时间顺序执行事件来进行模拟。事件可能会导致安排将来的事件（例如，计时器可能会将自己重新安排为在下一个时间间隔到期）。</p><p>初始事件通常由每个对象触发，例如，IPv6 将调度路由器广告，邻居请求等，应用程序调度第一个数据包发送事件等。</p><p>处理事件时，它可能会生成零个，一个或多个事件。在执行模拟时，将消耗事件，但是可能会（或可能不会）生成更多事件。当事件队列中没有其他事件时，或者发现特殊的 Stop 事件时，模拟将自动停止。<code>Stop</code> 事件是通过<code>Simulator::Stop(stopTime);</code>函数创建的。</p><p>在典型情况下，必须使用 <code>Simulator::Stop</code> 来停止模拟：发生自持事件时。自我维持（或重复发生）的事件是总是自行重新安排时间的事件。因此，它们始终将事件队列保持为非空。</p><p>有许多包含重复事件的协议和模块，例如：</p><ul><li>FlowMonitor-定期检查丢失的数据包</li><li>RIPng-定期广播路由表更新</li></ul><p>在这些情况下，必须使用 <code>Simulator::Stop</code> 才能正常停止模拟。另外，当 <code>ns3</code> 处于仿真模式时，使用 <code>RealtimeSimulator</code> 来使仿真时钟与机器时钟保持一致，并且 <code>Simulator::Stop</code> 是停止该过程所必需的。</p><p>本教程中的许多仿真程序都未明确调用 <code>Simulator::Stop</code>，因为事件队列将自动用尽事件。但是，这些程序还将接受对 <code>Simulator::Stop</code> 的调用。例如，第一个示例程序中的以下附加语句将安排在 11 秒时显式停止：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">+  Simulator::Stop (Seconds (<span class="hljs-number">11.0</span>));<br>   Simulator::Run ();<br>   Simulator::Destroy ();<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></div></td></tr></table></figure><p>上面的内容实际上不会改变此程序的行为，因为此特定的模拟自然会在 10 秒后结束。但是，如果要将以上语句中的停止时间从 11 秒更改为 1 秒，您会注意到模拟会在任何输出打印到屏幕之前停止（因为输出发生在模拟时间的 2 秒左右）。</p><p>重要的是在调用 <code>Simulator::Run</code> 之前先调用 <code>Simulator::Stop</code>否则，<code>Simulator::Run</code> 可能永远不会将控制权返回给主程序以执行停止！</p><h2 id="构建你的脚本"><a href="#构建你的脚本" class="headerlink" title="构建你的脚本"></a>构建你的脚本</h2><p>构建简单的脚本非常简单。您所要做的就是将脚本放到临时目录中，如果您运行 Waf，它将自动生成。试试吧切换回顶层目录后，将 <code>examples/tutorial/first.cc</code> 复制到 <code>scratch</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ cp examples/tutorial/first.cc scratch/myfirst.cc<br></code></pre></div></td></tr></table></figure><p>现在使用 waf 构建第一个示例脚本：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ./waf<br>Waf: Entering directory `/home/craigdo/repos/ns-3-allinone/ns-3-dev/build<span class="hljs-string">&#x27;</span><br><span class="hljs-string">[614/708] cxx: scratch/myfirst.cc -&gt; build/debug/scratch/myfirst_3.o</span><br><span class="hljs-string">[706/708] cxx_link: build/debug/scratch/myfirst_3.o -&gt; build/debug/scratch/myfirst</span><br><span class="hljs-string">Waf: Leaving directory `/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&#x27;</span><br><span class="hljs-string">&#x27;build&#x27;</span> finished successfully (2.357s)<br></code></pre></div></td></tr></table></figure><p>现在，您可以运行该示例（请注意，如果在 <code>scratch</code> 目录中构建程序，则必须在 <code>scratch</code> 目录<strong>外</strong>运行该程序）：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ./waf --run scratch/myfirst<br>Waf: Entering directory `/home/craigdo/repos/ns-3-allinone/ns-3-dev/build<span class="hljs-string">&#x27;</span><br><span class="hljs-string">Waf: Leaving directory `/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&#x27;</span><br><span class="hljs-string">&#x27;build&#x27;</span> finished successfully (0.418s)<br>Sent 1024 bytes to 10.1.1.2<br>Received 1024 bytes from 10.1.1.1<br>Received 1024 bytes from 10.1.1.2<br></code></pre></div></td></tr></table></figure><p>在这里，您会看到构建系统检查以确保已构建文件，然后运行它。您会看到 echo 客户端上的日志记录组件表明它已向 10.1.1.2 上的 Echo Server 发送了一个 1024 字节的数据包。您还可以看到回显服务器上的日志记录组件说它已从 10.1.1.1 接收到 1024 个字节。回显服务器以静默方式回显数据包，您会看到回显客户端日志，它已从服务器接收回数据包。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.nsnam.org/docs/release/3.30/tutorial/html/conceptual-overview.html#a-first-ns-3-script">Conceptual Overview — Tutorial</a></p><p><a href="https://blog.51cto.com/3240611/1641583">NS-3 入门[2]脚本与编译运行-针挑土-51CTO 博客</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>ns3 网络模拟软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>停止和删除 docker 所有的容器和镜像</title>
    <link href="/2020/06/27/stop-and-remove-all-docker-containers-and-images/"/>
    <url>/2020/06/27/stop-and-remove-all-docker-containers-and-images/</url>
    
    <content type="html"><![CDATA[<p>停止和删除 docker 所有的容器和镜像的简单方法，一句命令</p><a id="more"></a><h2 id="停止所有-Docker-容器"><a href="#停止所有-Docker-容器" class="headerlink" title="停止所有 Docker 容器"></a>停止所有 Docker 容器</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker stop $(docker ps -aq)<br><span class="hljs-comment"># 你的所有 Docker 容器的 ID</span><br></code></pre></div></td></tr></table></figure><p>其中 <code>docker ps -aq</code> 的作用是列出所有 <code>Docker</code> 容器的 ID</p><h2 id="删除所有-Docker-容器"><a href="#删除所有-Docker-容器" class="headerlink" title="删除所有 Docker 容器"></a>删除所有 Docker 容器</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker rm $(docker ps -aq)<br><span class="hljs-comment"># 你的所有 Docker 容器的 ID</span><br></code></pre></div></td></tr></table></figure><h2 id="删除所有-Docker-镜像"><a href="#删除所有-Docker-镜像" class="headerlink" title="删除所有 Docker 镜像"></a>删除所有 Docker 镜像</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ docker rmi $(docker images -aq)<br><span class="hljs-comment"># 你的所有 Docker 镜像的 ID</span><br></code></pre></div></td></tr></table></figure><p>其中 <code>docker images -aq</code> 的作用是列出所有 <code>Docker</code> 镜像的 ID</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://colobu.com/2018/05/15/Stop-and-remove-all-docker-containers-and-images/">停止、删除所有的 docker 容器和镜像 | 鸟窝</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ns3 网络模拟软件的安装和起步</title>
    <link href="/2020/06/24/ns3-getting-start/"/>
    <url>/2020/06/24/ns3-getting-start/</url>
    
    <content type="html"><![CDATA[<p>ns3 网络模拟软件的安装和使用</p><a id="more"></a><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>运行 <code>ns3</code> 需要安装 <code>Linux</code> 虚拟机或者是 <code>WSL</code>，Windows 无法直接跑，本文中使用 <code>VMWare Workstation 15.5</code> 的 <code>Ubuntu 20.04LTS</code> 为环境，其他 <code>Linux</code> 发行版本大同小异，请前往参考中的官网文档</p><p>建议用 <code>WSL</code> 跑，虚拟机会消耗一些性能</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先，进入<a href="https://www.nsnam.org/releases/">ns 的 release 网页（官方）</a></p><p><img src="https://s1.ax1x.com/2020/06/24/Nwenq1.png" alt="website"></p><p>下载最新版本的 tar 包，传入虚拟机中，使用 <code>tar -xvf</code> 命令解压文件，得到文件夹，我的是 <code>ns-allinone-3.30.1</code></p><h2 id="使用-apt-安装依赖"><a href="#使用-apt-安装依赖" class="headerlink" title="使用 apt 安装依赖"></a>使用 apt 安装依赖</h2><p>首先使用以下命令安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo apt install g++ python3<br>...<br>g++ is already the newest version (4:9.3.0-1ubuntu2).<br>python3 is already the newest version (3.8.2-0ubuntu2).<br>0 upgraded, 0 newly installed, 0 to remove and 9 not upgraded.<br></code></pre></div></td></tr></table></figure><p><code>Ununtu 20.04LTS</code> 版本中已经安装好了 <code>g++</code> 和 <code>Python3</code></p><h2 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h2><p>确保工作目录是在 <code>ns-allinone-3.30.1</code> 下，在命令行中执行如下命令开始构建，时间可能会很长，请耐心等待。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ./build.py --enable-tests --enable-examples<br>...<br>Leaving directory `./ns-3.30.1<span class="hljs-string">&#x27;</span><br></code></pre></div></td></tr></table></figure><p>得到以下输出，说明构建成功</p><p><img src="https://s1.ax1x.com/2020/06/24/Nwmb9S.jpg" alt="构建成功"></p><p>如果失败，请删除文件夹重新再来一遍（我就是这么做的，重来了几遍，最后可以正常运行了）</p><h2 id="进一步构建"><a href="#进一步构建" class="headerlink" title="进一步构建"></a>进一步构建</h2><p>据官方文档所说，上一步是构建好运行时需要的库，这一步是进行真实构建。</p><p>切换工作目录到文件夹中的 <code>ns-*</code> 目录（我的是 <code>ns-3.30.1</code>），在命令行中执行如下命令，向 Waf 解释它应该进行包括示例和测试的优化构建</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ./waf clean<br><span class="hljs-string">&#x27;clean&#x27;</span> finished successfully (0.398s)<br>$ ./waf configure --build-profile=optimized --enable-examples --enable-tests<br>...<br><span class="hljs-string">&#x27;configure&#x27;</span> finished successfully (2.899s)<br></code></pre></div></td></tr></table></figure><p>切换回包含示例和测试的调试（debug）版本。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ./waf clean<br>$ ./waf configure --build-profile=debug --enable-examples --enable-tests<br>...<br><span class="hljs-string">&#x27;configure&#x27;</span> finished successfully (2.618s)<br></code></pre></div></td></tr></table></figure><p>开始构建</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ./waf<br>...<br><span class="hljs-string">&#x27;build&#x27;</span> finished successfully (20m15.146s)<br>...<br></code></pre></div></td></tr></table></figure><p>如果出现了下图的结果，说明构建成功</p><p><img src="https://s1.ax1x.com/2020/06/24/NwuTSS.jpg" alt="进一步构建成功"></p><h2 id="测试-ns3（可跳过）"><a href="#测试-ns3（可跳过）" class="headerlink" title="测试 ns3（可跳过）"></a>测试 ns3（可跳过）</h2><p>命令行中执行 <code>./test.py</code> 来运行测试脚本，出现一大堆 <code>PASS</code> 说明测试成功（图就不放了，太大了）</p><p>这个时间很长，如果没耐心可以跳过，基本上来说前几步正常进行的话都没问题</p><h2 id="运行一个脚本"><a href="#运行一个脚本" class="headerlink" title="运行一个脚本"></a>运行一个脚本</h2><p>命令行中执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ./waf --run hello-simulator<br>Build commands will be stored <span class="hljs-keyword">in</span> build/compile_commands.json<br><span class="hljs-string">&#x27;build&#x27;</span> finished successfully (0.844s)<br>Hello Simulator<br></code></pre></div></td></tr></table></figure><p>出现和上面相同的结果说明运行成功，成功入门</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://www.cnblogs.com/jhcelue/p/6905943.html">NS3 网络仿真（2）：first.py - jhcelue - 博客园</a></p><p>这个是系列教程，作者很牛逼</p><p><a href="https://blog.csdn.net/deep_kang/article/details/73350350">NS3 网络仿真_deep_keng 的博客-CSDN 博客_ns3 使用 netanim 仿真 wifi 节点</a></p><p><a href="https://www.jianshu.com/p/fe77a15a1eb4">用 NS3 进行虚拟仿真 - 简书</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.nsnam.org/wiki/Installation">ns3 官方安装指南（英）</a></p><p><a href="https://www.nsnam.org/docs/release/3.30/tutorial/html/getting-started.html">ns3 官方构建文档（英）</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>ns3 网络模拟软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scanf 格式字符串中的空格</title>
    <link href="/2020/06/24/space-in-scanf/"/>
    <url>/2020/06/24/space-in-scanf/</url>
    
    <content type="html"><![CDATA[<p>scanf 语句中空格的问题</p><a id="more"></a><h2 id="格式说明符前"><a href="#格式说明符前" class="headerlink" title="格式说明符前"></a>格式说明符前</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>, &amp;c);<br></code></pre></div></td></tr></table></figure><p>第二行中 <code>%c</code> 前加空格，会消耗 <code>%d</code> 后的所有后继空白符，然后读取一个 <code>char</code></p><h2 id="格式说明符后"><a href="#格式说明符后" class="headerlink" title="格式说明符后"></a>格式说明符后</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d &quot;</span>, &amp;a);<br></code></pre></div></td></tr></table></figure><p>这种写法在你输入数字后，<code>scanf</code> 会<strong>跳过所有空格字符，包括回车符</strong>，直到遇到不是空格字符才退出，<strong>不建议这么写</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.cppreference.com/w/c/io/fscanf">zh.cpprefernce.com</a></p><p><a href="https://zhidao.baidu.com/question/620629950137762012.html">scanf 语句中%d 后面多加一个空格，为什么数据需要多输入一个？_百度知道</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C 语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 通过 apt 安装 nodejs</title>
    <link href="/2020/06/17/install-nodejs-on-ubuntu-with-apt/"/>
    <url>/2020/06/17/install-nodejs-on-ubuntu-with-apt/</url>
    
    <content type="html"><![CDATA[<p>Ubuntu 通过 apt 安装 nodejs 的方法</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>由于 Nodejs 更新速度较快，不建议使用此种方式，建议使用 <a href="https://github.com/nvm-sh/nvm">nvm</a> 或者 <a href="https://github.com/nodenv/nodenv">nodenv</a></p><p>官方文档不建议使用管理员权限进行安装，<a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally">Resolving EACCES permissions errors when installing packages globally</a></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="14-x"><a href="#14-x" class="headerlink" title="14.x"></a>14.x</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -<br>sudo apt-get install -y nodejs<br></code></pre></div></td></tr></table></figure><h3 id="12-x"><a href="#12-x" class="headerlink" title="12.x"></a>12.x</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -<br>sudo apt-get install -y nodejs<br></code></pre></div></td></tr></table></figure><h3 id="10-x"><a href="#10-x" class="headerlink" title="10.x"></a>10.x</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -<br>sudo apt-get install -y nodejs<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将 HTML 元素居中的方法</title>
    <link href="/2020/05/30/align-items-to-center-using-css/"/>
    <url>/2020/05/30/align-items-to-center-using-css/</url>
    
    <content type="html"><![CDATA[<p>三种将 HTML 元素居中的方法</p><a id="more"></a><h2 id="左右居中"><a href="#左右居中" class="headerlink" title="左右居中"></a>左右居中</h2><p>当元素的 <code>display</code> 属性为 <code>inline</code> 或者 <code>inline-block</code> 时，将<strong>父元素</strong>设定为 <code>text-align: center;</code> 即可左右居中</p><p>当元素的 <code>display</code> 属性为 <code>block</code> 时，将<strong>元素本身</strong>的 <code>margin-left</code> 和 <code>margin-right</code> 设定为 <code>auto</code> 即可左右居中</p><h2 id="上下居中"><a href="#上下居中" class="headerlink" title="上下居中"></a>上下居中</h2><h3 id="position-absolute"><a href="#position-absolute" class="headerlink" title="position: absolute"></a>position: absolute</h3><p>使用 <code>position: absolute</code> 时，可以参考如下代码</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-id">#center</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>) <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="flexbox"><a href="#flexbox" class="headerlink" title="flexbox"></a>flexbox</h3><p>flexbox 自带 <code>justify-content</code> 和 <code>align-items</code> 两个属性，分别设定主轴和交叉轴的对齐方式，将这两个属性都设置为 <code>center</code> 即可上下左右居中对齐</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="display-table"><a href="#display-table" class="headerlink" title="display: table"></a>display: table</h3><p>HTML 的 <code>table</code> 元素有一个 <code>valign</code> 属性，是用来设定垂直方向的对齐，可以通过 CSS 将其他元素的 <code>display</code> 属性设定为 <code>table</code> 去将它当作一个 <code>table</code> 去显示</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">display</span>: table;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;<br>&#125;<br><br># <span class="hljs-selector-tag">center</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">vertical-align</span>: middle;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>position: absolute 方法是对其元素本身，调整元素本身的属性即可</p><p>flexbox、display: table 方法是对其元素内容，先将容器调整为与画面大小相同，然后再设定他的内容的对齐方式</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1o7411G7dq">CodingStartup - [HTML] 上下左右置中对齐的三种方法_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 从选择的文件中读取文本</title>
    <link href="/2020/05/30/read-text-from-files-with-javascript/"/>
    <url>/2020/05/30/read-text-from-files-with-javascript/</url>
    
    <content type="html"><![CDATA[<p>在开发词法分析器的前端页面时，需要允许用户从本地上传 c++ 文件，并将文件内容载入到编辑器中，本文介绍如何用 JavaScript 和 input 标签来实现网页加载文本文件内容（注意是加载内容）</p><a id="more"></a><h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><p>首先介绍一下 <code>FileReader</code>，FileReader 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 对象指定要读取的文件或数据，可以用 <code>const reader = new FileReader();</code> 来初始化，详细部分在<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader">FileReader - Web API 接口参考 | MDN</a>中</p><h2 id="读取-Input-标签文件内容"><a href="#读取-Input-标签文件内容" class="headerlink" title="读取 Input 标签文件内容"></a>读取 Input 标签文件内容</h2><p>以下是示例代码</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 获取 input 标签对应的元素</span><br><span class="hljs-keyword">const</span> fileInput = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;file-input&quot;</span>);<br><span class="hljs-comment">// 读取文件</span><br><span class="hljs-keyword">const</span> file = fileInput.files[<span class="hljs-number">0</span>];<br></code></pre></div></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fileInput = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;file-input&quot;</span>);<br><span class="hljs-keyword">let</span> file = fileInput.files[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">let</span> reader = <span class="hljs-keyword">new</span> FileReader();<br><span class="hljs-keyword">let</span> text;<br>reader.addEventListener(<span class="hljs-string">&quot;loadend&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  text = reader.result;<br>&#125;);<br>reader.readAsText(file);<br></code></pre></div></td></tr></table></figure><h2 id="在-React-有状态组件中实现"><a href="#在-React-有状态组件中实现" class="headerlink" title="在 React 有状态组件中实现"></a>在 React 有状态组件中实现</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-title">handleFileChange</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> fileInput = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;file-input&quot;</span>);<br>  <span class="hljs-keyword">let</span> file = fileInput.files[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">let</span> reader = <span class="hljs-keyword">new</span> FileReader();<br>  reader.addEventListener(<span class="hljs-string">&quot;loadend&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      text: reader.result,<br>    &#125;);<br>    fileInput.value = <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;);<br>  reader.readAsText(file);<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意：因为是加载文件，所以加载完一次后要清除所选文件，否则下次加载同样的文件无法触发 <code>handleFileCHange</code> 函数，无法使状态改变了</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader">FileReader - Web API 接口参考 | MDN</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023022494381696">操作文件 - 廖雪峰的官方网站</a></p><p><a href="https://blog.csdn.net/cuixiping/article/details/37526871">用 Javascript 清空(重置)文件类型的 INPUT 元素的值<em>javascript</em>无心的专栏-CSDN 博客</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 CentOS7 上安装 MySQL Community Server</title>
    <link href="/2020/05/29/install-mysql-community-server-on-centos7/"/>
    <url>/2020/05/29/install-mysql-community-server-on-centos7/</url>
    
    <content type="html"><![CDATA[<p>对<a href="https://juejin.im/post/5d07cf13f265da1bd522cfb6#heading-24">tianranll - CentOS 安装 MySQL 详解</a>的一些补充</p><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p><a href="https://juejin.im/post/5d07cf13f265da1bd522cfb6#heading-24">tianranll - CentOS 安装 MySQL 详解</a></p><p>这个人已经讲的很详细了，我就是补充一下，讲解一下踩到的坑，另外，我是用虚拟机的方式来测试环境的，下面的一切操作都是基于 CentOS 虚拟机的情况下中执行的，容错率比较高。</p><h2 id="MySQL-Yum-Repo-安装链接"><a href="#MySQL-Yum-Repo-安装链接" class="headerlink" title="MySQL Yum Repo 安装链接"></a>MySQL Yum Repo 安装链接</h2><p>这个链接是在 <a href="https://dev.mysql.com/downloads/repo/yum/">MySQL Community Downloads - MySQL Yum Repository</a> 下找到的，根据 Linux 版本来选取，比如说我安装的是 CentOS7 就选择 RedHat Enterprise Linux 7</p><p><img src="https://cdn.jsdelivr.net/gh/mazixiang/assets@master/picgo/20200528085819.png" alt="选择 RedHat Enterprise Linux 7"></p><p>点击之后出来的这个页面，复制下面的 <code>no thanks</code> 链接地址</p><p><img src="https://cdn.jsdelivr.net/gh/mazixiang/assets@master/picgo/20200528090827.png" alt="复制链接地址"></p><p>你的 <code>wget</code> 命令后面应该接的是这个复制的地址（如果你想安装最新的版本）</p><h2 id="远程连接问题"><a href="#远程连接问题" class="headerlink" title="远程连接问题"></a>远程连接问题</h2><p>对应文章的 6. 允许 root 远程访问</p><p><strong>从 MySQL 8.0 以后，不可以再直接使用 <code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;</code> 来给权限了，可以用下面的命令来代替</strong></p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 1. 使用alter user</span><br>&gt; alter user set user.host=&#x27;%&#x27; where user.user=&#x27;root&#x27;;<br><span class="hljs-comment">-- 2. 使用create user</span><br>&gt; create user &#x27;userName&#x27;@&#x27;%&#x27; identified by &#x27;your_password&#x27;;<br></code></pre></div></td></tr></table></figure><p>我失败了之后查了好长一段时间，最后在<a href="https://www.jianshu.com/p/98a6d42e28c8">mysql8 grant 授权报错：ERROR 1410 (42000): You are not allowed to create a user with GRANT</a>找到了解决方案，但是原作者好像忘了写那个 <code>identified</code> 后面的 <code>by</code> 了……</p><h2 id="开启-CentOS7-的防火墙-3306-端口"><a href="#开启-CentOS7-的防火墙-3306-端口" class="headerlink" title="开启 CentOS7 的防火墙 3306 端口"></a>开启 CentOS7 的防火墙 3306 端口</h2><p>不开启端口，是无法使用远程连接的，参考<a href="https://blog.csdn.net/achang21/article/details/52538049">CentOS 7 开放防火墙端口命令</a>，在终端执行</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ firewall-cmd --zone=public --add-port=3306/tcp --permanent<br>success<br>$ firewall-cmd --reload<br>success<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5d07cf13f265da1bd522cfb6#heading-24">tianranll - CentOS 安装 MySQL 详解</a></p><p><a href="https://www.jianshu.com/p/98a6d42e28c8">mysql8 grant 授权报错：ERROR 1410 (42000): You are not allowed to create a user with GRANT</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 常用单位</title>
    <link href="/2020/05/28/commonly-used-css-units/"/>
    <url>/2020/05/28/commonly-used-css-units/</url>
    
    <content type="html"><![CDATA[<p>简单介绍 CSS 常用单位</p><a id="more"></a><h2 id="px"><a href="#px" class="headerlink" title="px"></a>px</h2><p><code>px</code> 是最常用的<strong>绝对单位</strong>，全称是 <code>pixel</code> ，代表屏幕上的像素点，用法如下</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="em"><a href="#em" class="headerlink" title="em"></a>em</h2><p><code>em</code> 是一个相对单位，代表相对父元素字体大小的倍数，用法如下</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.8em</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>此时的 <code>div</code> 中的 <code>h1</code> 元素字体大小为 <code>20px * 0.8em = 16px</code></p><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p><code>rem</code> 也是一个相对单位，代表相对根（root）元素字体大小的倍数，用法如下</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.8rem</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>此时的 <code>div</code> 中的 <code>h1</code> 元素字体大小为 <code>10px * 0.8em = 8px</code>，并且不受父容器字体大小的限制</p><h2 id="vw-和-vh"><a href="#vw-和-vh" class="headerlink" title="vw 和 vh"></a>vw 和 vh</h2><p><code>vw</code> 和 <code>vh</code> 即是 <code>viewport width</code> 和 <code>viewport height</code> 的缩写，<code>viewport</code> 是目前看到的画面的大小，他们的值只能是 1 - 100，<code>50vw</code> 是占画面宽度的一半，<code>50vh</code> 是占画面高度的一半</p><p>经常用到的是 <code>100vh</code> 和 <code>100 vw</code>，用来做水平垂直居中都很方便</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1d441167e9">CodingStartup - 5 个常用的 CSS 单位</a></p><p><a href="https://zhuanlan.zhihu.com/p/28915418">知乎 - css 单位中 px 和 em,rem 的区别</a></p><p><a href="https://www.w3.org/Style/Examples/007/units.zh_CN.html">w3.org - 网页样式表 CSS 提示以及技巧</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Windows 上 git log 乱码</title>
    <link href="/2020/05/27/solution-to-git-log-garbled-on-windows/"/>
    <url>/2020/05/27/solution-to-git-log-garbled-on-windows/</url>
    
    <content type="html"><![CDATA[<p>解决大多数的 Windows 上 git log 乱码问题，注意是大多数问题</p><a id="more"></a><h2 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h2><p>Linux 系统上的环境变量需要使用 <code>export LANG=zh_CN.UTF-8</code> 来指定</p><p>永久写入需要把 <code>export</code> 语句直接写入 <code>.bashrc</code> 或者 <code>.zshrc</code> 中</p><h2 id="检查环境变量"><a href="#检查环境变量" class="headerlink" title="检查环境变量"></a>检查环境变量</h2><p>打开 cmd 或者 powershell，输入</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">&gt; <span class="hljs-built_in">echo</span> %LANG%<br></code></pre></div></td></tr></table></figure><p>查看 <code>LANG</code> 变量，如果输出 <code>zh_CN.UTF-8</code> 则继续进行，如果输出别的，新建一个环境变量 <code>LANG</code>，值设为 <code>zh_CN.UTF-8</code>，重启 cmd</p><h2 id="修改-git-config"><a href="#修改-git-config" class="headerlink" title="修改 git config"></a>修改 git config</h2><p>在 cmd 或者 powershell 中，输入</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">&gt; git config -<span class="hljs-literal">-global</span> i18n.commitencoding utf<span class="hljs-literal">-8</span><br>&gt; git config -<span class="hljs-literal">-global</span> i18n.logoutputencoding utf<span class="hljs-literal">-8</span><br></code></pre></div></td></tr></table></figure><p>并新建一条环境变量 <code>LESSCHARSET</code>，值设为 <code>utf-8</code></p><h2 id="暂时设置环境变量"><a href="#暂时设置环境变量" class="headerlink" title="暂时设置环境变量"></a>暂时设置环境变量</h2><p>在 cmd 或者 powershell 中输入 <code>set LANG=zh_CN.UTF-8</code>，可以暂时起作用，但重新启动后就没用了</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/fb47a39f3578">git log 中文乱码 - 简书</a></p><p><a href="https://blog.csdn.net/qianggezhishen/article/details/80865143">git log 乱码解决方法_git_qianggezhishen 的专栏-CSDN 博客</a></p><p><a href="https://www.cnblogs.com/zhangxiaoliu/p/9226197.html">git log 中文乱码的解决方案 - 张发财 - 博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 自定义类的排序</title>
    <link href="/2020/05/26/sorting-of-custom-classes/"/>
    <url>/2020/05/26/sorting-of-custom-classes/</url>
    
    <content type="html"><![CDATA[<p>两种 Java 自定义类的排序的方法</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Java 中，类的实例默认是不可以进行比较和排序的，本文将解决以下两个问题：</p><ul><li>如何比较类同一个类的两个实例的大小？</li><li>正常的 Java 数组是可以用 <code>Array.sort()</code> 进行排序的，前提是这些元素是可排序的，在自定义的类中怎么直接使用 <code>Array.sort()</code> 呢？</li></ul><h2 id="介绍-Comparable"><a href="#介绍-Comparable" class="headerlink" title="介绍 Comparable"></a>介绍 Comparable</h2><p>Comparabe 是一个排序接口，如果一个类支持 <code>Comparable</code> 接口，就意味着该类支持排序排序。实现了 <code>Comparable</code> 接口的类的对象的列表或数组可以通过 <code>Arrays.sort()</code> 进行自动排序，此外，实现此接口的对象可以用作有序映射中的键或有序集合中的集合，无需指定比较器。</p><h3 id="Comparable-的定义"><a href="#Comparable-的定义" class="headerlink" title="Comparable 的定义"></a>Comparable 的定义</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T o)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Comparable-的说明"><a href="#Comparable-的说明" class="headerlink" title="Comparable 的说明"></a>Comparable 的说明</h3><ul><li>T 表示可以与此对象进行比较的对象的类型</li><li>此接口只有一个方法 <code>compareTo</code>，比较此对象与指定对象的顺序，小于返回负整数，大于返回正整数，等于返回 0</li></ul><h3 id="Comparable-的示例"><a href="#Comparable-的示例" class="headerlink" title="Comparable 的示例"></a>Comparable 的示例</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Fruit[] a = <span class="hljs-keyword">new</span> Fruit[<span class="hljs-number">3</span>];<br>      a[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Fruit(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>      a[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Fruit(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>      a[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Fruit(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>      Arrays.sort(a);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        System.out.println(a[i].getWeight() + <span class="hljs-string">&quot; &quot;</span> + a[i].getSugar() + <span class="hljs-string">&quot; &quot;</span> + a[i].getPrice());<br>      &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Fruit</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> weight;  <span class="hljs-comment">// 重量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> sugar;  <span class="hljs-comment">// 含糖量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> price;  <span class="hljs-comment">// 价格</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fruit</span><span class="hljs-params">(<span class="hljs-keyword">double</span> w, <span class="hljs-keyword">double</span> s, <span class="hljs-keyword">double</span> p)</span> </span>&#123;<br>        weight = w;<br>        sugar = s;<br>        price = p;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Fruit a)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> -Double.compare(<span class="hljs-keyword">this</span>.weight, a.weight);  <span class="hljs-comment">// 按照重量由大到小进行排序</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getWeight</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> weight;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSugar</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sugar;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> price;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的程序输出为</p><blockquote><p>7.0 8.0 9.0<br>4.0 5.0 6.0<br>1.0 2.0 3.0</p></blockquote><p>说明排序成功</p><h2 id="介绍-Comparator"><a href="#介绍-Comparator" class="headerlink" title="介绍 Comparator"></a>介绍 Comparator</h2><p>Comparator 是一个比较接口，如果要控制某个类的次序，而该类本身不支持排序，那么可以建立一个“该类的比较器”来进行排序，这个比较器只需要实现 Comparator 接口即可。</p><h3 id="Comparator-的定义"><a href="#Comparator-的定义" class="headerlink" title="Comparator 的定义"></a>Comparator 的定义</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(T o1, T o2)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="使用-Comparator-的注意事项"><a href="#使用-Comparator-的注意事项" class="headerlink" title="使用 Comparator 的注意事项"></a>使用 Comparator 的注意事项</h3><ul><li>若一个类要实现 Comparator 接口，必须要有<code>compare</code>函数，<code>equals</code>函数可写可不写</li><li><code>int compare(T o1, T o2)</code>函数是比较 o1 和 o2 的大小，返回负数意味着 o1 比 o2 小，返回 0 意味着 o1 等于 o2，返回正数代表 o1 大于 o2</li></ul><h3 id="Comparator-的示例"><a href="#Comparator-的示例" class="headerlink" title="Comparator 的示例"></a>Comparator 的示例</h3><h2 id="Comparable-和-Comparator-的比较"><a href="#Comparable-和-Comparator-的比较" class="headerlink" title="Comparable 和 Comparator 的比较"></a>Comparable 和 Comparator 的比较</h2><p>Comparable 是排序接口，若一个类实现了 Comparable 接口，就意味着“该类支持排序”。</p><p>Comparator 是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p><p>Comparable 相当于“内部比较器”，而 Comparator 相当于“外部比较器”。</p><p>两种方法各有优劣， 用 Comparable 简单， 只要实现 Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。</p><p>用 Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在 Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。</p><p>比如你引入了别人写的一个类，需要对这个类的实例进行比较或者排序，若要使用实现 Comparable 接口的方法，则你需要对引入的类进行源代码的修改，而如果使用实现 Comparator 接口的方式，则不需要对引入的类进行修改，只需要重新写一个引入类的比较器类就可以了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/gaoBlog/p/10754935.html">java 学习–自定义类的实例的大小比较和排序</a></p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html?is-external=true">Comparable 官方文档</a></p><p><a href="https://docs.oracle.com/javase/1.5.0/docs/api/java/util/Comparator.html">Comparator 官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 常用解压命令</title>
    <link href="/2020/05/26/linux-unzip-commands/"/>
    <url>/2020/05/26/linux-unzip-commands/</url>
    
    <content type="html"><![CDATA[<p>Linux 常用的解压命令</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Linux 下常见的压缩包格式为 <code>zip tar.gz tar.bz2 tar.xz tar.Z</code><br>其中 <code>tar</code> 是打包格式，<code>gz2 bz2</code> 等后缀是指代压缩方式</p><h2 id="filename-zip"><a href="#filename-zip" class="headerlink" title="filename.zip"></a>filename.zip</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ unzip filename.zip<br></code></pre></div></td></tr></table></figure><h2 id="filename-tar-gz"><a href="#filename-tar-gz" class="headerlink" title="filename.tar.gz"></a>filename.tar.gz</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ tar -zxvf filename.tar.gz<br></code></pre></div></td></tr></table></figure><p>-z：gzip - 压缩格式<br>-x：extract - 解压<br>-v：verbose - 详细信息<br>-f：file - 文件</p><h2 id="filename-tar-bz2"><a href="#filename-tar-bz2" class="headerlink" title="filename.tar.bz2"></a>filename.tar.bz2</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ tar -jxvf filename.tar.bz2<br></code></pre></div></td></tr></table></figure><p>-j：bz2 压缩方式</p><h2 id="filename-tar-xz"><a href="#filename-tar-xz" class="headerlink" title="filename.tar.xz"></a>filename.tar.xz</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ tar -Jxvf filename.tar.xz<br></code></pre></div></td></tr></table></figure><p>注意 J 大写</p><h2 id="filename-tar-Z"><a href="#filename-tar-Z" class="headerlink" title="filename.tar.Z"></a>filename.tar.Z</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ tar -Zxvf filename.tar.Z<br></code></pre></div></td></tr></table></figure><p>注意 Z 大写</p><h2 id="简便写法"><a href="#简便写法" class="headerlink" title="简便写法"></a>简便写法</h2><p>首先，使用 <code>tar --version</code> 查看版本，从 1.15 版本以后可以直接使用 <code>tar -xvf</code> 来智能识别格式</p><p>参考自<a href="https://www.cnblogs.com/cursorhu/p/5891699.html">Linux 下的解压命令小结 - cursorhu</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过 Travis CI 或者 GitHub Actions 将 Hexo 博客部署到 GitHub Pages</title>
    <link href="/2020/05/25/deploy-hexo-to-github-pages-with-travis-ci/"/>
    <url>/2020/05/25/deploy-hexo-to-github-pages-with-travis-ci/</url>
    
    <content type="html"><![CDATA[<p>纯萌新遇到的一些坑</p><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>目前，**<a href="https://hexo.io/docs/github-pages">Hexo 英文文档</a>**已经使用 <code>GitHub Actions</code> 来部署到 GitHub Pages 上了，但是中文文档没有同步更新，所以更新一下对应的方法</p><h3 id="预先检查"><a href="#预先检查" class="headerlink" title="预先检查"></a>预先检查</h3><p>首先，确定你项目的源文件全部在 source 分支上，然后进行对应的操作</p><h3 id="检查是否存在脚本"><a href="#检查是否存在脚本" class="headerlink" title="检查是否存在脚本"></a>检查是否存在脚本</h3><p>检查一下 <code>package.json</code> 文件下有没有如下两行，如果没有，添加进去</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;hexo generate&quot;</span><br>  &#125;,<br></code></pre></div></td></tr></table></figure><h3 id="推送到-GitHub-分支"><a href="#推送到-GitHub-分支" class="headerlink" title="推送到 GitHub 分支"></a>推送到 GitHub 分支</h3><p>在你的项目目录下面运行如下命令，将你博客的 source 分支推送到远程的对应分支上</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git push -u origin <span class="hljs-built_in">source</span><br>...<br></code></pre></div></td></tr></table></figure><h3 id="新建-GitHub-Workflow"><a href="#新建-GitHub-Workflow" class="headerlink" title="新建 GitHub Workflow"></a>新建 GitHub Workflow</h3><p>在你的项目文件夹下新建 <code>.github/workflows/pages.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">source</span> <span class="hljs-comment"># 默认部署分支</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">pages:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span> <span class="hljs-number">14</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;14&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">NPM</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">node_modules</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.OS</span> <span class="hljs-string">&#125;&#125;-npm-cache</span><br>          <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|</span><br>            <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.OS</span> <span class="hljs-string">&#125;&#125;-npm-cache</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">github_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITHUB_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">publish_dir:</span> <span class="hljs-string">./public</span><br>          <span class="hljs-attr">publish_branch:</span> <span class="hljs-string">master</span> <span class="hljs-comment"># 部署到的分支</span><br></code></pre></div></td></tr></table></figure><h3 id="更改-GitHub-仓库设置"><a href="#更改-GitHub-仓库设置" class="headerlink" title="更改 GitHub 仓库设置"></a>更改 GitHub 仓库设置</h3><p>更改你的 GitHub 仓库设置，到 <code>GitHub Pages</code> 部分，将 <code>source</code> 分支改为 <code>master</code></p><p>注意：如果你有自定义域名，请将 <code>CNAME</code> 文件放入 <code>source</code> 文件夹</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>使用 Hexo 搭建完博客之后，翻了一下官网，结果发现还可以用 <code>Travis CI</code> 来做自动生成部署啊！正好今天整了一天的 <code>Travis CI</code>，也差不多熟悉了，就直接按照官方文档去照着做了</p><h2 id="Travis-CI-介绍"><a href="#Travis-CI-介绍" class="headerlink" title="Travis CI 介绍"></a>Travis CI 介绍</h2><p>Travis CI 是一个持续集成工具，因为我只使用了一天，还不太了解。详细原理可以去搜一下，这里就简单讲一下：就是你提交了一次 <code>commit</code> 后，这个工具按照你的 repo 里的 <code>.travis.yml</code> 来自动执行一些操作，如果构建通过了显示 <code>passing</code>，不通过显示 <code>failing</code>。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a href="https://hexo.io/zh-cn/docs/github-pages">Hexo 官方的使用 Travis CI 教程</a>有点小坑啊，现在的 <code>GitHub Pages</code> 的部署分支必须是 <code>master</code> 分支了，但是官网的教程是部署到 <code>gh-pages</code> 分支上的，官网说可以切换 <code>GitHub Pages</code> 部署分支到 <code>gh-pages</code> 分支上，<strong>完全没说别的</strong>，作为刚使用一天的选手，我就是想把生成的分支改为 <code>master</code>，但是我在官方给的配置文件中根本没找到 <code>gh-pages</code>！，这里附带官网的配置文件（其中还要添加 <code>GH_TOKEN</code> 环境变量，这里就不展开说了）：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">sudo:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">node_js</span><br><span class="hljs-attr">node_js:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 使用 nodejs 的长期支持版本</span><br><span class="hljs-attr">cache:</span> <span class="hljs-string">npm</span><br><span class="hljs-attr">branches:</span><br>  <span class="hljs-attr">only:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span> <span class="hljs-comment"># 仅仅构建 master 分支</span><br><span class="hljs-attr">script:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span> <span class="hljs-comment"># 生成静态文件</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">provider:</span> <span class="hljs-string">pages</span><br>  <span class="hljs-attr">skip-cleanup:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">github-token:</span> <span class="hljs-string">$GH_TOKEN</span><br>  <span class="hljs-attr">keep-history:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">on:</span><br>    <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br>  <span class="hljs-attr">local-dir:</span> <span class="hljs-string">public</span><br></code></pre></div></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>我去网上找来找去，找到了几个类似的解决办法：</p><ul><li><a href="https://garryshield.github.io/2019/04/08/travis-ci/">通过 Travis CI 自动部署 Hexo 到 Github</a> - 这个实现方法，和官方的实现方法不太一样，我一般比较喜欢官方的实现方法，要是实在找不到解决办法才会用</li><li><a href="https://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/">使用 Travis CI 自动更新 GitHub Pages</a> - 这个说的也和官方的不太一样</li></ul><p>找来找去，结果在 <a href="https://docs.travis-ci.com/user/deployment/pages/">官方 pages 部署的文档</a> 里面找到了，原来这个部署的默认分支就是 <code>gh-pages</code>！可以通过进一步配置 <code>target_branch</code> 来修改！所以我把所有的源代码移到了 <code>source</code> 分支上，然后将配置文件改成了下面这样，就可以正常访问了。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">sudo:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">node_js</span><br><span class="hljs-attr">node_js:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 使用 nodejs 的长期支持版本</span><br><span class="hljs-attr">cache:</span> <span class="hljs-string">npm</span><br><span class="hljs-attr">branches:</span><br>  <span class="hljs-attr">only:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">source</span> <span class="hljs-comment"># 仅仅构建 source 分支</span><br><span class="hljs-attr">script:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span> <span class="hljs-comment"># 生成静态文件</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">provider:</span> <span class="hljs-string">pages</span><br>  <span class="hljs-attr">skip-cleanup:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">github-token:</span> <span class="hljs-string">$GH_TOKEN</span><br>  <span class="hljs-attr">keep-history:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">on:</span><br>    <span class="hljs-attr">branch:</span> <span class="hljs-string">source</span><br>  <span class="hljs-attr">local-dir:</span> <span class="hljs-string">public</span><br>  <span class="hljs-attr">target_branch:</span> <span class="hljs-string">master</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Travis CI</tag>
      
      <tag>GitHub Actions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程中的 KISS 原则</title>
    <link href="/2020/05/25/the-kiss-rules-in-programming/"/>
    <url>/2020/05/25/the-kiss-rules-in-programming/</url>
    
    <content type="html"><![CDATA[<p>参考<a href="https://zhuanlan.zhihu.com/p/110031390">知乎文章 - 编程中的 kiss 原则是什么</a></p><a id="more"></a><h2 id="KISS-表示的是什么"><a href="#KISS-表示的是什么" class="headerlink" title="KISS 表示的是什么"></a>KISS 表示的是什么</h2><p>KISS 是 Keep It Stupid Simple 或 Keep It Simple,Stupid 的缩写。</p><h2 id="KISS-的含义"><a href="#KISS-的含义" class="headerlink" title="KISS 的含义"></a>KISS 的含义</h2><p>该原则在<a href="https://www.zhihu.com/people/san-guo-you-xi-da-shi">作者</a>的多年的软件工程生涯中取得关键、巨大的成功。当今的软件工程师和开发者们有个共同的问题，那就是他们总是慢慢地使得问题复杂化。正确的做法应该是当开发者遇到一个问题后，把问题拆分成一个个能够明白的小块，然后进入编码阶段。<br><a href="https://www.zhihu.com/people/san-guo-you-xi-da-shi">作者</a>认为，10 个开发者中有 8 个或 9 个都没有把问题分解成足够小或可以理解的足够小的部分。这就导致了即使是一个非常简单的问题最后也变成了非常复杂的实现，另外一个副作用就是意大利面代码，在 BASIC 里只是一个 goto 语句的事情，在 Java 中却需要 500 到 1000 行代码，每个方法都有几百行代码。</p><p>你需要先想好问题的解决步骤一共分为几步，然后再进入编码。而不是拿到需求后，就开始一边写代码一边去满足需求。这样做的好处就是你的代码会变的足够容易理解和足够清晰。</p><h2 id="我们能从-KISS-中获取到什么好处"><a href="#我们能从-KISS-中获取到什么好处" class="headerlink" title="我们能从 KISS 中获取到什么好处"></a>我们能从 KISS 中获取到什么好处</h2><ul><li>你可以更好地解决更多问题。</li><li>你将可以通过很少的几行代码去解决复杂的问题。</li><li>你将可以产出高质量的代码。</li><li>你将可以构建更大更易维护的系统。</li><li>当新的需求来了后，你的代码将会更加的灵活，易于扩展、易于修改和重构。</li><li>你将完成比你想象得更多的事情。</li><li>你将能够工作在一个大型开发团队和大型项目中，因为所有的代码都是 stupid simple。</li></ul><h2 id="我如何把-KISS-原则用到我的工作中"><a href="#我如何把-KISS-原则用到我的工作中" class="headerlink" title="我如何把 KISS 原则用到我的工作中"></a>我如何把 KISS 原则用到我的工作中</h2><p><a href="https://www.zhihu.com/people/san-guo-you-xi-da-shi">作者</a>推荐了几个简单的步骤可供执行，但有一定挑战。就像说起来的那么简单，keep it simple，主要是需要耐心，更多的靠你自己。</p><ul><li>要谦虚，不要认为自己是个天才，这是你第一个误解。只有谦虚了，你才能真正达到超级天才的水平，即使不行，who cares！你的代码那么 stupid simple，所以你<strong>不需要是个天才</strong>！</li><li>将你的任务分解为 4 - 12 小时的子任务。</li><li>把你的问题拆分成多个小问题。每个问题用一个或者很少的几个类来解决掉。</li><li>保持你的方法足够小，每个方法永远不要超过 30 - 40 行代码。每个方法都应该只处理一个小小的问题，不要搞太多 uses case 进去。如果你的方法中有多个分支，尝试把他们拆分成多个小的方法。这样不仅容易阅读和维护，找 bug 也更快。慢慢的你将学会爱。</li><li>让你的类也小点，原则和上面的方法是一样的。</li><li>先解决问题，然后开始编码。不要一边编码，一边解决问题。这样做也没什么错，但你有能力提前把事情切分成多个小的块，然后开始编码可能是比较好的。但也请你不要害怕一遍遍重构你的代码。另外行数还不是为了衡量质量的标准，只是有个基本的尺子而已。</li><li>不要害怕干掉代码。重构和重做是两个非常重要的方面。如果你遵循上面的建议，重写代码的数量将会最小化，如果你不遵循，那么代码很可能会被重写。</li><li>其他的任何场景，都请你尝试尽可能的简单，simple，这也是最难的一步，但一旦你拥有了它，你再回头看，就会说，之前的事情就是一坨屎。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/110031390">知乎文章 - 编程中的 kiss 原则是什么</a></p>]]></content>
    
    
    <categories>
      
      <category>思想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KISS</tag>
      
      <tag>编程原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity 2D 平台跳跃游戏角色转身</title>
    <link href="/2019/10/19/unity-character-turn-around/"/>
    <url>/2019/10/19/unity-character-turn-around/</url>
    
    <content type="html"><![CDATA[<p>Unity 2D 平台跳跃游戏角色转身的一些方法</p><a id="more"></a><h2 id="方法-1-设置-Transform-中-Scale-属性为-1"><a href="#方法-1-设置-Transform-中-Scale-属性为-1" class="headerlink" title="方法 1 - 设置 Transform 中 Scale 属性为-1"></a>方法 1 - 设置 Transform 中 Scale 属性为-1</h2><p>具体实现方法如下</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> faceDirection = Input.GetAxisRaw(<span class="hljs-string">&quot;horizontal&quot;</span>);<br><span class="hljs-keyword">if</span> (!Mathf.Approximately(faceDirection, <span class="hljs-number">0.0f</span>))<br>&#123;<br>    transform.localScale = <span class="hljs-keyword">new</span> Vector3(faceDirection, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="方法-2-在动画器中新建相反方向的动画"><a href="#方法-2-在动画器中新建相反方向的动画" class="headerlink" title="方法 2 - 在动画器中新建相反方向的动画"></a>方法 2 - 在动画器中新建相反方向的动画</h2><p>在动画控制器中，新建一个 x 轴反转的属性，在我之前学习的教程中有具体描述</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>哔哩哔哩作者 <a href="https://space.bilibili.com/370283072/">M_studio</a> 的视频</p><p><a href="https://www.bilibili.com/video/BV154411f7Pa">Unity 教程 Your First Game|入门 Tutorial:05 角色方向&amp;跳跃</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity 游戏引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对单例模式的理解</title>
    <link href="/2019/10/11/some-understanding-to-singleton-pattern/"/>
    <url>/2019/10/11/some-understanding-to-singleton-pattern/</url>
    
    <content type="html"><![CDATA[<p>对单例模式的一些理解</p><a id="more"></a><h2 id="单例模式概述"><a href="#单例模式概述" class="headerlink" title="单例模式概述"></a>单例模式概述</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p>注意：</p><ul><li>单例类只能有一个实例</li><li>单例类必须创建自己的唯一实例</li><li>单例类必须给所有其他对象提供这一实例</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h3 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h3><p>一个全局使用的类频繁地创建与销毁。</p><h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><p>当您想控制实例数目，节省系统资源的时候。</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><p>构造函数是私有的。</p><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><ol><li>一个班级只有一个班主任</li><li>Windows是多进程多线程的，在操作一个文件的时候，就不可避免的出现多个进程或线程同时操作一个文件的情况，所以所有文件的处理必须通过唯一实例运行</li><li>设备管理器经常设计为单例模式，比如一个电脑有两个打印机，在输出的时候不能两台打印机处理同一文件</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>避免对资源的多重占用（比如写文件操作）。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><p>要求生产唯一序列号。</p></li><li><p>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</p></li><li><p>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p></li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton _instance = <span class="hljs-keyword">new</span> Singleton();<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _instance;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton _instance = <span class="hljs-keyword">new</span> Singleton2();<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (_instance != <span class="hljs-keyword">null</span>) &#123;<br>            _instance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> _instance;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">runoob.com - 单例模式</a></p><p><a href="https://refactoringguru.cn/design-patterns/singleton">refactoringguru.cn - 单例设计模式</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
