<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue 按钮防抖</title>
    <link href="/2023/05/04/vue-debounced-button/"/>
    <url>/2023/05/04/vue-debounced-button/</url>
    
    <content type="html"><![CDATA[<p>vue 防止短时间内重复点击按钮</p><span id="more"></span><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>需要将现有系统的一些按钮防止短时间内重复点击，以免重复提交请求。</p><h2 id="使用框架"><a href="#使用框架" class="headerlink" title="使用框架"></a>使用框架</h2><ul><li><a href="https://cn.vuejs.org/">Vuejs3</a></li><li><a href="https://element-plus.org/">element-plus</a></li><li><a href="https://windicss.org/">WindiCSS</a></li></ul><h2 id="自定义-directive"><a href="#自定义-directive" class="headerlink" title="自定义 directive"></a>自定义 directive</h2><p>使用 vue 的 Plugin 特性，新增一个 <code>v-limit-click</code> 指令，监听 <code>click</code> 事件，点击后对元素添加 <code>is-disabled</code> 和 <code>cursor-wait</code> 类并将 <code>disabled</code> 设置为 <code>true</code>，延迟后取消这两个类并将 <code>disabled</code> 设置为 <code>false</code>。</p><blockquote><p><code>is-disabled</code> 是 <code>element-plus</code> 中按钮是 <code>disabled</code> 的 <code>class</code> &gt; <code>cursor-wait</code> 是 WindiCSS 中 <code>cursor: wait</code> 的简写，加 ! 将这个 <code>cursor</code> 设定成为 <code>important</code> &gt; <code>disabled</code> 是 <code>HTML</code> 规范里设定的禁用按钮的属性</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Plugin</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LimitClickOptions</span> &#123;<br>  delay?: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">defaultOption</span>: <span class="hljs-title class_">LimitClickOptions</span> = &#123;<br>  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> classes = [<span class="hljs-string">&quot;is-disabled&quot;</span>, <span class="hljs-string">&quot;!cursor-wait&quot;</span>];<br><br><span class="hljs-keyword">const</span> limitClick = (opts?: <span class="hljs-title class_">LimitClickOptions</span>): <span class="hljs-function"><span class="hljs-params">Plugin</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; delay &#125; = &#123; ...defaultOption, ...opts &#125;;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">install</span>(<span class="hljs-params">app</span>) &#123;<br>      app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&quot;limitClick&quot;</span>, &#123;<br>        <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el</span>) &#123;<br>          el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            el.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(...classes);<br>            el.<span class="hljs-property">disabled</span> = <span class="hljs-literal">true</span>;<br>          &#125;);<br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            el.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(...classes);<br>            el.<span class="hljs-property">disabled</span> = <span class="hljs-literal">false</span>;<br>          &#125;, delay);<br>        &#125;,<br>      &#125;);<br>    &#125;,<br>  &#125;;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> limitClick;<br></code></pre></td></tr></table></figure><h2 id="将按钮点击事件设置为防抖"><a href="#将按钮点击事件设置为防抖" class="headerlink" title="将按钮点击事件设置为防抖"></a>将按钮点击事件设置为防抖</h2><p>对按钮的 <code>@click</code> 事件绑定的方法进行修改。缺点：需要修改原来的 <code>@click</code> 方法</p><h2 id="按钮点击后设置-loading"><a href="#按钮点击后设置-loading" class="headerlink" title="按钮点击后设置 loading"></a>按钮点击后设置 loading</h2><p>如果发送请求，可以在请求方法开始之前将 v-loading 设置为 true，请求完成后改回 false。缺点：如果请求过快点击两次还会调用两次</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li><a href="https://cn.vuejs.org/guide/reusability/custom-directives.html">自定义指令</a></li><li><a href="https://juejin.cn/post/6948621847239852062">Element-UI 中给 el-button 加上防抖</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vite 设置别名</title>
    <link href="/2022/07/12/set-alias-for-vite/"/>
    <url>/2022/07/12/set-alias-for-vite/</url>
    
    <content type="html"><![CDATA[<p>为 vite 配置 @ 别名来简化 import</p><span id="more"></span><h2 id="设置成果"><a href="#设置成果" class="headerlink" title="设置成果"></a>设置成果</h2><p>可以直接使用 @ 代指 src 来导入模块</p><p>Before:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../components&quot;</span>;<br></code></pre></td></tr></table></figure><p>After:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/components&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="Vite-Config"><a href="#Vite-Config" class="headerlink" title="Vite Config"></a>Vite Config</h2><p>修改 <code>vite.config.js</code> 或 <code>vite.config.ts</code>，在其中加上如下配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&quot;@&quot;</span>: <span class="hljs-string">&quot;/src&quot;</span>,<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="TSConfig"><a href="#TSConfig" class="headerlink" title="TSConfig"></a>TSConfig</h2><p>如果项目是 <code>Typescript</code> 项目，还需要修改 <code>tsconfig.json</code>，在 <code>compolierOptions</code> 项加上如下配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">&quot;baseUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;.&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;paths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;@/*&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;src/*&quot;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-comment">// ...</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docusaurus 设置中文菜单</title>
    <link href="/2022/05/03/docusaurus-set-chinese-menu/"/>
    <url>/2022/05/03/docusaurus-set-chinese-menu/</url>
    
    <content type="html"><![CDATA[<p>Docusaurus 设置中文菜单</p><span id="more"></span><div class="note note-warning">            <p>注意：现在docusaurus官方已经改正该疑惑处</p>          </div><p>Docusaurus 是一个静态页面生成工具，其中每个文章的 Edit this page 和 Next 默认都是英文，在设置中设置 zh-CN 是无效的，需要设置为 zh-Hans</p><p>在 <code>docusaurus.config.js</code> 文件的 <code>config</code> 字段中添加如下键值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> config = &#123;<br>  <span class="hljs-comment">// other config</span><br>  <span class="hljs-attr">i18n</span>: &#123;<br>    <span class="hljs-attr">defaultLocale</span>: <span class="hljs-string">&quot;zh-Hans&quot;</span>,<br>    <span class="hljs-attr">locales</span>: [<span class="hljs-string">&quot;zh-Hans&quot;</span>],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意，是 zh-Hans，不是 zh-CN。此处官方文档没有任何说明</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/facebook/docusaurus/tree/main/packages/docusaurus-theme-translations/locales/zh-Hans">翻译源代码</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docusaurus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis 实现数组存取</title>
    <link href="/2021/09/11/mybatis-custom-typehandler/"/>
    <url>/2021/09/11/mybatis-custom-typehandler/</url>
    
    <content type="html"><![CDATA[<p>通过 mybatis 自定义 TypeHandler 实现数组的存取</p><span id="more"></span><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>数据模型是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(value = &quot;test&quot;, autoResultMap = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; ids;<br>&#125;<br></code></pre></td></tr></table></figure><p>传入的参数是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;ids&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>存到数据库里面的要是这样的条目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">+-------+<br>|  ids  |<br>+-------+<br>| 1,2,3 |<br>+-------+<br></code></pre></td></tr></table></figure><p>要把这个数据存到数据库中，<strong>存到数据库里面的是 <code>varchar</code> 类型</strong>。由于 MySQL 没有数组类型的数据，而且 Mybatis 也没有特定的 TypeHandler 来处理这个类型的数据，所以要写一个自定义的 typeHandler</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>新建 <code>IntegerListTypeHandler</code> 类，别忘了判空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MappedJdbcTypes(JdbcType.VARCHAR)</span><br><span class="hljs-meta">@MappedTypes(List.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerListTypeHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseTypeHandler</span>&lt;List&lt;Integer&gt;&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNonNullParameter</span><span class="hljs-params">(PreparedStatement preparedStatement, <span class="hljs-type">int</span> i, List&lt;Integer&gt; integers, JdbcType jdbcType)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">if</span> (integers == <span class="hljs-literal">null</span>) &#123;<br>            preparedStatement.setString(i, <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            preparedStatement.setString(i, integers.stream().map(String::valueOf).collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>)));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(ResultSet resultSet, String s)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> resultSet.getString(s);<br><br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Arrays.stream(str.split(<span class="hljs-string">&quot;,&quot;</span>)).map(Integer::parseInt).collect(Collectors.toList());<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(ResultSet resultSet, <span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> resultSet.getString(i);<br><br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Arrays.stream(str.split(<span class="hljs-string">&quot;,&quot;</span>)).map(Integer::parseInt).collect(Collectors.toList());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(CallableStatement callableStatement, <span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> callableStatement.getString(i);<br><br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Arrays.stream(str.split(<span class="hljs-string">&quot;,&quot;</span>)).map(Integer::parseInt).collect(Collectors.toList());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/weixin_41862314/article/details/105553587">mybatisplus 中配置 TypeHanlder 实现自定义转换_<Sun>的博客-CSDN 博客_mybatisplus typehandler</a></li></ul><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>附上所有相关代码，使用的是 Mybatis-Plus 框架，数据库请自行配置</p><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><p><code>controller/TestController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.RequiredArgsConstructor;<br><span class="hljs-keyword">import</span> me.mazixiang.mybatisplustest.entity.Test;<br><span class="hljs-keyword">import</span> me.mazixiang.mybatisplustest.service.TestService;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestBody;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TestService testService;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/save&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Test t)</span> &#123;<br>        System.out.println(t.getIds());<br>        testService.save(t);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/get&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;Test&gt; <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> testService.list();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h3><p><code>entity/Test.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(value = &quot;test&quot;, autoResultMap = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-meta">@TableField(typeHandler = IntegerListTypeHandler.class)</span><br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; ids;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>entity/IntegerListTypeHandler.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> me.mazixiang.mybatisplustest.entity;<br><br><span class="hljs-keyword">import</span> org.apache.ibatis.type.BaseTypeHandler;<br><span class="hljs-keyword">import</span> org.apache.ibatis.type.JdbcType;<br><span class="hljs-keyword">import</span> org.apache.ibatis.type.MappedJdbcTypes;<br><span class="hljs-keyword">import</span> org.apache.ibatis.type.MappedTypes;<br><br><span class="hljs-keyword">import</span> java.sql.CallableStatement;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-meta">@MappedJdbcTypes(JdbcType.VARCHAR)</span><br><span class="hljs-meta">@MappedTypes(List.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerListTypeHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseTypeHandler</span>&lt;List&lt;Integer&gt;&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNonNullParameter</span><span class="hljs-params">(PreparedStatement preparedStatement, <span class="hljs-type">int</span> i, List&lt;Integer&gt; integers, JdbcType jdbcType)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">if</span> (integers == <span class="hljs-literal">null</span>) &#123;<br>            preparedStatement.setString(i, <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            preparedStatement.setString(i, integers.stream().map(String::valueOf).collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>)));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(ResultSet resultSet, String s)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> resultSet.getString(s);<br><br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Arrays.stream(str.split(<span class="hljs-string">&quot;,&quot;</span>)).map(Integer::parseInt).collect(Collectors.toList());<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(ResultSet resultSet, <span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> resultSet.getString(i);<br><br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Arrays.stream(str.split(<span class="hljs-string">&quot;,&quot;</span>)).map(Integer::parseInt).collect(Collectors.toList());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(CallableStatement callableStatement, <span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> callableStatement.getString(i);<br><br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Arrays.stream(str.split(<span class="hljs-string">&quot;,&quot;</span>)).map(Integer::parseInt).collect(Collectors.toList());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h3><p><code>mapper/TestMapper.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;<br><span class="hljs-keyword">import</span> me.mazixiang.mybatisplustest.entity.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Test&gt; &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p><code>service/TestService.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;<br><span class="hljs-keyword">import</span> me.mazixiang.mybatisplustest.entity.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IService</span>&lt;Test&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>service/impl/TestServiceImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;<br><span class="hljs-keyword">import</span> me.mazixiang.mybatisplustest.entity.Test;<br><span class="hljs-keyword">import</span> me.mazixiang.mybatisplustest.mapper.TestMapper;<br><span class="hljs-keyword">import</span> me.mazixiang.mybatisplustest.service.TestService;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;TestMapper, Test&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TestService</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h3><p><code>MybatisPlusTestApplication.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPlusTestApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(MybatisPlusTestApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Express 收到两次请求的方法</title>
    <link href="/2021/07/28/fix-express-receive-same-request/"/>
    <url>/2021/07/28/fix-express-receive-same-request/</url>
    
    <content type="html"><![CDATA[<p>介绍如何解决 Express 收到两次请求</p><span id="more"></span><h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>本来做一个服务器来接收 WebHook 请求，但是，一测试 WebHook 就会有两次请求进来，导致要执行的代码被重复执行两次，原代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-property">json</span>);<br><br><span class="hljs-comment">// Handle Functions...</span><br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">1919</span>);<br></code></pre></td></tr></table></figure><p>后来，打印出请求 IP 发现，会有两个值：<code>::ffff:127.0.0.1</code> 和 <code>::1</code>，经过搜索发现，这两个都是本机地址的 IPv6 标记，而如果监听 IPv6 地址，<code>net.Server</code> 也可能会监听 IPv4 地址导致收到两次重复请求。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>上网找到如下解决方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-property">json</span>);<br><br><span class="hljs-comment">// Handle Functions...</span><br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">1919</span>, <span class="hljs-string">&quot;0.0.0.0&quot;</span>);<br></code></pre></td></tr></table></figure><p>这样就可以只监听 IPv4 地址</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://codeplayer.vip/question/j7t0v/answer/j7t11">Node.js express 如何监听 IPv4 地址 - CodePlayer | 代码玩家</a></li><li><a href="https://serverfault.com/questions/840198/ipv6-are-there-actual-differences-between-local-addresses-1-and-ffff127-0">IPv6: Are There Actual Differences Between Local Addresses ::1 and ::ffff:127.0.0.1? - Server Fault</a></li><li><a href="https://stackoverflow.com/questions/59355190/whats-different-in-1-and-ffff127-0-0-1">express - What’s different in ::1 and ::ffff:127.0.0.1 - Stack Overflow</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Express</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 WordPress WP REST API 404 问题</title>
    <link href="/2021/07/20/fix-wp-restapi-404/"/>
    <url>/2021/07/20/fix-wp-restapi-404/</url>
    
    <content type="html"><![CDATA[<p>解决 WordPress 更新失败时 404 问题</p><span id="more"></span><p>在想更新文章时，显示 WordPress 更新失败，此响应不是合法的 json 响应，这种错误有四种情况</p><ul><li>WordPress 编辑器插件的问题</li><li>WordPress WP RestAPI 的问题</li><li>系统镜像的问题</li><li>伪静态的问题</li></ul><p>打开控制台看到 <code>404</code> 错误，判断为第二种错误</p><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><p>OS: Ubuntu Server 20.04<br>Apache: Apache2.4.41<br>WordPress: 5.7.2_zh_CN</p><h2 id="Apache2-配置"><a href="#Apache2-配置" class="headerlink" title="Apache2 配置"></a>Apache2 配置</h2><p>首先修改 &#x2F;etc&#x2F;apache2&#x2F;apache2.conf，找到下面的语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;Directory /var/www/&gt;<br>    Options Indexes FollowSymLinks<br>    AllowOverride None<br>    Require all granted<br>&lt;/Directory&gt;<br></code></pre></td></tr></table></figure><p>把 <code>AllowOverride</code> 改为 <code>All</code></p><h2 id="使用-rewrite-模块"><a href="#使用-rewrite-模块" class="headerlink" title="使用 rewrite 模块"></a>使用 rewrite 模块</h2><p>改了上面那些还不够，查看 WordPress 根目录下面的 .htaccess 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain"># BEGIN WordPress<br># 在“BEGIN WordPress”与“END WordPress”之间的指令（行）是<br># 动态生成的，只应被WordPress过滤器修改。<br># 任何对标记之间的指令的修改都会被覆盖。<br>&lt;IfModule mod_rewrite.c&gt;<br>RewriteEngine On<br>RewriteRule .* - [E=HTTP_AUTHORIZATION:%&#123;HTTP:Authorization&#125;]<br>RewriteBase /<br>RewriteRule ^index\.php$ - [L]<br>RewriteCond %&#123;REQUEST_FILENAME&#125; !-f<br>RewriteCond %&#123;REQUEST_FILENAME&#125; !-d<br>RewriteRule . /index.php [L]<br>&lt;/IfModule&gt;<br><br># END WordPress<br></code></pre></td></tr></table></figure><p>可以发现需要启用 mod_rewrite.c 模块</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ sudo a2enmod rewrite<br>Enabling module rewrite.<br>To activate the new configuration, you need to run:<br>  systemctl restart apache2<br><br>$ systemctl restart apache2<br></code></pre></td></tr></table></figure><p>重启服务后，问题就解决了</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1769015">[已解决]wordpress网站发布失败：此响应不是合法的JSON响应 - 云+社区 - 腾讯云 - 晓得博客</a></li><li><a href="http://www.iasptk.com/enable-apache-mod_rewrite-ubuntu-14-04-lts/">Enable apache mod_rewrite in Ubuntu 14.04 LTS</a></li><li><a href="https://stackoverflow.com/questions/34670533/wordpress-rest-api-wp-api-404-error-cannot-access-the-wordpress-rest-api">Stack Overflow</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Apache2</tag>
      
      <tag>WordPress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 Oracle Linux 8 中安装 Oracle Database EE 19c</title>
    <link href="/2021/05/07/install-oracle-database-on-oracle-linux-8/"/>
    <url>/2021/05/07/install-oracle-database-on-oracle-linux-8/</url>
    
    <content type="html"><![CDATA[<p>介绍如何在 Oracle Linux 中安装 Oracle Database EE 19c</p><span id="more"></span><p>由于我还是是初学者，不懂其中的原理，所以大多数的操作都是从网上搜索得来的。使用 RPM 安装的方法我重复了10次，最后还是无法进行连接。下面的步骤我重复了 8 次，最后成功使用 Navicat 软件连接。每个人环境都不相同，仅提供参考</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h3><p>VMWare 虚拟机</p><h3 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h3><ul><li>Oracle Linux 8.3</li><li>Oracle Database Enterprise Edition 19c</li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>需要准备：</p><ul><li>Oracle Linux 8 操作系统或者虚拟机，<a href="https://yum.oracle.com/oracle-linux-isos.html">点击链接前往下载页面</a></li><li>Oracle Database<a href="https://www.oracle.com/cn/database/technologies/oracle19c-linux-downloads.html">点击链接前往下载页面</a></li></ul><h2 id="配置-Linux-操作系统"><a href="#配置-Linux-操作系统" class="headerlink" title="配置 Linux 操作系统"></a>配置 Linux 操作系统</h2><p>Linux 安装好之后直接新建一个用户，用户名叫 oracle，密码随意</p><p>以 root 身份登录，新建一个用户组叫做 oinstall，执行以下命令为 Oracle 新建一个文件夹并将权限转移到 oracle 用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain"># mkdir -p /u01/app/oracle<br># mkdir -p /u01/app/oraInventory<br># chown -R oracle:oinstall /u01/app/oracle<br># chown -R oracle:oinstall /u01/app/oraInventory<br># chmod -R 775 /u01/app<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>注意：代码块中的 <code>#</code> 符号代表以 root 身份执行，<code>$</code> 符号代表以用户身份运行。不代表 bash 注释</p>          </div><p>将你下载的 zip 压缩文件使用 WinSCP 进行传输，传输到 &#x2F;tmp 文件夹下，假设文件名为 db_home.zip，以 oracle 用户的身份进行解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p /u01/app/oracle/product/19.0.0/dbhome_1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /u01/app/oracle/product/19.0.0/dbhome_1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">unzip -q /tmp/db_home.zip</span><br>...<br></code></pre></td></tr></table></figure><p>安装相关的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"># yum -y install oracle-database-preinstall-19c<br></code></pre></td></tr></table></figure><p>解压完成后，设置对应系统版本的环境变量（不设置会导致安装界面白屏），转换到对应目录执行安装程序</p><div class="note note-danger">            <p>注意：将下面的 <code>OEL8.3</code> 换成你下载的 Oracle Linux 的版本</p>          </div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">export</span> CV_ASSUME_DISTID=OEL8.3</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /u01/app/oracle/product/19.0.0/dbhome_1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./runInstaller</span><br>...<br></code></pre></td></tr></table></figure><p>按指示进行，如进行到第三步下图所示</p><p><img src="https://z3.ax1x.com/2021/05/07/g3O1Ff.png" alt="Step 3"></p><p>Password 处需要记住，最好包含大小写和数字，不会抛出异常</p><p>第四步 Root Script 处选择第一项，输入 root 用户的密码</p><p>之后如果监测交换区内存大小出异常，选择 ignore all 忽略掉异常</p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>编辑 <code>/home/oracle/.bashrc</code>，在末尾处添加以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">export TMP=/tmp<br>export TMPDIR=$TMP<br><br>export ORACLE_HOSTNAME=oracle-db-19c<br>export ORACLE_UNQNAME=oradb<br>export ORACLE_BASE=/u01/app/oracle<br>export ORACLE_HOME=$ORACLE_BASE/product/19.0.0/dbhome_1<br>export ORA_INVENTORY=/u01/app/oraInventory<br>export ORACLE_SID=orcl<br>export PDB_NAME=pdb<br>export DATA_DIR=$ORACLE_BASE/oradata<br>export PATH=$ORACLE_HOME/bin:$PATH<br>export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib<br>export CLASSPATH=$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib<br></code></pre></td></tr></table></figure><div class="note note-danger">            <p>注意：将 ORACLE_SID 的值换成你在第四步设置的 <code>Global database name</code></p>          </div><p>执行 <code>source /home/oracle/.bashrc</code> 来更新环境变量</p><p>更新完环境变量后执行 <code>lsnrctl start</code> 开始监听</p><h2 id="安装-SqlPlus（Linux）"><a href="#安装-SqlPlus（Linux）" class="headerlink" title="安装 SqlPlus（Linux）"></a>安装 SqlPlus（Linux）</h2><p>首先需要配置 SqlPlus 来进行数据库的启动，执行如下命令来安装 SqlPlus</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain"># yum -y install oracle-instantclient-release-el8.x86_64<br># yum -y install instantclient-sqlplus<br></code></pre></td></tr></table></figure><h2 id="使用-SqlPlus-操作数据库"><a href="#使用-SqlPlus-操作数据库" class="headerlink" title="使用 SqlPlus 操作数据库"></a>使用 SqlPlus 操作数据库</h2><p>在监听开启的情况下，执行如下命令来使用 SqlPlus 连接并开启数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sqlplus / as sysdba</span><br>SQL*Plus: Release 19.0.0.0.0 - Production on Fri May 7 08:39:13 2021<br>Version 19.3.0.0.0<br><br>Copyright (c) 1982, 2019, Oracle.  All rights reserved.<br><br>Connected to an idle instance.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">SQL&gt; </span><span class="language-bash">startup</span><br>ORACLE instance started.<br><br>Total System Global Area 2415918568 bytes<br>Fixed Size           9137640 bytes<br>Variable Size        536870912 bytes<br>Database Buffers     1862270976 bytes<br>Redo Buffers         7639040 bytes<br>Database mounted.<br>Database opened.<br><span class="hljs-meta prompt_">SQL&gt;</span><br></code></pre></td></tr></table></figure><p>执行如下命令来关闭数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">SQL&gt; </span><span class="language-bash">shutdown</span><br>Database closed.<br>Database dismounted.<br>ORACLE instance shut down.<br><span class="hljs-meta prompt_">SQL&gt;</span><br></code></pre></td></tr></table></figure><p>浏览器可以前往 <code>https://localhost:5500/em</code> 进行图形化管理，使用sys和你刚才设置的密码进行登录，登录不成功的话执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">SQL&gt; </span><span class="language-bash"><span class="hljs-built_in">exec</span> dbms_xdb_config.SetGlobalPortEnabled(TRUE)</span><br></code></pre></td></tr></table></figure><h2 id="使用数据库管理软件连接"><a href="#使用数据库管理软件连接" class="headerlink" title="使用数据库管理软件连接"></a>使用数据库管理软件连接</h2><p>首先执行如下命令来打开电脑的 <code>1521</code> 端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain"># firewall-cmd --add-port=1521/tcp --permanent<br>success<br># firewall-cmd --reload<br>success<br></code></pre></td></tr></table></figure><p>我使用 Navicat 进行连接。主机写 Linux 的 IP 地址，端口写 1521（默认），服务名就是你在第三步设置的默认数据库名称，默认就是 orcl，用户名是 sys，密码是你在第三步设置的密码，之后就可以连接了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.martinberger.com/2020/05/install-oracle-19c-rdbms-on-oracle-linux-8-avoid-warning-ins-08101-unexpected-error-while-executing-the-action-at-state-supportedoscheck/">Install Oracle 19c RDBMS on Oracle Linux 8 – avoid [WARNING] [INS-08101] Unexpected error while executing the action at state: ‘supportedOSCheck’ – martinberger.com</a></li><li><a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/ladbi/running-rpm-packages-to-install-oracle-database.html#GUID-BB7C11E3-D385-4A2F-9EAF-75F4F0AACF02">Running RPM Packages to Install Oracle Database</a></li><li><a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/ladbi/running-oracle-universal-installer-to-install-oracle-database.html#GUID-DD4800E9-C651-4B08-A6AC-E5ECCC6512B9">Running Oracle Database Setup Wizard to Install Oracle Database</a></li><li><a href="https://www.rultr.com/tutorials/4047.html">CentOS 8 系统安装 Oracle 19c 数据库 | RULTR</a></li><li><a href="https://cloud.tencent.com/developer/article/1027411">Oracle日常运维操作总结-数据库的启动和关闭 - 云+社区 - 腾讯云</a></li><li><a href="https://blog.csdn.net/qq_36659897/article/details/84100308">CentOS 7 启动Oracle_EricRan__的博客-CSDN博客_centos启动oracle数据库</a></li><li><a href="https://dba.stackexchange.com/questions/186235/oracle-12c-can-not-login-to-enterprise-manager-xdb-login-prompt">Oracle 12c - Can not login to Enterprise Manager - XDB Login prompt - Database Administrators Stack Exchange</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础 Redis</title>
    <link href="/2021/03/15/basic-redis/"/>
    <url>/2021/03/15/basic-redis/</url>
    
    <content type="html"><![CDATA[<p>介绍基础的 redis</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我使用 Docker 来进行安装，官网提供了 Linux 源代码，可以自行 make</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -p 6379:6379 --name redis-docker redis<br>...<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> redis:latest<br></code></pre></td></tr></table></figure><h2 id="默认端口由来"><a href="#默认端口由来" class="headerlink" title="默认端口由来"></a>默认端口由来</h2><p>Redis 是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。redis 的默认端口号是 6379。</p><p>为什么 Redis 选择 6379 作为默认端口号？</p><p>6379 在是手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字。</p><p>Alessia Merz 是一位意大利舞女、女演员。 Redis 作者 Antirez 早年看电视节目，觉得 Merz 在节目中的一些话愚蠢可笑，Antirez 喜欢造“梗”用于平时和朋友们交流，于是造了一个词 “MERZ”，形容愚蠢，与 “stupid” 含义相同。</p><p>后来 Antirez 重新定义了 “MERZ” ，形容”具有很高的技术价值，包含技艺、耐心和劳动，但仍然保持简单本质“。</p><p>到了给 Redis 选择一个数字作为默认端口号时，Antirez 没有多想，把 “MERZ” 在手机键盘上对应的数字 6379 拿来用了。</p><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>使用 <code>docker exec -it ID /bin/sh</code> 进入容器，使用 redis 命令进入命令行：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># redis-cli</span><br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure><h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><p>del 命令用于删除现有的 key</p><h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>string 类型是 redis 最基本的类型，一个 key 对应一个 value</p><p>一个键最大能存储 512 MB</p><p>用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set hello world<br>OK<br>127.0.0.1:6379&gt; get hello<br>&quot;world&quot;<br></code></pre></td></tr></table></figure><h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><p>hash 是一个键值对集合</p><p>每个 hash 可以存储 $2^{32}-1$ 个键值对</p><p>用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; hmset hello field1 value1 field2 value2<br>OK<br>127.0.0.1:6379&gt; hget hello field1<br><span class="hljs-string">&quot;value1&quot;</span><br></code></pre></td></tr></table></figure><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部或尾部</p><p>列表最多存储 $2^{32}-1$ 个元素</p><p>用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; lpush hello redis<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; lpush hello mongodb<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; lrange hello 0 10<br>1) <span class="hljs-string">&quot;redis&quot;</span><br>2) <span class="hljs-string">&quot;mongodb&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>set 是 string 类型的无序集合</p><p>集合是通过哈希表实现的，所以添加、删除、查找的复杂度都是 $O(1)$</p><p>集合中最大成员数为 $2^{32}-1$</p><p>用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; sadd hello redis<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd hello mongodb<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; sadd hello mongodb<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; smembers hello<br>1) <span class="hljs-string">&quot;redis&quot;</span><br>2) <span class="hljs-string">&quot;mongodb&quot;</span><br></code></pre></td></tr></table></figure><p>注：上面用法中 mongodb 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略</p><h3 id="zset（有序集合）"><a href="#zset（有序集合）" class="headerlink" title="zset（有序集合）"></a>zset（有序集合）</h3><p>zset 和 set 一样也是 string 类型元素的集合，不允许重复的成员</p><p>不同的是在 zset 中，每个元素都会关联一个 double 类型的分数。redis 通过分数来为集合中的成员进行从小到大的排序</p><p>zset 的成员是唯一的，但分数（score）可重复</p><p>用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; zadd hello redis<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zadd hello mongodb<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; zadd hello mongodb<br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; ZRANGESCORE runoob 0 1000<br>1) <span class="hljs-string">&quot;redis&quot;</span><br>2) <span class="hljs-string">&quot;mongodb&quot;</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://m.php.cn/redis/453699.html">redis默认端口是什么-Redis-PHP中文网</a></li><li><a href="https://www.runoob.com/redis/redis-data-types.html">Redis 数据类型 | 菜鸟教程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sass 笔记</title>
    <link href="/2021/03/06/sass-notes/"/>
    <url>/2021/03/06/sass-notes/</url>
    
    <content type="html"><![CDATA[<p>Sass 笔记</p><span id="more"></span><h2 id="Sass-Scss"><a href="#Sass-Scss" class="headerlink" title="Sass Scss"></a>Sass Scss</h2><p>SASS 语言有两种形式，一种是 SASS 形式，使用缩进来取代大括号，严格限制缩进：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">h1</span><br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-variable">$main-fonts</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$headings-color</span>;<br></code></pre></td></tr></table></figure><p>另一种是 SCSS，保留完整的大括号，不限制缩进：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-variable">$main-fonts</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$headings-color</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了括号和缩进外二者之间没有区别，下面使用的是 SCSS 形式</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>SASS 和 CSS 不同的地方之一是 SASS 的变量，SASS 用变量存储数据</p><p>SASS 的变量以 <code>$</code> 开头</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$main-fonts</span>: Arial, sans-serif;<br><span class="hljs-variable">$headings-color</span>: green;<br><br><span class="hljs-comment">//To use variables:</span><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-variable">$main-fonts</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$headings-color</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>变量可以让许多地方的相同颜色一起更改</p><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>SASS 允许你嵌套 CSS 规则</p><p>在一个很大的工程中，CSS 文件会有许多规则。嵌套可以帮你更好地组织代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">nav</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">list-style</span>: none;<br>&#125;<br><br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">nav</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br><br>  <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">list-style</span>: none;<br><br>    <span class="hljs-selector-tag">li</span> &#123;<br>      <span class="hljs-attribute">display</span>: inline-block;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h2><p>SASS 中，mixin 是一组可重用的 CSS 声明</p><p>CSS 新的特性需要一些时间来在所有浏览器兼容。当新特性加入到浏览器中时，CSS 规则可能需要一些前缀，例如 box-shadow</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  -webkit-<span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0px</span> <span class="hljs-number">4px</span> <span class="hljs-number">#fff</span>;<br>  -moz-<span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0px</span> <span class="hljs-number">4px</span> <span class="hljs-number">#fff</span>;<br>  -ms-<span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0px</span> <span class="hljs-number">4px</span> <span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0px</span> <span class="hljs-number">4px</span> <span class="hljs-number">#fff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果每个元素都有这一属性，重写它们将会很浪费时间。同时修改属性的话将耗费相当大的精力。</p><p>mixin 就像 CSS 的函数一样：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> box-shadow(<span class="hljs-variable">$x</span>, <span class="hljs-variable">$y</span>, <span class="hljs-variable">$blur</span>, <span class="hljs-variable">$c</span>)&#123; <br>  -webkit-<span class="hljs-attribute">box-shadow</span>: <span class="hljs-variable">$x</span> <span class="hljs-variable">$y</span> <span class="hljs-variable">$blur</span> <span class="hljs-variable">$c</span>;<br>  -moz-<span class="hljs-attribute">box-shadow</span>: <span class="hljs-variable">$x</span> <span class="hljs-variable">$y</span> <span class="hljs-variable">$blur</span> <span class="hljs-variable">$c</span>;<br>  -ms-<span class="hljs-attribute">box-shadow</span>: <span class="hljs-variable">$x</span> <span class="hljs-variable">$y</span> <span class="hljs-variable">$blur</span> <span class="hljs-variable">$c</span>;<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-variable">$x</span> <span class="hljs-variable">$y</span> <span class="hljs-variable">$blur</span> <span class="hljs-variable">$c</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@mixin</code> 后面跟着一个自定义的名称，参数是可选的。现在如果你想使用 <code>box-shadow</code> 这一属性的话，只需要用 <code>@include</code> 调用 <code>mixin</code> 规则</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-keyword">@include</span> box-shadow(<span class="hljs-number">0px</span>, <span class="hljs-number">0px</span>, <span class="hljs-number">4px</span>, <span class="hljs-number">#fff</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>SASS 中的 <code>@if</code> 指令用来测试特定的条件</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> make-bold(<span class="hljs-variable">$bool</span>) &#123;<br>  <span class="hljs-keyword">@if</span> <span class="hljs-variable">$bool</span> == true &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和 JS 中相同，也可以用 <code>else if</code> 和 <code>else</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> text-effect(<span class="hljs-variable">$val</span>) &#123;<br>  <span class="hljs-keyword">@if</span> <span class="hljs-variable">$val</span> == danger &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>  &#125;<br>  <span class="hljs-keyword">@else</span> if <span class="hljs-variable">$val</span> == alert &#123;<br>    <span class="hljs-attribute">color</span>: yellow;<br>  &#125;<br>  <span class="hljs-keyword">@else</span> if <span class="hljs-variable">$val</span> == success &#123;<br>    <span class="hljs-attribute">color</span>: green;<br>  &#125;<br>  <span class="hljs-keyword">@else</span> &#123;<br>    <span class="hljs-attribute">color</span>: black;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>可以用 <code>for</code> 指令来实现循环结构</p><p><code>@for</code> 指令有两种用法：<code>start through end</code> 和 <code>start to end</code>。前者是前开后开，后者是前开后闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sass">@for $i from 1 through 12 &#123;<br>  .col-#&#123;$i&#125; &#123; width: 100%/12 * $i; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#&#123;$i&#125;</code> 是使用变量 <code>i</code> 创建字符串，转换成 CSS 后是这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.col-1</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">8.33333%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.col-2</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">16.66667%</span>;<br>&#125;<br><br>...<br><br><span class="hljs-selector-class">.col-12</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>for 循环是创建网格布局的强大方法</p><h2 id="each"><a href="#each" class="headerlink" title="each"></a>each</h2><p>SASS 提供了 <code>@each</code> 指令来遍历 <code>list</code> 或者 <code>map</code> 中的元素</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$colors</span>: (color1: blue, color2: red, color3: green);<br><br><span class="hljs-keyword">@each</span> <span class="hljs-variable">$key</span>, <span class="hljs-variable">$color</span> in <span class="hljs-variable">$colors</span> &#123;<br>  .#&#123;<span class="hljs-variable">$color</span>&#125;-text &#123;<span class="hljs-attribute">color</span>: <span class="hljs-variable">$color</span>;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要用 <code>$key</code> 变量来引用映射中的键，否则编译后的 css 会有 color1、color2… 在里面</p><p>上面的代码会被转换为下面的 CSS</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.blue-text</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.red-text</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br><span class="hljs-selector-class">.green-text</span> &#123;<br>  <span class="hljs-attribute">color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p><code>@while</code> 指令用来执行循环</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$x</span>: <span class="hljs-number">1</span>;<br><span class="hljs-keyword">@while</span> <span class="hljs-variable">$x</span> &lt; <span class="hljs-number">13</span> &#123;<br>  <span class="hljs-selector-class">.col-</span>#&#123;<span class="hljs-variable">$x</span>&#125; &#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>/<span class="hljs-number">12</span> * <span class="hljs-variable">$x</span>;&#125;<br>  <span class="hljs-variable">$x</span>: <span class="hljs-variable">$x</span> + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，定义一个变量 <code>$x</code> 并设置为 1。然后使用 <code>while</code> 指令来创建当 <code>x</code> 小于 13 的循环。在设置完 <code>width</code> 属性后，<code>x: x + 1</code> 用来避免无限循环</p><h2 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h2><p>Sass 中的 Partial 是保存 CSS 代码段的单独文件。它们被导入并在其他 Sass 文件中使用。这是一种将相似的代码分组到模块中以保持其组织性的好方法。</p><p>部分名称以下划线 _ 字符开头，这告诉 Sass 它是 CSS 的一小段，而不是将其转换为 CSS 文件。另外，Sass 文件以 .scss 文件扩展名结束。要将部分代码导入到另一个 Sass 文件中，请使用 @import指令。</p><p>例如，如果你所有的 mixin 都保存在一个名为 _mixins.scss 的 Partial 中。main.scss 中使用它们的方法：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// In the main.scss file</span><br><br><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;mixins&#x27;</span><br></code></pre></td></tr></table></figure><p>请注意，在 import 语句中不需要下划线和文件扩展名。Sass 理解它是一个 Partial。一旦一个 Partial 被导入到一个文件中，所有的变量、mixin 和其他代码都可以使用。</p><h2 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h2><p>Sass有一个名为 extend 的特性，可以很容易地从一个元素借用 CSS 规则，然后在另一个元素上构建它们。</p><p>例如，下面的CSS规则块样式是一个.panel类。它有背景颜色、高度和边框</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.panel</span>&#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">70px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid green;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在你需要另一个叫。big-panel的面板。它具有与.panel相同的基本属性，但也需要一个宽度和字体大小。可以从.panel复制和粘贴初始的CSS规则，但是当您添加更多类型的面板时，代码会变得重复。extend指令是一种简单的方法，可以重用为一个元素编写的规则，然后为另一个元素添加更多的规则:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.big-panel</span>&#123;<br>  <span class="hljs-keyword">@extend</span> .panel;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了新的样式之外，.big-panel将具有与.panel相同的属性。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript 笔记</title>
    <link href="/2021/03/03/typescript-notes/"/>
    <url>/2021/03/03/typescript-notes/</url>
    
    <content type="html"><![CDATA[<p>TypeScript 笔记</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JS 的优点</p><ul><li>易学</li><li>易用</li></ul><p>JS 的缺点</p><ul><li>过于易学导致程序员不知道实现原理</li><li>开发过程容易埋下安全隐患</li><li>维护成本过高</li></ul><p>JS 不适合开发大型项目的原因</p><ul><li>早期（ES6 之前）面向对象的编程很麻烦</li><li>变量的类型不确定，变量之间的运算会有隐患（不会报错）</li><li>函数的参数没有类型</li></ul><p>JS 产生于第一次浏览器大战，网景和微软的大战，这导致了 JS 的制作周期非常的短，导致没有那么严谨</p><p>希望有一门语言可以克服 JS 的缺点，微软设计了 TypeScript 语言来实现这个目的</p><h3 id="TS-是什么"><a href="#TS-是什么" class="headerlink" title="TS 是什么"></a>TS 是什么</h3><ul><li>以 JS 为基础构建的语言</li><li>一个 JS 的超集</li><li>扩展了 JS，并添加了类型</li><li>可以在任何支持 JS 的平台中执行</li></ul><p>TS 不能被 JS 解析器直接执行，TS 代码要编译为 JS</p><h3 id="TS-增加了什么"><a href="#TS-增加了什么" class="headerlink" title="TS 增加了什么"></a>TS 增加了什么</h3><ul><li>类型</li><li>ES 的特性</li><li>添加 ES 不具备的新特性</li><li>丰富的配置选项</li></ul><h2 id="TS-开发环境搭建"><a href="#TS-开发环境搭建" class="headerlink" title="TS 开发环境搭建"></a>TS 开发环境搭建</h2><ol><li>下载 Nodejs</li><li>安装 Nodejs</li><li>使用 npm 全局安装 TS<ol><li>进入命令行</li><li>输入 <code>npm i -g typescript</code></li></ol></li><li>创建一个 TS 文件</li><li>使用 tsc 对 ts 文件进行编译<ol><li>进入命令行</li><li>进入 ts 文件所在目录</li><li>执行命令 <code>tsc file.ts</code></li></ol></li></ol><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><ul><li>类型声明是 TS 非常重要的一个特点</li><li>通过类型声明可以指定 TS 中变量的类型</li><li>指定类型时，对变量进行赋值时，TS 编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</li></ul><p>语法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> 变量: 类型;<br><span class="hljs-keyword">let</span> 变量: 类型 = 值;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">参数: 类型, 参数: 类型</span>): 类型 &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自动类型判断"><a href="#自动类型判断" class="headerlink" title="自动类型判断"></a>自动类型判断</h3><ul><li>TS 有自动的类型判断机制</li><li>当对变量的声明和复制时同时进行的，TS 编译器会自动判断变量的类型</li><li>所以如果你的变量声明和赋值是同时进行的，可以省略掉类型声明</li></ul><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li><code>number</code>：数字</li><li><code>string</code>：字符串</li><li><code>boolean</code>：布尔值 true 或者 false</li><li>字面量：限制变量的值就是该字面量的值</li><li><code>any</code>：任意类型</li><li><code>unknown</code>：类型安全的 any</li><li><code>void</code>：没有值或者 undefined</li><li><code>never</code>：不能是任何值</li><li><code>object</code>：JS 对象</li><li><code>array</code>：JS 数组</li><li><code>tuple</code>：元组，固定长度的数组（TS 新增）</li><li><code>enum</code>：枚举（TS 新增）</li></ul><h3 id="number-类型"><a href="#number-类型" class="headerlink" title="number 类型"></a><code>number</code> 类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">decimal</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">hex</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0xf00d</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">binary</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0b1010</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">octal</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0o744</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">big</span>: <span class="hljs-built_in">bigint</span> = <span class="hljs-number">100n</span>;<br></code></pre></td></tr></table></figure><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>可以使用 <code>|</code> 连接多个类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">boolean</span> | <span class="hljs-built_in">string</span>;<br><span class="hljs-comment">// 字面量</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">y</span>: <span class="hljs-string">&#x27;male&#x27;</span> | <span class="hljs-string">&#x27;female&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a><code>any</code> 类型</h3><p><code>any</code> 表示的是任意类型，一个变量设置为 <code>any</code> 后相当于对<strong>该变量</strong>关闭了 ts 的类型检测</p><p>声明变量如果不指定类型，则 TS 解析器会自动判断变量的类型为 <code>any</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">any</span>;<br>x = <span class="hljs-number">1</span>; <span class="hljs-comment">// 不会报错</span><br>x = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 不会报错</span><br>x = <span class="hljs-string">&#x27;hello&#x27;</span>; <span class="hljs-comment">// 不会报错</span><br><span class="hljs-keyword">let</span> y; <span class="hljs-comment">// d: any</span><br></code></pre></td></tr></table></figure><p>同时，<code>any</code> 类型的变量可以给任何类型的变量赋值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> x;<br>x = <span class="hljs-number">10</span>;<br>x = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>y = x; <span class="hljs-comment">// 不会报错</span><br></code></pre></td></tr></table></figure><p><strong>显式和隐式的 <code>any</code> 不建议使用</strong></p><h3 id="unknown-类型"><a href="#unknown-类型" class="headerlink" title="unknown 类型"></a><code>unknown</code> 类型</h3><p><code>unknown</code> 表示未知类型，是类型安全的 <code>any</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">unknown</span>;<br>x = <span class="hljs-number">10</span>;<br>x = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>y = x; <span class="hljs-comment">// 会报错</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>  y = x; <span class="hljs-comment">// 不会报错</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>unknown</code> 类型的变量赋值给已知类型的变量会报错</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言，可以告诉解析器 <code>unknown</code> 变量的实际类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">unknown</span>;<br>x = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>y = x; <span class="hljs-comment">// 会报错</span><br>y = x <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 不会报错</span><br>y = &lt;<span class="hljs-built_in">number</span>&gt;e; <span class="hljs-comment">// 不会报错</span><br></code></pre></td></tr></table></figure><h3 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a><code>void</code> 类型</h3><p>如果不显式声明返回值类型，ts 解析器会自动判断返回值类型</p><p><code>void</code> 类型表示空，以函数为例就表示没有返回值（或者返回值为 null、undefined）的函数</p><h3 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a><code>never</code> 类型</h3><p><code>never</code> 表示永远不会返回结果</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;&#125; <span class="hljs-comment">// 不会报错</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;&#125; <span class="hljs-comment">// 报错</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn3</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;报错了&#x27;</span>);<br>&#125; <span class="hljs-comment">// 不会报错</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn4</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;&#125;<br>&#125; <span class="hljs-comment">// 不会报错</span><br></code></pre></td></tr></table></figure><h3 id="object-类型"><a href="#object-类型" class="headerlink" title="object 类型"></a><code>object</code> 类型</h3><p>object 就是 JS 里面的对象，<strong>不太实用</strong>（JS 的一切都是对象）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">object</span>;<br>x = &#123;&#125;;<br>x = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;; <span class="hljs-comment">// 函数也是对象</span><br></code></pre></td></tr></table></figure><p>在限制对象的时候去<strong>限制对象里面包含的属性</strong>，而不是<strong>限制是不是对象</strong></p><p><code>&#123;&#125;</code> 里面可以指定对象中包含哪些属性，必须<strong>完全相同</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> &#125;;<br>x = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;abc&#x27;</span> &#125;; <span class="hljs-comment">// 不会报错</span><br>x = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">22</span> &#125;; <span class="hljs-comment">// 会报错</span><br></code></pre></td></tr></table></figure><p>可有可无的字段后面加 <code>?</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; age?: <span class="hljs-built_in">number</span> &#125;;<br>x = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;abc&#x27;</span> &#125;; <span class="hljs-comment">// 不会报错</span><br>x = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">22</span> &#125;; <span class="hljs-comment">// 不会报错</span><br></code></pre></td></tr></table></figure><p>要对某一字段有特定要求，不限制其他字段</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; [<span class="hljs-attr">propname</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span> &#125;;<br>x = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;; <span class="hljs-comment">// 不会报错</span><br>x = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;; <span class="hljs-comment">// 会报错</span><br></code></pre></td></tr></table></figure><p>函数结构的类型声明</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">func</span>: <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br>func = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;; <span class="hljs-comment">// 结构符合上面的定义</span><br></code></pre></td></tr></table></figure><h3 id="array-类型（数组）"><a href="#array-类型（数组）" class="headerlink" title="array 类型（数组）"></a><code>array</code> 类型（数组）</h3><p>类似 JS 的数组</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[]; <span class="hljs-comment">// number 类型的数组</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr2</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt;; <span class="hljs-comment">// number 类型的数组</span><br></code></pre></td></tr></table></figure><p>指定类型之后，数组里面的变量只能包含特定的类型</p><h3 id="tuple-类型"><a href="#tuple-类型" class="headerlink" title="tuple 类型"></a><code>tuple</code> 类型</h3><p>元组是固定长度的数组，存储效率比数组好一点</p><p>当数组元素的数量是固定的，可以用元组</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">t</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>];<br>t = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>]; <span class="hljs-comment">// 不会报错</span><br>t = [<span class="hljs-string">&#x27;hello&#x27;</span>]; <span class="hljs-comment">// 数量不对</span><br>t = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">123</span>]; <span class="hljs-comment">// 类型不对</span><br></code></pre></td></tr></table></figure><h3 id="enum-类型"><a href="#enum-类型" class="headerlink" title="enum 类型"></a><code>enum</code> 类型</h3><p>枚举在处理数据，有一些数据是在几个值之间选择（比如性别只能是男或者女）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Gender</span> &#123;<br>  <span class="hljs-title class_">Male</span>,<br>  <span class="hljs-title class_">Female</span>,<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">person</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">gender</span>: <span class="hljs-title class_">Gender</span> &#125;;<br>person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;test&#x27;</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-title class_">Gender</span>.<span class="hljs-property">Male</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>&amp; 表示同时满足左右两边的字段</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">person</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> &#125; &amp; &#123; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> &#125;;<br>person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;; <span class="hljs-comment">// 报错</span><br>person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">40</span> &#125;; <span class="hljs-comment">// 不会报错</span><br></code></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span> | <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">num2</span>: <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span> | <span class="hljs-number">5</span>; <span class="hljs-comment">// 复杂</span><br></code></pre></td></tr></table></figure><p>使用类型别名来定义复杂的结构</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">type</span> myType = <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span> | <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: myType;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">num2</span>: myType;<br></code></pre></td></tr></table></figure><h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p>前面的那些代码，有的有错误，但是还是可以编译成为 JS，因为符合 JS 的规范</p><h3 id="自动编译文件"><a href="#自动编译文件" class="headerlink" title="自动编译文件"></a>自动编译文件</h3><p>在编译文件时，TS 编译器会自动监视文件的变化，并在文件发生变化时重新编译</p><p>在编译时加上 -w 参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tsc -w test.ts<br></code></pre></td></tr></table></figure><h3 id="ts-配置文件"><a href="#ts-配置文件" class="headerlink" title="ts 配置文件"></a>ts 配置文件</h3><p>在项目下新建一个 tsconfig.json 文件，里面不需要写任何东西</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> &#123;&#125; &gt; tsconfig.json<br></code></pre></td></tr></table></figure><p>在项目文件夹下执行 tsc，编译器就会自动编译并监视所有 ts 文件</p><p>一些配置选项</p><h3 id="include"><a href="#include" class="headerlink" title="include"></a><code>include</code></h3><p>include 指定 ts 编译器要包含哪些文件</p><p><code>*</code> 代表任意文件</p><p><code>**</code> 代表任意目录</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;./src/**/*&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a><code>exclude</code></h3><p>exclude 指定 ts 编译器要排除哪些文件</p><p>默认值：<code>[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;]</code></p><h3 id="files"><a href="#files" class="headerlink" title="files"></a><code>files</code></h3><p>指定被编译文件的列表，只有需要编译的文件少时才会用到</p><h3 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a><code>compilerOptions</code></h3><p>compilerOption 包含多个子选项来完成对编译器的配置</p><ul><li><code>target</code>：设置代码编译的目标版本，可选值 ES3、ES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext</li><li><code>lib</code>：指定代码运行时所包含的库（宿主环境），可选值 ES3、ES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost 等等</li><li><code>module</code>：设置编译后代码使用的模块化系统，可选值 CommonJS、UMD、AMD、System、ES2020、ESNext、None</li><li><code>outDir</code>：指定编译后文件所在目录</li><li><code>outFile</code>：将<strong>全局作用域</strong>代码合并为一个文件（不能有模块化）</li><li><code>allowJs</code>：是否对 JS 文件进行编译，默认为 <code>false</code></li><li><code>checkJs</code>：是否检查 JS 代码是否符合语法规范，默认为 <code>false</code></li><li><code>removeComments</code>：是否移除注释，默认为 <code>false</code></li><li><code>noEmit</code>：是否<strong>不生成</strong>编译后生成的文件，默认为 <code>false</code></li><li><code>noEmitOnError</code>：当有错误时是否不生成编译后的文件，默认为 <code>false</code></li></ul><h3 id="alwaysStrict"><a href="#alwaysStrict" class="headerlink" title="alwaysStrict"></a><code>alwaysStrict</code></h3><p>生成的代码中是否使用 ES6 的严格模式，默认为 <code>false</code></p><p>当有模块的导入导出时，默认禁用掉严格模式</p><h3 id="noImplicitAny"><a href="#noImplicitAny" class="headerlink" title="noImplicitAny"></a><code>noImplicitAny</code></h3><p>不允许隐式 <code>any</code> 类型</p><p>指定代码中没指定类型的变量是否隐式声明为 <code>any</code> 类型</p><p>默认为 <code>false</code></p><h3 id="noImplicitThis"><a href="#noImplicitThis" class="headerlink" title="noImplicitThis"></a><code>noImplicitThis</code></h3><p>不允许不明确类型的 <code>this</code></p><p>默认为 <code>false</code></p><h3 id="strictNullChecks"><a href="#strictNullChecks" class="headerlink" title="strictNullChecks"></a><code>strictNullChecks</code></h3><p>严格的 <code>null</code> 控制</p><p>调用某个对象的方法的时候，这个对象有可能时 null，不能对空对象调用方法</p><p>默认为 <code>false</code></p><h3 id="strict"><a href="#strict" class="headerlink" title="strict"></a><code>strict</code></h3><p>所有严格检查的总开关</p><p>上面所有严格选项的开关</p><p>默认为 <code>false</code></p><h2 id="使用-webpack-打包-TS-代码"><a href="#使用-webpack-打包-TS-代码" class="headerlink" title="使用 webpack 打包 TS 代码"></a>使用 webpack 打包 TS 代码</h2><p>要用 webpack，要先用 npm 对包进行管理</p><p>在项目文件夹下执行 <code>npm init -y</code> 可以自动生成 <code>package.json</code> 文件</p><p>安装 <code>webpack</code> 和 <code>webpack-cli</code> 来对代码进行打包</p><p>安装 <code>typescript</code> 和 <code>ts-loader</code> 对代码进行整合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm i --save-dev webpack webpack-cli typescript ts-loader<br>...<br></code></pre></td></tr></table></figure><p>编写 <code>webpack</code> 配置文件 <code>webpack.config.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 引入一个包</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-comment">// webpack 中所有的配置信息都应该写在 module.exports 中</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// 指定入口文件</span><br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.ts&#x27;</span>,<br>  <span class="hljs-comment">// 指定打包文件所在目录</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-comment">// 指定打包文件的目录</span><br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    <span class="hljs-comment">// 打包后的文件名</span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-comment">// 指定 webpack 打包时要使用的模块</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-comment">// 指定要加载的规则</span><br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-comment">// 指定规则生效的文件</span><br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,<br>        <span class="hljs-comment">// 要使用的 loader</span><br>        <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;ts-loader&#x27;</span>,<br>        <span class="hljs-comment">// 要排除的文件</span><br>        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>对 ts 编译器进行配置：<code>tsconfig.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ES6&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ES6&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在 <code>package.json</code> 文件的 <code>script</code> 部分添加一个打包脚本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><h3 id="自动生成-HTML-文件"><a href="#自动生成-HTML-文件" class="headerlink" title="自动生成 HTML 文件"></a>自动生成 HTML 文件</h3><p>命令行中执行 <code>npm i --save-dev html-webpack-plugin</code> 安装包，可以帮我们自动生成 HTML 文件</p><p>在 <code>webpack.config.js</code> 中添加</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 引入 HTML 插件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HTMLWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// 配置 webpack 插件</span><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-comment">// 自动生成文件，引入相关资源</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTMLWebpackPlugin</span>(),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样，再执行 <code>npm run build</code> 的时候就可以生成一个 <code>index.html</code> 文件</p><p>也可以传入自定义的参数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">new</span> <span class="hljs-title class_">HTMLWebpackPlugin</span>(&#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;这是自定义的 title&quot;</span>,<br>&#125;),<br></code></pre></td></tr></table></figure><p>也可以自定义模板 HTML 文件</p><h3 id="开发服务器"><a href="#开发服务器" class="headerlink" title="开发服务器"></a>开发服务器</h3><p>命令行中执行 <code>npm i --save-dev webpack-dev-server</code> 来安装开发服务器</p><p>修改 <code>package.json</code> 中的 <code>scripts</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack serve --open chrome.exe&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>运行 <code>npm run dev</code> 就可以打开开发服务器了</p><h3 id="编译之前清空-dist-目录"><a href="#编译之前清空-dist-目录" class="headerlink" title="编译之前清空 dist 目录"></a>编译之前清空 dist 目录</h3><p>大多数时候需要保持 dist 目录为最新生成的，需要清理之前的 dist 目录</p><p>命令行中执行 <code>npm i --save-dev clean-webpack-plugin</code> 来安装插件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 引入 clean 插件</span><br>const <span class="hljs-punctuation">&#123;</span> CleanWebpackPlugin <span class="hljs-punctuation">&#125;</span> = require(<span class="hljs-string">&quot;clean-webpack-plugin&quot;</span>);<br><br><span class="hljs-comment">// ...</span><br>module.exports = <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// 配置 webpack 插件</span><br>  plugins<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-comment">// 清除 dist 目录</span><br>    new CleanWebpackPlugin()<span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// 自动生成文件，引入相关资源</span><br>    new HTMLWebpackPlugin(<span class="hljs-punctuation">&#123;</span><br>      title<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;这是自定义的 title&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span>;<br></code></pre></td></tr></table></figure><h3 id="ts-模块问题"><a href="#ts-模块问题" class="headerlink" title="ts 模块问题"></a>ts 模块问题</h3><p>假如在 ts 里面 require 另一个 ts 文件导出的变量，webpack 不知道你要导入的 ts 是可以作为模块被导入的</p><p>修改 <code>webpack.config.js</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// ...</span><br>module.exports = <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// 设置引用模块</span><br>  resolve<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    extensions<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;.ts&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;.js&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span>;<br></code></pre></td></tr></table></figure><h3 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h3><p>IE 浏览器不支持最新的 ES 标准，在写完代码之后必须转换为 IE 支持的版本</p><p>虽然在 TS 编译器中有这个选项，但是还有一些功能是 TS 编译器中不具备的</p><p>TS 编译器只能进行语法的转换，像是 ES6 的 Promise 是不能转换过去的</p><p>为了让代码有更好的兼容性，在开发时候推荐安装 Babel</p><p>命令行中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i --save-dev @babel/core @babel/preset-env babel-loader core-js<br></code></pre></td></tr></table></figure><ul><li><code>preset-env</code> 预先设置的环境</li><li><code>babel-loader</code> 将 Babel 和 webpack 结合</li><li><code>core-js</code> 模拟 JS 的运行环境，可以让老版本的浏览器用到新的技术</li></ul><p>修改配置文件 <code>webpack.config.js</code>，对 babel 进行配置</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// ...</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-comment">// 指定要加载的规则</span><br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-attr">use</span>: [<br>          <span class="hljs-comment">// 配置 babel</span><br>          &#123;<br>            <span class="hljs-comment">// 指定加载器</span><br>            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>            <span class="hljs-comment">// 设置 babel</span><br>            <span class="hljs-attr">options</span>: &#123;<br>              <span class="hljs-comment">// 设置预定义的环境</span><br>              <span class="hljs-attr">presets</span>: [<br>                [<br>                  <span class="hljs-comment">// 指定环境插件</span><br>                  <span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>,<br>                  <span class="hljs-comment">// 配置信息</span><br>                  &#123;<br>                    <span class="hljs-comment">// 要兼容的目标浏览器兼容版本</span><br>                    <span class="hljs-attr">targets</span>: &#123;<br>                      <span class="hljs-attr">chrome</span>: <span class="hljs-string">&#x27;88&#x27;</span>,<br>                    &#125;,<br>                    <span class="hljs-comment">// 指定 corejs 的版本</span><br>                    <span class="hljs-attr">corejs</span>: <span class="hljs-string">&#x27;3&#x27;</span>,<br>                    <span class="hljs-comment">// 使用 corejs 的方式</span><br>                    <span class="hljs-comment">// usage 表示按需加载</span><br>                    <span class="hljs-attr">useBuiltIns</span>: <span class="hljs-string">&#x27;usage&#x27;</span>,<br>                  &#125;,<br>                ],<br>              ],<br>            &#125;,<br>          &#125;,<br>          <span class="hljs-string">&#x27;ts-loader&#x27;</span>,<br>        ],<br>        <span class="hljs-comment">// ...</span><br>      &#125;,<br>    ],<br>  &#125;,<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>use 里面的模块是从后往前加载的，需要先将 TS 文件编译，后转换为兼容的代码</p><p>由于 babel 的配置较为复杂，要写一些配置信息</p><p>比如你的代码里面没有 Promise 这个类，但是 IE 里面没有这个类，corejs 里面有他自己实现的 Promise，就可以顺利放到 IE 里运行了，但是不代表 IE 就不会报错</p><p>babel 只管一部分代码，而 webpack 打包之后默认的会使用箭头函数，所以 IE 浏览器一定会报错，我们需要去指定 webpack 打包时不使用箭头函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// ...</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">environment</span>: &#123;<br>      <span class="hljs-attr">arrowFunction</span>: <span class="hljs-literal">false</span>,<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>定义类的语法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">class</span> 类名 &#123;<br>  属性名: 类型;<br>  <span class="hljs-keyword">readonly</span> 只读属性名: 类型;<br>  <span class="hljs-keyword">static</span> 静态属性名: 类型;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">参数: 类型</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.属性名 = 参数;<br>  &#125;<br><br>  方法名() &#123;&#125;<br>  <span class="hljs-keyword">static</span> 静态方法名() &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>readonly</code> 代表只读，可以用在属性</p><p><code>static</code> 代表静态，可以用在属性和方法</p><h3 id="构造函数和-this"><a href="#构造函数和-this" class="headerlink" title="构造函数和 this"></a>构造函数和 this</h3><p>构造函数会在对象创建时调用</p><p>在构造函数中，<code>this</code> 表示当前的实例</p><p>在方法中，<code>this</code> 表示调用当前方法的对象</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>extends 表示继承</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">class</span> 子类 <span class="hljs-keyword">extends</span> 父类 &#123;&#125;<br></code></pre></td></tr></table></figure><p>子类会拥有父类拥有的方法和属性</p><p>继承可以将多个将多个类中共有的代码抽象到一个父类</p><p>如果子类添加了和父类相同的方法，则子类会覆盖掉父类的方法</p><h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><p>super 表示当前类的父类</p><p>注意：如果在子类中写了构造函数，子类的构造函数必须对父类的构造函数进行调用</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>以 abstract 开头的类是抽象类，抽象类不能用来创建对象</p><p>抽象类是专门用来继承的类</p><p>抽象类中可以添加抽象方法，抽象方法使用 abstract 开头，没有方法体</p><p>抽象方法只能定义在抽象类中，子类必须要对抽象方法进行重写</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>描述一个对象的类型使用 <code>type</code></p><p>接口用来定义一个类的结构</p><p><code>type</code> 同一个名称只能声明一个</p><p><code>interface</code> 同一个名称可以声明多个，必须取到接口所有字段</p><p>定义类是，可以让类实现一个接口</p><p>接口和抽象类不同：</p><ul><li>接口里只有方法的定义，抽象类既可以只定义也可以实现</li><li>抽象类是继承，接口是实现</li></ul><h2 id="属性的封装"><a href="#属性的封装" class="headerlink" title="属性的封装"></a>属性的封装</h2><p>属性可以任意地被修改，会导致对象中的数据变的非常不安全</p><p>TS 可以在属性前添加属性的修饰符</p><p>public（默认值）：可以在任意位置访问和修改</p><p>private：只能在类的内部进行访问</p><p>protected：只能在当前类和当前类的子类中访问</p><p>对私有属性可以在类中添加方法使私有属性可以被外部访问</p><p>getter 方法用来读取属性 setter 方法用来设置属性</p><p>TS 中设置 getter 方法的方式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">newName: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;newName&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><p>TS 可以直接把属性定义在构造函数中</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> age: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在定义函数或者类时，如果遇到类型不明确的，就可以使用泛型</p><p>泛型的定义方式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> func&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br><span class="hljs-comment">// 可以直接调用具有泛型的函数</span><br><span class="hljs-title function_">func</span>(<span class="hljs-number">10</span>);<br>func&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-keyword">function</span> func2&lt;T, S&gt;(<span class="hljs-attr">a</span>: T, <span class="hljs-attr">b</span>: S): T &#123;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p>不指定类型，TS 可以自动对类型进行推断，但是不一定能推断出来</p><p>也可以指定泛型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">function</span> func3&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MyInterface</span>&gt;(<span class="hljs-attr">a</span>: T): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> a.<span class="hljs-property">length</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>泛型可以同时指定多个</p><p><code>T extends MyInterface</code> 表示泛型 T 必须是 <code>MyInterface</code> 的实现类</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 8 中主要新特性</title>
    <link href="/2021/02/26/java8-new-features/"/>
    <url>/2021/02/26/java8-new-features/</url>
    
    <content type="html"><![CDATA[<p>介绍 Java 8 中主要的新特性：Lambda 表达式、函数式接口、方法引用与构造器引用、Stream API 和 Optional 类</p><span id="more"></span><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>lambda 表达式使用举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我爱北京天安门&quot;</span>);<br>    &#125;<br>&#125;;<br><br>r1.run();<br>System.out.println(<span class="hljs-string">&quot;===========&quot;</span>);<br><span class="hljs-type">Runnable</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;我爱北京故宫&quot;</span>);<br>r2.run();<br></code></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>-&gt;</code>：Lambda 操作符</p><p>左边是形参列表，其实就是接口中抽象方法的形参列表</p><p>右边是 <code>Lambda</code> 体，其实就是抽象方法的方法体</p><p>语法格式一：无参无返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;我爱北京故宫&quot;</span>);<br></code></pre></td></tr></table></figure><p>语法格式二：需要参数，无返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Consumer&lt;String&gt; consumer = (String s) -&gt; System.out.println(s);<br></code></pre></td></tr></table></figure><p>语法格式三：参数类型可以省略，可以由编译器推断得出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Consumer&lt;String&gt; consumer = (s) -&gt; System.out.println(s);<br></code></pre></td></tr></table></figure><p>语法格式四：如果只需要一个参数，参数的小括号可以省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Consumer&lt;String&gt; con = s -&gt; System.out.println(s);<br></code></pre></td></tr></table></figure><p>语法格式五：需要两个或以上的参数，多条执行语句，可以有返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;Integer&gt; con = (x, y) -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;实现函数式接口方法&quot;</span>);<br>    <span class="hljs-keyword">return</span> Integer.compare(x, y);<br>&#125;;<br></code></pre></td></tr></table></figure><p>语法格式六：当 Lambda 体只有一条语句时，<code>return</code> 和大括号都可以省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Consumer&lt;String&gt; con = s -&gt; System.out.println(s);<br>Comparator&lt;Integer&gt; con = (x, y) -&gt; Integer.compare(x, y);<br></code></pre></td></tr></table></figure><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>Lambda 表达式的本质是函数式接口的实例</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>当一个接口只包含一个抽象方法，这个接口就是函数式接口</p><p>可以通过 Lambda 表达式来创建这个接口的对象（若 Lambda 表达式抛出一个异常，那么该异常需要在目标接口的抽象方法上进行声明）</p><p>可以在一个接口上使用 <code>@FunctionalInterface</code> 注解，这样可以检查是否是一个函数式接口。同时 JavaDoc 也会包含一条声明，说明这个接口是一个函数式接口</p><p>在 <code>java.util.function</code> 包下定义了 Java8 的丰富函数式接口</p><p><a href="https://www.notion.so/1c805457b4e949619a9706124ecc2a0b">Java 内置四大核心函数式接口</a></p><h2 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h2><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>当要传递给 Lambda 体的操作，已经有实现的方法了，可以使用方法引用</p><p>方法引用可以看作是 Lambda 表达式深层次的表达。换句话说，方法引用就是 Lambda 表达啊是，也就是函数式接口的一个实例，通过方法的名字指向一个方法，可以认为是 Lambda 表达式的一个语法糖</p><p>要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法参数列表和返回值类型保持一致</p><p>格式：使用操作符 <code>::</code> 将类（或对象）与方法名分割开</p><p>主要有以下三种情况</p><ul><li>情况一：对象<code>::</code>实例方法名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Employee</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1001</span>, <span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-number">5600</span>);<br>Supplier&lt;String&gt; sup = () -&gt; e.getName();<br><span class="hljs-comment">// to</span><br>Supplier&lt;String&gt; sup2 = e::getName;<br></code></pre></td></tr></table></figure><ul><li>情况二：类<code>::</code>静态方法名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Consumer&lt;String&gt; consumer = (s) -&gt; System.out.println(s);<br><span class="hljs-comment">// to</span><br>Consumer&lt;String&gt; consumer2 = System.out::println;<br><br>Comparator&lt;Integer&gt; com1 = (t1, t2) -&gt; Integer.compare(t1, t2);<br><span class="hljs-comment">// to</span><br>Comparator&lt;Integer&gt; com2 = Integer::compare;<br></code></pre></td></tr></table></figure><ul><li>情况三：类<code>::</code>实例方法名（特殊）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;String&gt; com1 = (s1, s2) -&gt; s1.compareTo(s2);<br><span class="hljs-comment">// to</span><br>Comparator&lt;String&gt; com2 = String::compareTo;<br><br>Function&lt;Employee, String&gt; func1 = e -&gt; e.getName();<br><span class="hljs-comment">// to</span><br>Function&lt;Employee, String&gt; func2 = e -&gt; Employee::getName;<br></code></pre></td></tr></table></figure><p>使用情况：当要传递给 Lambda 体的操作已经有实现的方法了，可以用方法引用</p><p>本质：方法引用本质上是 Lambda 表达式，Lambda 表达式作为函数式接口的实例。所以方法引用也是函数式接口的实例</p><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>构造器引用和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。抽象方法的返回值类型即为构造器所属的类的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Supplier&lt;Employee&gt; sup = () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>();<br><span class="hljs-comment">// to</span><br>Supplier&lt;Employee&gt; sup2 = Employee::<span class="hljs-keyword">new</span>;<br><br>Function&lt;Integer, Employee&gt; func = (id) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(id);<br><span class="hljs-comment">// to</span><br>Function&lt;Integer, Employee&gt; func2 = Employee::<span class="hljs-keyword">new</span>;<br><br>BiFunction&lt;Integer, String, Employee&gt; bf1 = (id, name) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(id, name);<br><span class="hljs-comment">// to</span><br>BiFunction&lt;Integer, String, Employee&gt; bf1 = Employee::<span class="hljs-keyword">new</span>;<br></code></pre></td></tr></table></figure><h3 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h3><p>可以把数组看作特殊的类，则写法与构造器引用相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Function&lt;Integer, String[]&gt; func = length -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[length];<br><span class="hljs-comment">// to</span><br>Function&lt;Integer, String[]&gt; func = String[]::<span class="hljs-keyword">new</span>;<br></code></pre></td></tr></table></figure><h2 id="强大的-Stream-API"><a href="#强大的-Stream-API" class="headerlink" title="强大的 Stream API"></a>强大的 Stream API</h2><p>Stream API（<code>java.util.stream</code>）把真正的函数式编程风格引入到 Java 中</p><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作</p><h3 id="为什么要用-Stream-API"><a href="#为什么要用-Stream-API" class="headerlink" title="为什么要用 Stream API"></a>为什么要用 Stream API</h3><p>是集开发中，项目中多数数据源都来自 mySQL，Oracle 等。但现在数据源可以更多了，有 MongoDB，Redis 等，而这些 NoSQL 的数据需要 Java 层面处理。</p><h3 id="Stream-和-Collection-的区别"><a href="#Stream-和-Collection-的区别" class="headerlink" title="Stream 和 Collection 的区别"></a>Stream 和 Collection 的区别</h3><p>Collection 是一种静态内存数据结构，而 Stream 是有关计算的。前者主要是面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算</p><h3 id="关于-Stream-注意"><a href="#关于-Stream-注意" class="headerlink" title="关于 Stream 注意"></a>关于 Stream 注意</h3><ol><li>Stream 自己不会存储元素</li><li>Stream 不会改变源对象。他们会返回一个持有结果的新 Stream</li><li>Stream 的操作是延迟执行的，这意味着他们会等到需要结果的时候才执行</li></ol><h3 id="Stream-执行流程"><a href="#Stream-执行流程" class="headerlink" title="Stream 执行流程"></a>Stream 执行流程</h3><ol><li>创建 Stream：一个数据源（如集合、数组），获取一个流</li><li>中间操作：一个中间操作链，对数据源的数据进行处理</li><li>终止操作：一旦执行终止操作，就执行中间操作链并产生结果。之后不会再被使用</li></ol><h3 id="创建-Stream-方式"><a href="#创建-Stream-方式" class="headerlink" title="创建 Stream 方式"></a>创建 Stream 方式</h3><p>方式一：通过集合</p><p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>Stream&lt;Integer&gt; stream = list.stream();<br>Stream&lt;Integer&gt; parallelStream = list.parallelStream();<br></code></pre></td></tr></table></figure><p>方式二：通过数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">IntStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br></code></pre></td></tr></table></figure><p>方式三：通过 Stream 的 of</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; stream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>方式四：创建无限流（不常用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 迭代</span><br>Stream.iterate(<span class="hljs-number">0</span>, t -&gt; t + <span class="hljs-number">2</span>).limit(<span class="hljs-number">10</span>).forEach(System.out::println);<br><span class="hljs-comment">// 生成</span><br>Stream.generate(Math::random).limit(<span class="hljs-number">10</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><h3 id="Stream-的中间操作"><a href="#Stream-的中间操作" class="headerlink" title="Stream 的中间操作"></a>Stream 的中间操作</h3><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理。而在终止操作时一次性全部处理，称为惰性求值</p><p>筛选与切片：</p><ul><li><code>filter(Predicate p)</code>：接收 Lambda，从流中排除某些元素</li><li><code>distinct()</code>：筛选，通过流所生成元素的 <code>hashCode()</code> 和 <code>equals()</code> 去除重复元素</li><li><code>limit(long maxSize)</code>：截断流，使其元素不超过给定数量</li><li><code>skip(long n)</code>：跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流，与 <code>limit(n)</code> 互补</li></ul><p>映射：</p><ul><li><code>map(Function f)</code>：接收一个函数作为参数，该函数将会被应用到每个元素上，并将其映射成一个新的元素</li><li><code>mapToDouble(ToDoubleFunction f)</code>：接收一个函数作为参数，该函数将会被应用到每个元素上，产生一个新的 <code>DoubleStream</code></li><li><code>mapToInt(ToIntFunction f)</code>：接收一个函数作为参数，该函数将会被应用到每个元素上，产生一个新的 <code>IntStream</code></li><li><code>mapToLong(ToLongFunction f)</code>：接收一个函数作为参数，该函数将会被应用到每个元素上，产生一个新的 <code>LongStream</code></li><li><code>flatMap(Function f)</code>：接收一个函数作为参数，将流中的每一个值都换成另一个流，然后把所有流连接成一个流（相当于嵌套循环，将里面一层循环打开）</li></ul><p>排序：</p><ul><li><code>sorted()</code>：产生一个新流，其中按自然顺序排序</li><li><code>sorted(Comparator com)</code>：产生一个新流，其中按指定的比较器排序</li></ul><h3 id="Stream-的终止操作"><a href="#Stream-的终止操作" class="headerlink" title="Stream 的终止操作"></a>Stream 的终止操作</h3><p>终止操作会从流的流水线生成结果，其结果可以是任意不是流的值，例如 <code>List</code>、<code>Integer</code>，甚至是 <code>void</code></p><p>匹配与查找：</p><ul><li><code>allMatch(Predicate p)</code>：检查是否匹配所有元素，返回 <code>boolean</code></li><li><code>anyMatch(Predicate p)</code>：检查是否至少匹配一个元素，返回 <code>boolean</code></li><li><code>noneMatch(Predicate p)</code>：检查是否没有匹配所有元素，返回 <code>boolean</code></li><li><code>findFirst()</code>：返回第一个元素，返回 <code>Optional&lt;T&gt;</code></li><li><code>findAny()</code>：返回当前流中的任意元素，返回 <code>Optional&lt;T&gt;</code></li><li><code>count()</code>：返回流中元素的总个数，返回 <code>long</code></li><li><code>max(Comparator c)</code>：返回流中的最大值，返回 <code>Optional&lt;T&gt;</code></li><li><code>min(Comparator c)</code>：返回流中的最小值，返回 <code>Optional&lt;T&gt;</code></li><li><code>forEach(Consumer c)</code>：内部迭代</li></ul><p>规约：</p><ul><li><code>reduce(T identify, BinaryOperator&lt;T&gt; operator)</code>：将流中的元素反复结合起来，得到一个值，返回 <code>T</code>，第一个参数是初始值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 求 1-10 的和</span><br>List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);<br>list.stream().reduce(<span class="hljs-number">0</span>, Integer::sum);<br></code></pre></td></tr></table></figure><p>收集：</p><ul><li><code>collect(Collector c)</code>：将流转换为其他形式，接收一个 <code>Collector</code> 接口的实现，用于给 <code>Stream</code> 中的元素做汇总的方法</li></ul><p><code>Collector</code> 接口中方法的实现决定了如何对流执行收集的操作（如收集到 <code>List</code>、<code>Set</code>、<code>Map</code>）</p><p>Collectors 实用类提供了很多静态的方法，可以方便地创建收集器实例</p><ul><li><code>toList()</code>：把流中元素收集到 <code>List</code>，返回 <code>List&lt;T&gt;</code></li><li><code>toSet()</code>：把流中元素收集到 <code>Set</code>，返回 <code>Set&lt;T&gt;</code></li><li><code>toCollection()</code>：把流中元素收集到创建的集合，返回 <code>Collection&lt;T&gt;</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Employee&gt; employeeList = employees.stream().collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h2 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h2><p><code>Optional&lt;T&gt;</code> 类是一个容器类，可以保存类型 T 的值，代表这个值存在，或者仅仅保存 <code>null</code>，表示这个值不存在。原来用 <code>null</code> 表示一个值不存在，现在 <code>Optional</code> 可以更好地表达这个概念，并且可以避免空指针异常</p><p>创建 <code>Optional</code> 对象的方法</p><ul><li><code>Optional.of(T t)</code>：创建一个 <code>Optional</code> 实例，<strong>t 必须非空</strong></li><li><code>Optional.empty()</code>：创建一个空的 <code>Optional</code> 实例</li><li><code>Optional.ofNullAple(T t)</code>：t 可以为 <code>null</code></li></ul><p>判断 <code>Optional</code> 容器中是否包含对象</p><ul><li><code>isPresent()</code>：判断是否包含对象，返回 <code>boolean</code></li><li><code>ifPresent(Consumer&lt;? super T&gt; consumer)</code>：如果有值，就执行 <code>Consumer</code> 接口实现的代码，并且该值会作为参数传递给它</li></ul><p>获取 <code>Optional</code> 容器中的对象</p><ul><li><code>get()</code>：如果调用对象包含值，返回该值，否则抛异常</li><li><code>orElse(T other)</code>：如果有值则返回，否则返回指定的 <code>other</code> 对象</li><li><code>orElseGet(Supplier&lt;? extends T&gt; other)</code>：如果有值则返回，否则返回由 <code>Supplier</code> 接口实现提供的对象</li><li><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>：如果有值则返回，否则抛出由 <code>Supplier</code> 接口实现提供的异常</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Lambda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 笔记 - 动态代理</title>
    <link href="/2021/02/25/java-notes-dynamic-proxy/"/>
    <url>/2021/02/25/java-notes-dynamic-proxy/</url>
    
    <content type="html"><![CDATA[<p>Java 笔记 - 动态代理</p><span id="more"></span><h2 id="代理设计模式的原理"><a href="#代理设计模式的原理" class="headerlink" title="代理设计模式的原理"></a>代理设计模式的原理</h2><p>使用一个代理将对象包装起来，然后用该代理对象取代原始对象，任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</p><h2 id="静态代理的例子"><a href="#静态代理的例子" class="headerlink" title="静态代理的例子"></a>静态代理的例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClothFactory</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceCloth</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyClothFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClothFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> ClothFactory factory; <span class="hljs-comment">// 用被代理类对象进行实例化</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyClothFactory</span><span class="hljs-params">(ClothFactory factory)</span> &#123;<br>        <span class="hljs-built_in">this</span>.factory = factory;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceCloth</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;代理工厂做准备工作&quot;</span>);<br>        factory.produceCloth();<br>        System.out.println(<span class="hljs-string">&quot;代理工厂做后续工作&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NikeClothFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClothFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceCloth</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Nike 工厂生产一批运动服&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticProxyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建被代理类的对象</span><br>        <span class="hljs-type">NikeClothFactory</span> <span class="hljs-variable">nike</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NikeClothFactory</span>();<br>        <span class="hljs-comment">// 创建代理类的对象</span><br>        <span class="hljs-type">ProxyClothFactory</span> <span class="hljs-variable">proxyClothFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyClothFactory</span>(nike);<br><br>        proxyClothFactory.produceCloth();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态代理的特点是代理类和被代理类在编译期间确定下来了</p><h2 id="动态代理举例"><a href="#动态代理举例" class="headerlink" title="动态代理举例"></a>动态代理举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Human</span> &#123;<br>    String <span class="hljs-title function_">getBelief</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String food)</span>;<br>&#125;<br><br><span class="hljs-comment">// 被代理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperMan</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Human</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBelief</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I believe I can fly.&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String food)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我喜欢吃 &quot;</span> + food);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 问题一：如何根据加载到内存中的被代理类，动态创建一个代理类及其对象</span><br><span class="hljs-comment">* 问题二：当通过代理类的对象调用方法时，如何动态调用被代理类中的方法</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span> &#123;<br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 调用此方法返回一个代理类的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj 被代理类的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 代理类的对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-type">MyInvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInvocationHandler</span>();<br><br>        handler.bind(obj);<br><br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-comment">// 需要使用被代理类的对象来赋值</span><br>    <span class="hljs-keyword">private</span> Object obj;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-built_in">this</span>.obj = obj;<br>    &#125;<br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 通过代理类的对象调用方法时，会自动调用如下方法</span><br><span class="hljs-comment">     * 将被代理类要执行的方法的功能声明在 invoke 方法中</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> proxy 代理类的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method 代理类的对象要调用的方法，也是被代理类对象要调用的方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args 同名方法的参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 要调用的方法的返回值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable 抛出的异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">return</span> method.invoke(obj, args);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicProxyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SuperMan</span> <span class="hljs-variable">superMan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperMan</span>();<br>        <span class="hljs-comment">// 代理类的对象</span><br>        <span class="hljs-type">Human</span> <span class="hljs-variable">proxyInstance</span> <span class="hljs-operator">=</span> (Human) ProxyFactory.getProxyInstance(superMan);<br>        <span class="hljs-comment">// 当通过代理类对象调用方法时，会自动调用被代理类中的同名方法</span><br>        proxyInstance.getBelief();<br>        proxyInstance.eat(<span class="hljs-string">&quot;四川麻辣烫&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态代理和-AOP"><a href="#动态代理和-AOP" class="headerlink" title="动态代理和 AOP"></a>动态代理和 AOP</h2><p>AOP（Aspect Oriented Programming），面向切面编程</p><p>在上个例子的 <code>invoke</code> 方法中，可以自由添加你想要执行的方法，这就是面向切面的编程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// your method...</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> method.invoke(obj, args);<br>    <span class="hljs-comment">// your method...</span><br>    <span class="hljs-keyword">return</span> returnValue;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
      <tag>动态代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 笔记 - 反射</title>
    <link href="/2021/02/23/java-notes-reflection/"/>
    <url>/2021/02/23/java-notes-reflection/</url>
    
    <content type="html"><![CDATA[<p>Java 笔记 - 反射</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>反射被视为动态语言的关键，反射机制允许程序在执行期间借助于 API 取得任何类的内部信息，并直接操作任意对象的内部属性及方法</p><p>加载完类之后，在堆内存的方法区产生了一个 Class 类型的对象，这个对象包含了完整的类的结构信息。可以通过这个对象看到类的结构。这个对象就像一面镜子，透过镜子可以看到类的结构，所以称之为反射</p><p>动态语言</p><p>在运行时可以改变其结构的语言，如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化</p><p>主要有：C#，JS，PHP、Python</p><p>静态语言</p><p>运行时结构不可变的语言是静态语言，如 Java、C、C++</p><p>Java 不是动态语言，但是 Java 可以称之为准动态语言，即 Java 有一定的动态性，我们可以利用反射机制来获得类似动态语言的特性。</p><h3 id="反射机制提供的功能"><a href="#反射机制提供的功能" class="headerlink" title="反射机制提供的功能"></a>反射机制提供的功能</h3><ul><li>在运行时判断一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li>生成动态代理</li></ul><h2 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h2><p>Person 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// getters and setters</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;你好，我是一个人&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">showNation</span><span class="hljs-params">(String nation)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我的国籍是：&quot;</span> + nation);<br>        <span class="hljs-keyword">return</span> nation;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正常可以对 Person 示例进行的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建 Person 对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-number">12</span>);<br><br>        <span class="hljs-comment">// 访问对象内部的属性、方法</span><br>        p1.age = <span class="hljs-number">10</span>;<br>        System.out.println(p1.toString());<br><br>        p1.show();<br><br>        <span class="hljs-comment">// 在 Person 类外部不可以通过对象调用私有结构</span><br>        <span class="hljs-comment">// 比如 name、showNation() 以及私有构造器</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么使用反射，可以实现相同的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException,<br>            InstantiationException, NoSuchFieldException &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Person.class;<br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> c.getConstructor(String.class, <span class="hljs-type">int</span>.class);<br><br>        <span class="hljs-comment">// 通过反射创建 Person 类的对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">12</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Person) obj;<br>        System.out.println(obj.toString());<br>        System.out.println(p.toString());<br><br>        <span class="hljs-comment">// 访问对象的属性</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);<br>        age.set(p, <span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 调用指定的方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">show</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;show&quot;</span>);<br>        show.invoke(p);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，反射还可以访问私有成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException,<br>            InstantiationException, NoSuchFieldException &#123;<br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-comment">// 调用私有属性</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">showNation</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;showNation&quot;</span>, String.class);<br>        showNation.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">nation</span> <span class="hljs-operator">=</span> (String) showNation.invoke(p1, <span class="hljs-string">&quot;中国&quot;</span>);<br>        System.out.println(nation);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="什么时候用反射"><a href="#什么时候用反射" class="headerlink" title="什么时候用反射"></a>什么时候用反射</h2><p>反射的特征是动态性，当在编译的时候不确定要实例化哪一个类</p><p>反射与面向对象中的封装性是不是矛盾的？如何看待两个技术</p><p>不矛盾。封装性解决的是希望你去调用什么，反射解决的是能不能调</p><h2 id="对于-java-lang-Class-类的理解"><a href="#对于-java-lang-Class-类的理解" class="headerlink" title="对于 java.lang.Class 类的理解"></a>对于 <code>java.lang.Class</code> 类的理解</h2><p>首先，源代码经过 <code>javac.exe</code> 命令编译后会生成一个或多个字节码文件 <code>.java</code> 文件</p><p>类的加载过程</p><p>使用 <code>java.exe</code> 对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中</p><p>加载到内存中的类，我们就称为运行时类，此运行时类就成为 Class 的一个实例</p><p>换句话说，Class 的实例就对应一个运行时类</p><p>加载到内存中的运行时类，会缓存一定的时间，在此时间之内，可以通过不同的方式获取此运行时类</p><h2 id="获取-Class-实例的方式"><a href="#获取-Class-实例的方式" class="headerlink" title="获取 Class 实例的方式"></a>获取 Class 实例的方式</h2><ul><li>调用运行时类的属性 <code>.class</code><br><code>Class c = Person.class;</code></li><li>通过运行时类的对象，调用 <code>getClass()</code><br><code>Person p = new Person();</code><br><code>Class c = p.getClass();</code></li><li>调用 Class 的静态方法：<code>forName(String classPath)</code><br><code>Class.forName(&quot;path.to.your.class&quot;);</code></li><li>使用类的加载器 <code>ClassLoader</code>（使用较少）<br><code>ClassLoader classLoader = ReflectionTest.class.getClassLoader(); Class c4 = classLoader.loadClass(&quot;Person&quot;);</code></li></ul><h2 id="Class-实例对应结构"><a href="#Class-实例对应结构" class="headerlink" title="Class 实例对应结构"></a>Class 实例对应结构</h2><p>哪些类型可以有 Class 对象</p><ul><li><code>class</code>：外部类、成员、局部内部类、匿名内部类</li><li><code>interface</code>：接口</li><li><code>[]</code>：数组</li><li><code>enum</code>：枚举</li><li><code>annoation</code>：注解</li><li><code>primitive type</code>：基本数据类型</li><li><code>void</code></li></ul><p>只要数组的元素类型与维度一样，就是同一个 Class</p><h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a><code>ClassLoader</code></h2><h3 id="使用-ClassLoader-加载配置文件"><a href="#使用-ClassLoader-加载配置文件" class="headerlink" title="使用 ClassLoader 加载配置文件"></a>使用 <code>ClassLoader</code> 加载配置文件</h3><p>可以用 ClassLoader 来加载静态配置文件，配置文件的默认路径为当前 module 的 src 下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ClassLoaderTest.class.getClassLoader();<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> classLoader.getResourceAsStream(<span class="hljs-string">&quot;jdbc.properties&quot;</span>);<br>        props.load(in);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewInstanceTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Person.class;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> c.newInstance();  <span class="hljs-comment">// 创建对应的运行时类的对象，调用空参构造器</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Person) instance;<br>        System.out.println(p);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>newInstance 方法要求</p><ul><li>运行时类必须提供空参构造器</li><li>空参构造器的访问权限一般是 public</li></ul><p>在 JavaBean 中要求提供一个 public 的空参构造器，原因：</p><ul><li>便于通过反射创建运行时类的对象</li><li>便于子类继承此运行时类时，默认调用 super 时，保证父类有此构造器</li></ul><h2 id="获取运行时类的结构"><a href="#获取运行时类的结构" class="headerlink" title="获取运行时类的结构"></a>获取运行时类的结构</h2><h3 id="获取运行时类的属性结构"><a href="#获取运行时类的属性结构" class="headerlink" title="获取运行时类的属性结构"></a>获取运行时类的属性结构</h3><p><code>getFields()</code>：获取当前运行时类及其父类中声明为 <code>public</code> 访问权限的属性，返回 <code>Field</code> 数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Field[] fields = cls.getFields();<br><span class="hljs-keyword">for</span> (Field f : fields) &#123;<br>    System.out.println(f);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getDeclaredFields()</code>：获取当前运行时类中声明的所有属性（不包含父类中声明的属性），返回 <code>Field</code> 数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Field[] fields = cls.getDeclaredFields();<br><span class="hljs-keyword">for</span> (Field f : fields) &#123;<br>    System.out.println(f);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Field-类的方法"><a href="#Field-类的方法" class="headerlink" title="Field 类的方法"></a><code>Field</code> 类的方法</h3><ul><li><code>getModifiers()</code>：获得权限修饰符，返回 int 值，public（1），private（2），protected（0）</li><li><code>getType()</code>：获得数据类型，返回类型 <code>Class</code></li><li><code>getName()</code>：获得属性名，返回类型 <code>String</code></li></ul><h3 id="获取运行时类的方法结构"><a href="#获取运行时类的方法结构" class="headerlink" title="获取运行时类的方法结构"></a>获取运行时类的方法结构</h3><p><code>getMethods()</code>：获取当前运行时类及其所有父类中声明为 <code>public</code> 权限的方法，返回 Method 数组</p><p><code>getDeclaredMethods()</code>：获取当前运行时类中所有的方法，返回 <code>Method</code> 数组</p><h3 id="Method-类的方法"><a href="#Method-类的方法" class="headerlink" title="Method 类的方法"></a><code>Method</code> 类的方法</h3><ul><li><code>getAnnotations()</code>：获取方法声明的注解，返回值类型 <code>Annotation</code> 数组</li><li><code>getModifiers()</code>：获得权限修饰符，返回 <code>int</code> 值，public（1），private（2），protected（0）</li><li><code>getReturnType()</code>：获得返回值类型，返回类型 <code>Class</code></li><li><code>getName()</code>：获得方法名，返回类型 <code>String</code></li><li><code>getParameterTypes()</code>：获取参数类型，返回 <code>Class</code> 数组</li><li><code>getExceptionTypes()</code>：获取抛出异常的类型，返回 <code>Class</code> 数组</li></ul><h3 id="获取运行时类的构造器结构"><a href="#获取运行时类的构造器结构" class="headerlink" title="获取运行时类的构造器结构"></a>获取运行时类的构造器结构</h3><p><code>getConstructors()</code>：获取<strong>当前运行时类</strong>中声明为 <code>public</code> 的构造函数，返回 <code>Constructor</code> 数组</p><p><code>getDeclaredConstructors()</code>：获取当前运行时类中声明的所有构造器</p><h3 id="获取运行时类的父类及父类的泛型"><a href="#获取运行时类的父类及父类的泛型" class="headerlink" title="获取运行时类的父类及父类的泛型"></a>获取运行时类的父类及父类的泛型</h3><p><code>getSuperclass()</code>：获取当前运行时类的父类，返回 <code>Class</code></p><p><code>getGenericSuperclass()</code>：获取运行时类带泛型的父类，返回 <code>Type</code></p><h3 id="获取运行时类的接口、所在包、注解等"><a href="#获取运行时类的接口、所在包、注解等" class="headerlink" title="获取运行时类的接口、所在包、注解等"></a>获取运行时类的接口、所在包、注解等</h3><p><code>getInterface()</code>：返回运行时类实现的接口（不包含父类实现的接口），返回 <code>Class</code> 数组</p><p><code>getPackage()</code>：获取运行时类所在的包，返回 <code>Package</code></p><p><code>getAnnotations()</code>：获取运行时类的注解，返回 <code>Annotation</code> 数组</p><h2 id="调用运行时类的指定结构"><a href="#调用运行时类的指定结构" class="headerlink" title="调用运行时类的指定结构"></a>调用运行时类的指定结构</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><code>getField(String name)</code>：获取运行时类中指定的属性，要求属性声明为 <code>public</code>，返回 <code>Field</code>，通常不采用这种方式</p><p><code>getDeclaredField(String name)</code>：获取运行时类中指定的属性，返回 <code>Field</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Person.class;<br><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Person) cls.newInstance();<br><span class="hljs-type">Field</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> cls.getField(<span class="hljs-string">&quot;id&quot;</span>);<br>id.set(p, <span class="hljs-number">101</span>);<br>id.get(p);<br></code></pre></td></tr></table></figure><p><code>Field</code> 的相关方法</p><p><code>set(Object obj, Object value)</code>：参数 1：指明设置哪个对象的属性，参数 2：设置为多少</p><p><code>get(Object obj)</code>：获取哪个对象的属性值，返回 <code>Object</code></p><p><code>setAccessible(boolean b)</code>：设置 <code>Field</code> 的访问权限</p><p>静态属性就是将具体的对象换成类的 <code>class</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">someField.set(SomeClass.class, value);<br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>getDeclaredMethod(String name, Class&lt;?&gt; ...parameterTypes)</code>：参数 1：方法名称，参数 2：形参类型</p><p><code>Method</code> 的相关方法</p><p><code>setAccessible(boolean b)</code>：设置 <code>Method</code> 的访问权限</p><p><code>invoke(Object obj, Object... args)</code>：调用方法，参数 1：方法的调用者，参数 2：给方法形参赋值的实参，返回 <code>Object</code>，返回值为对应类中调用的方法的返回值</p><p>如果调用方法没有返回值，则 <code>invoke</code> 方法返回 <code>null</code></p><p>如果调用静态方法，<code>invoke</code> 函数的第一个参数就是对应的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">someFunc.invoke(SomeClass.class, args);<br><span class="hljs-comment">// or</span><br>someFunc.invoke(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>通常情况下，<code>newInstance()</code> 可以直接调用无参构造器</p><p>要想调用有参构造器，可以使用 <code>Constructor</code> 类的 <code>newInstance(Object... initargs)</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="获取-Class-实例的三种方式"><a href="#获取-Class-实例的三种方式" class="headerlink" title="获取 Class 实例的三种方式"></a>获取 <code>Class</code> 实例的三种方式</h3><p>第四种不常用，所以不说</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> String.class;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Person.getClass();<br><span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;Person&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="对-Class-类的理解"><a href="#对-Class-类的理解" class="headerlink" title="对 Class 类的理解"></a>对 <code>Class</code> 类的理解</h3><p>Class 实例对应着加载到内存中的一个运行时类</p><h3 id="创建-Class-对应运行时类的对象通用方法"><a href="#创建-Class-对应运行时类的对象通用方法" class="headerlink" title="创建 Class 对应运行时类的对象通用方法"></a>创建 Class 对应运行时类的对象通用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cls.newInstance(); <span class="hljs-comment">// 创建对应的运行时类的对象</span><br></code></pre></td></tr></table></figure><p>要求：</p><ul><li>必须有空参构造器</li><li>修饰符的权限要够，通常为 <code>public</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 笔记 - 网络编程</title>
    <link href="/2021/02/22/java-notes-socket-programming/"/>
    <url>/2021/02/22/java-notes-socket-programming/</url>
    
    <content type="html"><![CDATA[<p>Java 笔记 - 网络编程</p><span id="more"></span><p>注意：本文内容涉及到到 <a href="https://blog.mazixiang.me/2021/02/20/java-notes-io-stream/">IO 流</a> 的内容</p><h2 id="网络编程概述"><a href="#网络编程概述" class="headerlink" title="网络编程概述"></a>网络编程概述</h2><p>Java 是 Internet 上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序。</p><p>Java 提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在 Java 的本机安装系统里，由 JVM 进行控制。并且 Java 实现了一个跨平台的网络库，程序员面对的是一个统一的网络编程环境。</p><p>网络编程的目的：直接或间接地通过网络协议与其他计算机实现数据交换，进行通讯</p><h2 id="网络通信要素概述"><a href="#网络通信要素概述" class="headerlink" title="网络通信要素概述"></a>网络通信要素概述</h2><p>如何实现网络中的主机互相通信</p><p>通信双方地址：</p><ul><li>IP</li><li>端口号</li></ul><p>一定的规则</p><ul><li>OSI 参考模型：模型过于理想化，未能在因特网上进行广泛推广</li><li>TCP&#x2F;IP 参考模型：事实上的国际标准</li></ul><p><img src="https://s3.ax1x.com/2021/02/22/yHDZPx.png" alt="网络通信协议"></p><p>网络通信协议</p><h2 id="通信要素-1：IP-和端口号"><a href="#通信要素-1：IP-和端口号" class="headerlink" title="通信要素 1：IP 和端口号"></a>通信要素 1：IP 和端口号</h2><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP 地址类：<code>InetAddress</code></p><ul><li>唯一的表示 <code>Internet</code> 上的计算机</li><li>本地主机地址：<code>127.0.0.1</code>，主机名：<code>localhost</code></li><li>IP 地址分类方式：IPV4 和 IPV6<ul><li>IPV4：4 个字节组成，4 个 0-255。大概 42 亿，30 亿都在北美，亚洲 4 亿。2011 年初已经用尽。以点分十进制表示，如 192.168.1.1</li><li>IPV6：128 位（16 字节），写成 8 个无符号整数，每个整数用四个十六进制位表示，数之间用冒号（:）分开，如：<code>3ffe:3021:1401:1280:c8ff:fe4d:db39:1984</code></li></ul></li><li>IP 地址分类方式 2：公网地址和私有地址。192.168 开头的就是私有地址，范围是 <code>192.168.0.0 - 192.168.255.255</code></li></ul><p><code>InetAddress</code> 不对外暴露构造器，需要用 <code>InetAddress.getByName(&quot;localhost&quot;)</code> 进行实例化</p><p>另外，可以用 <code>InetAddress.getLocalHost()</code> 直接获取本机的本地 IP</p><p>常用方法</p><ul><li><code>getHostName()</code>：获取主机域名</li><li><code>getHostAddress()</code>：获取主机地址</li></ul><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>端口号标识正在计算机上运行的进程（程序）</p><ul><li>不同的进程有不同的端口号</li><li>被规定为一个 16 位的整数 0-65535</li></ul><p>端口分类</p><ul><li>公认端口：0-1023：被预先定义的服务通信占用（如 HTTP 占用端口 80，FTP 占用端口 21，Telnet 占用端口 23 等）</li><li>注册端口：1024-49151：分配给用户进程或应用程序。（如 Tomcat 占用端口 8080，MySQL 占用端口 3306，Oracle 占用端口 1521 等）</li><li>动态&#x2F;私有端口：49152-65535</li></ul><p>端口号与 IP 地址的组合地处一个网络套接字：Socket</p><h2 id="通信要素-2：网络协议"><a href="#通信要素-2：网络协议" class="headerlink" title="通信要素 2：网络协议"></a>通信要素 2：网络协议</h2><h3 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h3><p>计算机网络中实现通信必须有一些约定，即通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准</p><p>问题：网络协议太复杂</p><p>计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩解压缩，差错控制，流量控制，路由控制，如何实现如此复杂的网络协议呢？通信协议分层的思想</p><p>在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展</p><h3 id="TCP-x2F-IP-协议"><a href="#TCP-x2F-IP-协议" class="headerlink" title="TCP&#x2F;IP 协议"></a>TCP&#x2F;IP 协议</h3><p>传输层协议中有两个非常重要的协议</p><p>传输控制协议：TCP，Transmission Control Protocol</p><p>用户数据报协议：UDP，User Datagram Protocol</p><p>TCP&#x2F;IP 以其两个主要协议：传输控制协议和网络互联协议（IP）而得名，实际上是一组协议，包括具有多个不同功能且互为关联的协议</p><p>IP 协议是网络层的主要协议，支持网间互联的数据通信</p><p>TCP&#x2F;IP 协议模型从更实用的角度触发，形成了高效的四层体系结构，及物理链路层、IP 层、传输层和应用层</p><p>TCP 协议</p><ul><li>使用 TCP 协议前，须先建立 TCP 连接，形成传输数据通道</li><li>传输前，采用三次握手方式，点对点通信，是可靠的</li><li>TCP 协议进行通信的两个应用进程：客户端、服务端。</li><li>在连接中可进行大数据量的传输</li><li>传输完毕，需释放已建立的连接，效率低</li></ul><p>UDP 协议</p><ul><li>将数据、源、目的封装成数据包，不需要建立连接</li><li>每个数据报的大小限制在 64K 内</li><li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li><li>可以广播发送</li><li>发送数据结束时无需释放资源，开销小，速度快</li></ul><h2 id="TCP-网络编程"><a href="#TCP-网络编程" class="headerlink" title="TCP 网络编程"></a>TCP 网络编程</h2><p>示例 1：简单的文本传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.InetAddress;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">client</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InetAddress</span> <span class="hljs-variable">addr</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;localhost&quot;</span>);<br>            <span class="hljs-comment">// 创建 Socket 对象，指明服务器 IP 和端口号</span><br>            socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(addr, <span class="hljs-number">10999</span>);<br>            <span class="hljs-comment">// 获取输出流，用于输出数据</span><br>            os = socket.getOutputStream();<br>            <span class="hljs-comment">// 向输出流写数据</span><br>            os.write(<span class="hljs-string">&quot;test&quot;</span>.getBytes());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            close(os);<br>            close(socket);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">server</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建服务器端 ServerSocket，指明自己的端口号</span><br>            socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">10999</span>);<br>            <span class="hljs-comment">// 调用 accept 接收来自客户端的 socket</span><br>            client = socket.accept();<br>            <span class="hljs-comment">// 获取输入流</span><br>            inputStream = client.getInputStream();<br>            <span class="hljs-comment">// 读取输入流中的数据</span><br>            out = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">20</span>];<br>            <span class="hljs-type">int</span> len;<br>            <span class="hljs-keyword">while</span> ((len = inputStream.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>                out.write(buf, <span class="hljs-number">0</span>, len);<br>            &#125;<br>            <span class="hljs-comment">// 操作数据</span><br>            System.out.println(out.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 资源的关闭</span><br>            close(out);<br>            close(inputStream);<br>            close(client);<br>            close(socket);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Closeable closeable)</span> &#123;<br>        <span class="hljs-keyword">if</span> (closeable != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                closeable.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例 2：文件传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileTransmissionServer</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">client</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">socketOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">10021</span>);<br>            socketOutputStream = client.getOutputStream();<br>            fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><br>            <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> len;<br><br>            <span class="hljs-keyword">while</span> ((len = fis.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>                socketOutputStream.write(buf, <span class="hljs-number">0</span>, len);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            close(socketOutputStream);<br>            close(fis);<br>            close(client);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">server</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            serverSocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">10021</span>);<br>            clientSocket = serverSocket.accept();<br>            is = clientSocket.getInputStream();<br>            fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;hello-server.txt&quot;</span>);<br><br>            <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> len;<br>            <span class="hljs-keyword">while</span> ((len = is.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>                fos.write(buf, <span class="hljs-number">0</span>, len);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            close(fos);<br>            close(is);<br>            close(clientSocket);<br>            close(serverSocket);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Closeable closeable)</span> &#123;<br>        <span class="hljs-keyword">if</span> (closeable != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                closeable.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>注意</p><p>某些时候需要使用：<code>socket.shutdownInput()/shutdownOutput()</code> 来显式关闭流</p>          </div><h2 id="UDP-网络编程"><a href="#UDP-网络编程" class="headerlink" title="UDP 网络编程"></a>UDP 网络编程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.Closeable;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.DatagramPacket;<br><span class="hljs-keyword">import</span> java.net.DatagramSocket;<br><span class="hljs-keyword">import</span> java.net.InetAddress;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sender</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-meta">@Test</span><br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;UDP packet&quot;</span>;<br>            <span class="hljs-type">byte</span>[] data = str.getBytes();<br>            <span class="hljs-type">InetAddress</span> <span class="hljs-variable">addr</span> <span class="hljs-operator">=</span> InetAddress.getLocalHost();<br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(data, <span class="hljs-number">0</span>, data.length, addr, <span class="hljs-number">10900</span>);<br><br>            socket.send(packet);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            close(socket);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">10900</span>);<br>            <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf, <span class="hljs-number">0</span>, buf.length);<br><br>            socket.receive(packet);<br><br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(packet.getData(), <span class="hljs-number">0</span>, packet.getLength()));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            close(socket);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Closeable closeable)</span> &#123;<br>        <span class="hljs-keyword">if</span> (closeable != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                closeable.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="URL-编程"><a href="#URL-编程" class="headerlink" title="URL 编程"></a>URL 编程</h2><p>URL 表示因特网上某一资源的地址</p><p>它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何定位这个资源</p><p>通过 URL 我们可以访问因特网上的各种网络资源，比如最常见的网站</p><p>URL 的基本结构由五部分构成</p><p>传输协议:&#x2F;&#x2F;主机名:端口号&#x2F;文件名#片段名?参数列表</p><p>URL 类常用方法</p><ul><li><code>getProtocol()</code>：获取协议名</li><li><code>getHost()</code>：获取主机名</li><li><code>getPort()</code>：获取端口号</li><li><code>getPath()</code>：获取文件路径</li><li><code>getFile()</code>：获取文件名</li><li><code>getQuery()</code>：获取参数</li></ul><p>下载文件示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.Closeable;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.net.HttpURLConnection;<br><span class="hljs-keyword">import</span> java.net.URL;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">URLTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">urlConnection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://example.org/api&quot;</span>);<br>            urlConnection = (HttpURLConnection) url.openConnection();<br>            urlConnection.connect();<br>            is = urlConnection.getInputStream();<br>            fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><br>            <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">100</span>];<br>            <span class="hljs-type">int</span> len;<br><br>            <span class="hljs-keyword">while</span> ((len = is.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>                fos.write(buf, <span class="hljs-number">0</span>, len);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            close(is);<br>            close(fos);<br>            <span class="hljs-keyword">if</span> (urlConnection != <span class="hljs-literal">null</span>) &#123;<br>                urlConnection.disconnect();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Closeable closeable)</span> &#123;<br>        <span class="hljs-keyword">if</span> (closeable != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                closeable.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Socket 编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 笔记 - IO 流</title>
    <link href="/2021/02/20/java-notes-io-stream/"/>
    <url>/2021/02/20/java-notes-io-stream/</url>
    
    <content type="html"><![CDATA[<p>Java 笔记 - IO 流</p><span id="more"></span><h2 id="File-类的使用"><a href="#File-类的使用" class="headerlink" title="File 类的使用"></a>File 类的使用</h2><p><code>File</code> 类的一个对象，代表一个文件或一个文件目录</p><p><code>File</code> 类声明在 <code>java.io</code> 包下</p><p>File 类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入过读取文件内容的操作。如果需要读取或写入文件内容，必须使用 IO 流来完成</p><p>后续 File 类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点”</p><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ul><li><code>File(String filePath)</code></li><li><code>File(String parentPath, String childPath)</code></li><li><code>File(File parentFile, String childPath)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/home/user/hello.txt&quot;</span>);<br></code></pre></td></tr></table></figure><p>路径中的每级目录用一个路径分隔符隔开</p><p>路径分隔符和系统有关：</p><ul><li>Windows 和 DOS 系统默认用 \ 来表示</li><li>UNIX 和 URL 用 &#x2F; 表示</li></ul><p>Java 程序支持跨平台运行，因此路径分隔符要慎用</p><p>为了解决这个隐患，File 类提供了一个常量 <code>separator</code>。根据操作系统，动态提供分隔符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:&quot;</span> + File.separator + <span class="hljs-string">&quot;foo&quot;</span> + File.separator + <span class="hljs-string">&quot;bar&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><p>获取功能</p><ul><li><code>getAbsolutePath()</code>：获取绝对路径</li><li><code>getPath()</code>：获取路径</li><li><code>getName()</code>：获取名称</li><li><code>getParent()</code>：获取上层文件目录路径，若无，返回 null</li><li><code>length()</code>：获取文件长度，不能获取目录长度</li><li><code>lastModified()</code>：获取最后一次修改时间</li><li>适用于文件目录<ul><li><code>list()</code>：获取指定目录下的所有文件或者文件目录的名称数组</li><li><code>listFiles()</code>：获取指定目录下的所有文件或者文件目录的 File 数组</li></ul></li></ul></li><li><p>重命名功能</p><ul><li><p><code>renameTo(File dest)</code>：把文件重命名为指定的文件路径</p><p>要想保证返回 <code>true</code>，需要 file1 在硬盘中存在的，且 file2 不能在硬盘中存在</p></li></ul></li><li><p>判断功能</p><ul><li><code>isDirectory()</code>：判断是否是文件目录</li><li><code>isFile()</code>：判断是否是文件</li><li><code>exists()</code>：判断是否存在</li><li><code>canRead()</code>：判断是否可读</li><li><code>canWrite()</code>：判断是否可写</li><li><code>isHidden()</code>：判断是否隐藏</li></ul></li><li><p>创建功能</p><ul><li><p><code>createNewFile()</code>：创建文件。若文件存在，则不创建，返回 false</p></li><li><p><code>mkdir()</code>：创建文件目录。若此文件目录存在或此文件目录的上层目录不存在，就不创建</p></li><li><p><code>mkdirs()</code>：创建文件目录。如果上层文件目录不存在，一并创建</p><p>如果创建文件或文件目录没有写绝对路径，默认在项目的路径下</p></li></ul></li><li><p>删除功能</p><ul><li><p><code>delete()</code>：删除文件或文件夹</p><p>删除文件不走回收站</p><p>要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录</p></li></ul></li></ul><h2 id="IO-流原理及流的分类"><a href="#IO-流原理及流的分类" class="headerlink" title="IO 流原理及流的分类"></a>IO 流原理及流的分类</h2><p><code>I/O</code> 是 <code>Input/Output</code> 的缩写，I&#x2F;O 技术是非常实用的技术，用于处理设备之间的数据传输。如读写文件、网络通讯等</p><p>Java 程序中，对于数据的输入输出操作以流的方式进行</p><p><code>java.io</code> 包下提供了各种流类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据</p><h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><ul><li>按操作数据单位不同分为：字节流（1Byte &#x3D; 8bit）、字符流（1char &#x3D; 16bit）</li><li>按数据流的流向不同分为：输入流、输出流</li><li>按流的角色不同分为：节点流（作用在节点）、处理流（作用在已有流基础上）</li></ul><p>Java 的 IO 流共涉及 40 多个类，实际上非常规则，都是从如下四个抽象基类派生的</p><ul><li>输入字节流：<code>InputStream</code></li><li>输出字节流：<code>OutputStream</code></li><li>输入字符流：<code>Reader</code></li><li>输出字符流：<code>Writer</code></li></ul><p>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</p><p><img src="https://s3.ax1x.com/2021/02/20/y5fF5n.png" alt="IO 流体系"></p><p>IO 流体系</p><div class="note note-warning">            <p><strong>注意</strong></p><p>不能用字符流来处理图片等字节数据</p>          </div><h2 id="节点流（或文件流）"><a href="#节点流（或文件流）" class="headerlink" title="节点流（或文件流）"></a>节点流（或文件流）</h2><h3 id="FileReader-读取数据的操作"><a href="#FileReader-读取数据的操作" class="headerlink" title="FileReader 读取数据的操作"></a>FileReader 读取数据的操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1 指明操作的文件</span><br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Hello.txt&quot;</span>);<br><span class="hljs-comment">// 2 提供具体的流</span><br><span class="hljs-type">FileReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(file);<br><span class="hljs-comment">// 3 数据的读入</span><br><span class="hljs-comment">// read()：返回读入的一个字符。如果到达文件末尾，返回 -1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> reader.read();<br><span class="hljs-keyword">while</span>(data != -<span class="hljs-number">1</span>) &#123;<br>    System.out.println((<span class="hljs-type">char</span>) data);<br>    data = reader.read();<br>&#125;<br><span class="hljs-comment">// 4 流的关闭</span><br><span class="hljs-comment">// 关闭的重要性参见垃圾回收机制</span><br>reader.close();<br></code></pre></td></tr></table></figure><p>另外一种写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> data;<br><span class="hljs-keyword">while</span> ((data = reader.read()) != -<span class="hljs-number">1</span>) &#123;<br>    System.out.println((<span class="hljs-type">char</span>) data);<br>&#125;<br></code></pre></td></tr></table></figure><p>不建议用 <code>throws</code> 处理异常，因为流可能不会关闭，建议用 <code>try...catch...finally</code> 进行处理</p><p>读入的文件一定要存在，否则就会报 FileNotFoundException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 1 指明操作的文件</span><br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Hello.txt&quot;</span>);<br>    <span class="hljs-comment">// 2 提供具体的流</span><br>    reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(file);<br>    <span class="hljs-comment">// 3 数据的读入</span><br>    <span class="hljs-comment">// read()：返回读入的一个字符。如果到达文件末尾，返回 -1</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">while</span> ((data = reader.read()) != -<span class="hljs-number">1</span>) &#123;<br>        System.out.println((<span class="hljs-type">char</span>) data);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 4 流的关闭</span><br>        <span class="hljs-comment">// 关闭的重要性参见垃圾回收机制</span><br>        <span class="hljs-keyword">if</span> (reader != <span class="hljs-literal">null</span>) &#123;<br>            reader.close();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个 <code>read(char[] chars)</code> 的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// read(char[] chars)：返回每次读入的个数，如果达到文件末尾，返回 -1</span><br><span class="hljs-type">char</span>[] chs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span> ((len = reader.read(chs)) != -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">/*for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="hljs-comment">        System.out.println(chs[i]);</span><br><span class="hljs-comment">    &#125;*/</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chs, <span class="hljs-number">0</span>, len));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FileWriter-写出数据的操作"><a href="#FileWriter-写出数据的操作" class="headerlink" title="FileWriter 写出数据的操作"></a>FileWriter 写出数据的操作</h3><p>说明：</p><ol><li><p>输出操作，对应的 File 可以不存在。如果不存在，在输出的过程中，会自动创建此文件。</p></li><li><p>如果硬盘中的文件存在：</p><p>如果流使用的构造器是：FileWriter(file, false) &#x2F; FileWriter(file)：对原有文件覆盖</p><p>如果流使用的构造器是：FileWriter(file, true)：不会对原有文件覆盖，而是在原有文件基础上追加内容</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1 指明到写出类的文件</span><br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><span class="hljs-comment">// 2 提供 FileWriter 的对象，用于数据的写出</span><br><span class="hljs-type">FileWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(file);<br><span class="hljs-comment">// 3 写出操作</span><br>writer.write(<span class="hljs-string">&quot;I have a dream!&quot;</span>);<br><span class="hljs-comment">// 4 流资源的关闭</span><br>writer.close();<br></code></pre></td></tr></table></figure><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>对于文本文件（txt、java、c、cpp），使用字符流处理</p><p>对于非文本文件（jpg、mp4、mp3），使用字节流处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br><br><span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> len;<br><br><span class="hljs-keyword">while</span> ((len = in.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, <span class="hljs-number">0</span>, len);<br>    System.out.println(str);<br>&#125;<br><br>in.close();<br></code></pre></td></tr></table></figure><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>处理流之一：缓冲流</p><ul><li><code>BufferedInputStream</code></li><li><code>BufferedOutputStream</code></li><li><code>BufferedReader</code></li><li><code>BufferedWriter</code></li></ul><p>作用：提供流的读取、写入的速度</p><p>提高读写速度的原因：内部提供了一个缓冲区，在传输过程中不断刷新缓冲区（<code>BufferedInputStream</code> 里的 <code>flush</code> 方法）</p><p><code>BufferedReader</code> 添加了一个 <code>readLine</code> 方法，剩下差不多都相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 1 造文件</span><br>    <span class="hljs-type">File</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br>    <span class="hljs-type">File</span> <span class="hljs-variable">dest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;hello1.txt&quot;</span>);<br><br>    <span class="hljs-comment">// 2 造流</span><br>    in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src);<br>    out = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dest);<br><br>    bin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(in);<br>    bout = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(out);<br><br>    <span class="hljs-comment">// 3 读取和写入</span><br>    <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-keyword">while</span> ((len = bin.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>        bout.write(buf, <span class="hljs-number">0</span>, len);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 4 资源关闭</span><br>    <span class="hljs-comment">// 要求：先关闭外层的流，再关闭内层的流</span><br>    <span class="hljs-comment">// 关闭外层流的同时，内层流也会自动地进行关闭</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (bin != <span class="hljs-literal">null</span>) &#123;<br>            bin.close();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (bout != <span class="hljs-literal">null</span>) &#123;<br>            bout.close();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>转换流提供了在字节流和字符流之间的转换</p><p>JavaAPI 提供了两个转换流</p><ul><li><code>InputStreamReader</code>：将 <code>InputStream</code> 转换为 <code>Reader</code></li><li><code>OutputStreamReader</code>：将 <code>Writer</code> 转换为 <code>OutputStream</code></li></ul><p>字节流中的数据都是字符时，转成字符流操作更高效</p><p>很多时候使用转换流来处理文件乱码的问题，实现编码和解码的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><span class="hljs-comment">// 参数 2 指明了字符集，取决于文件保存时使用的字符集</span><br><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(in, StandardCharsets.UTF_8);<br><br><span class="hljs-type">char</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span> ((len = reader.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span>, len);<br>    System.out.println(str);<br>&#125;<br><br>reader.close();<br></code></pre></td></tr></table></figure><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p><code>ASCII</code>：美国标准信息交换码，用一个字节的 7 位可以表示</p><p><code>ISO8859-1</code>：拉丁码表。欧洲码表。用一个字节的 8 位表示</p><p><code>GB2312</code>：中国的中文编码表。最多两个字节编码所有字符</p><p><code>GBK</code>：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</p><p><code>Unicode</code>：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的字符都用两个字节表示</p><p><code>UTF-8</code>：变长的编码方式，可用 1-4 字节表示一个字符（修正后是 1-6）</p><p><code>UCS Transfer Format</code>，面向传输的众多标准出现了，<code>UTF-8</code> 就是每次 8 个位传输数据，<code>UTF-16</code> 就是每次 16 个位。这是为传输而涉及的编码，并使编码无国界，这样就可以现实全世界上所有文化的字符了</p><p><img src="https://s3.ax1x.com/2021/02/20/y5W1c8.png" alt="unicode 和 utf-8 编码"></p><p>字符编码</p><p><code>ANSI</code> 编码，通常指的是平台的默认编码，例如英文的操作系统中是 <code>ISO-8859-1</code>，中文系统是 <code>GBK</code></p><p><code>Unicode</code> 字符集只定义字符的集合和唯一编号，<code>Unicode</code> 编码则是对 <code>UTF-8</code>、<code>UCS-2</code>&#x2F;<code>UTF-16</code> 等具体编码方案的统称，并不是具体的编码方案</p><h2 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h2><p><code>System.in</code> 和 <code>System.out</code> 分别代表了系统的标准输入和输出设备</p><p>默认输入设备是键盘，默认输出设备是控制台</p><p><code>System.in</code> 的类型是 <code>InputStream</code></p><p><code>System.out</code> 的类型是 <code>PrintStream</code>，是 <code>OutputStream</code> 的子类</p><p>重定向：通过 <code>System</code> 类的 <code>setIn</code> 和 <code>setOut</code> 方法重新指定输入和输出的流</p><ul><li><code>public static void setIn(InputStream in)</code></li><li><code>public static void setOut(PrintStream out)</code></li></ul><p>示例代码：从键盘输入字符串，要求将读到的整行字符串转换成大写进行输出。然后继续进行输入操作，直到输入 “e” 或 “E” 退出程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in);<br>    br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<br>    br.readLine();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> br.readLine();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;e&quot;</span>.equals(data) || <span class="hljs-string">&quot;E&quot;</span>.equals(data)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;End&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        System.out.println(data.toUpperCase(Locale.ROOT));<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (br != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            br.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>打印流：<code>PrintStream</code> 和 <code>PrintWriter</code></p><ul><li>提供了一系列重载的 <code>print</code> 和 <code>println</code> 方法，用于多种数据类型的输出</li><li><code>PrintStream</code> 和 <code>PrintWriter</code> 的输出不会抛出 <code>IOException</code> 异常</li><li><code>PrintStream</code> 和 <code>PrintWriter</code> 有自动 <code>flush</code> 的功能</li><li><code>PrintStream</code> 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下应使用 <code>PrintWriter</code> 类</li><li><code>System.out</code> 返回的是 <code>PrintStream</code> 的实例</li></ul><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>为了方便地读写 <code>Java</code> 中基本数据类型和 <code>String</code> 类型的数据，可以使用数据流。</p><p>数据流：<code>DataInputStream</code> 和 <code>DataOutputStream</code>，分别套在 <code>InputStream</code> 和 <code>OutputStream</code> 子类的流上</p><p><code>DataInputStream</code> 中的方法</p><ul><li><code>readBoolean()</code></li><li><code>readChar()</code></li><li><code>readDouble()</code></li><li><code>readLong()</code></li><li><code>readUTF()</code></li><li><code>readByte()</code></li><li><code>readFloat()</code></li><li><code>readInt()</code></li><li><code>readFully(byte[] b)</code></li></ul><p><code>DataOutputStream</code> 中的方法将上述方法的 <code>read</code> 改为相应的 <code>write</code> 即可</p><h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>对象流：<code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code></p><p>用于存储基本数据类型数据或对象的处理流。它的强大之处是可以将 <code>Java</code> 中的对象写入到数据流中，也能把对象从数据源中还原回来</p><p>序列化：用 <code>ObjectOutputStream</code> 类保存基本数据类型或对象的机制</p><p>反序列化：用 <code>ObjectOutputStream</code> 类读取基本数据类型或对象的机制</p><p><code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> 不能序列化 <code>static</code> 和 <code>transient</code> 修饰的成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>));<br>    oos.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br>    oos.flush();<span class="hljs-comment">// 刷新操作</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (oos != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            oos.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h3><ul><li>对象序列化机制允许把内存中的 <code>Java</code> 对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。<br>当其他程序获取了这种二进制流，就可以恢复成原来的 <code>Java</code> 对象</li><li>序列化的好处在于可将任何实现了 <code>Serializable</code> 接口的对象转化为字节数据，使其在保存和传输时可被还原</li><li>序列化是 <code>RMI</code>（Remote Method Invoke - 远程方法调用）过程的参数和返回值都必须实现的机制，而 <code>RMI</code> 是 <code>JavaEE</code> 的基础。因此序列化机制是 JavaEE 平台的基础</li><li>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出 <code>NotSerializableException</code> 异常<ul><li><code>Serializable</code></li><li><code>Externalizable</code></li></ul></li><li>凡是实现 <code>Serializable</code> 接口的类都有一个表示序列化版本标识符的静态变量<ul><li><code>public static final long serialVersionUID</code></li><li><code>serialVersionUID</code> 用来表明类的不同版本的兼容性。简而言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容</li><li>如果类没有显式定义这个静态常量，他的值是由 Java 运行时环境根据类的内部希捷自动生成的。若类的实例变量做了修改，<code>serialVersionUID</code> 可能发生变化，建议显式声明</li></ul></li><li>Java 的序列化机制是通过运行时判断类的 <code>serialVersionUID</code> 来验证版本的一致性的。在进行反序列化时，JVM 会把传来的字节流中的 <code>serialVersionUID</code> 与本地相应实体类的 <code>serialVersionUID</code> 进行比较，如果相同就认为是一致的，否则就会抛出序列化版本不一致的异常 <code>InvalidCastException</code></li></ul><h3 id="自定义类的序列化和反序列化"><a href="#自定义类的序列化和反序列化" class="headerlink" title="自定义类的序列化和反序列化"></a>自定义类的序列化和反序列化</h3><p><code>Person</code> 要满足如下要求才可以序列化</p><ul><li>实现接口 <code>Serializable</code></li><li>当前类提供一个全局常量 <code>serialVersionUID</code>，值可以随便设置</li><li>除了当前 <code>Person</code> 类需要实现 <code>Serializable</code> 接口外，还必须保证其内部所有属性都是可序列化的</li><li>默认情况下，基本数据类型可以序列化</li><li>默认情况下，<code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> 不能序列化 <code>static</code> 和 <code>transient</code> 修饰的成员变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-comment">// Serializable 接口只是一个标识</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">2121L</span>;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="随机存取文件流"><a href="#随机存取文件流" class="headerlink" title="随机存取文件流"></a>随机存取文件流</h2><p><code>RandomAccessFile</code> 类</p><ul><li><code>RandomAccessFile</code> 类声明在 <code>java.io</code> 包下，直接继承于 <code>Object</code> 类。并且它实现了 <code>DataInput</code>、<code>DataOutput</code> 这两个接口，也就意味着这个类既可以读又可以写</li><li><code>RandomAccessFile</code> 类支持随机访问的方式，程序可以直接跳到文件的任意地方读写文件<ul><li>支持只访问文件的部分内容</li><li>可以向已经存在的文件后追加内容</li></ul></li><li><code>RandomAccessFile</code> 对象包含一个记录指针，用以标示当前读写处的位置。<code>RandomAccessFile</code> 类对象可以自由移动记录指针<ul><li><code>long getFilePointer()</code>：获取文件记录指针的当前位置</li><li><code>void seek(long pos)</code>：将文件记录指针定位到 pos 位置</li></ul></li></ul><p><code>RandomAccessFile</code> 作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建，如果写出到的文件存在，则会对原有的文件内容进行覆盖。默认情况下从头覆盖</p><p>可以用 <code>RandomAccessFile</code> 类来实现多线程断点下载的功能</p><h2 id="NIO-中类的使用"><a href="#NIO-中类的使用" class="headerlink" title="NIO 中类的使用"></a>NIO 中类的使用</h2><p>NIO（New IO，Non-Blockinbg IO） 是 Java 1.4 版本开始引入的一套新的 IO API，可以替代标准的 IO API。NIO 与原来的 IO 具有同样的作用和目的，但是使用方式是完全不同的，NIO 是面向缓冲区的（IO 是面向流的）、基于通道的 IO 操作，NIO 将以更加高效的方式进行文件的读写操作</p><p>Java API 中提供了两套 NIO，一套是针对标准输入输出 NIO，另一套是网络编程 NIO</p><p>JDK 7 发布的 NIO2 对 NIO 进行了极大的扩展，增强了对文件处理和文件系统特性的支持</p><h3 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h3><p>早期的 Java 只提供了一个 File 类来访问文件系统，但 File 类的功能比较有限，所提供的方法性能也不高。而且大多数方法出错时并不提供具体异常信息</p><p>NIO2 为了弥补这种不足，引入了 Path 接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path 可以看成是 File 类的升级版本，实际引用的资源可以不存在</p><p>Path 常用方法：</p><ul><li><code>String toString()</code>：返回调用 Path 对象的字符串表示形式</li><li><code>boolean startsWith(String path)</code>：判断是否以 path 路径开始</li><li><code>boolean endsWith(String path)</code>：判断是否以 path 路径结束</li><li><code>boolean isAbsolute())</code>：判断是否是绝对路径</li><li><code>Path getParent()</code>：返回 Path 对象包含整个路径,不包含 Path 对象指定的文件路径</li><li><code>Path getRoot()</code>：返回调用 Path 对象的根路径</li><li><code>Path getFileName()</code>：返回与调用 Path 对象关联的文件名</li><li><code>int getNameCount()</code>：返回 Path 根目录后面元素的数量</li><li><code>Path getName(int idx)</code>：返回指定索引位置 idx 的路径名称</li><li><code>Path toAbsolutePath()</code>：作为绝对路径返回调用 Path 对象</li><li><code>Path resolve(Path p)</code>：合并两个路径,返回合并后的路径对应的 Path 对象</li><li><code>File toFile()</code>：将 Path 转化为 File 类的对象</li></ul><h2 id="使用第三方-jar-包操作文件"><a href="#使用第三方-jar-包操作文件" class="headerlink" title="使用第三方 jar 包操作文件"></a>使用第三方 jar 包操作文件</h2><p><code>apache.commons.io</code></p><h2 id="涉及垃圾回收的说明"><a href="#涉及垃圾回收的说明" class="headerlink" title="涉及垃圾回收的说明"></a>涉及垃圾回收的说明</h2><p>垃圾回收机制关键点：</p><ul><li>垃圾回收机制只回收 JVM 堆内存里的对象空间。</li><li>对其他物理连接，比如数据库连接、输入流输出流、Socket 连接无能为力</li><li>现在的 JVM 有多种垃圾回收实现算法，表现各异</li><li>垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行</li><li>可以将对象的引用变量设置为 null，暗示垃圾回收机制可以回收该对象</li><li>程序员可以通过 <code>System.gc()</code> 或者 <code>Runtime.getRuntime().gc()</code> 来通知系统进行垃圾回收，会有些效果，但是系统是否进行垃圾回收依然不确定</li><li>垃圾回收机制回收任何对象之前，总会先调用它的 <code>finalize</code> 方法（如果覆盖该方法，让一个新的引用变量重新引用该对象，则会重新激活对象）</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>IO 流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进入 Docker 容器的方法</title>
    <link href="/2021/02/19/methods-to-enter-docker-container/"/>
    <url>/2021/02/19/methods-to-enter-docker-container/</url>
    
    <content type="html"><![CDATA[<p>简单介绍进入 Docker 容器的方法</p><span id="more"></span><p>在创建容器时，使用 <code>-d</code> 参数，容器会在后台启动。如果想和容器进行交互，就要进入容器。</p><p>进入容器有 <code>docker attach</code> 和 <code>docker exec</code> 两种方式，更推荐后者</p><h2 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h2><p>假设某一容器名为 <code>container</code>，可以通过如下方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker attach container<br>root@&lt;container-id&gt;:/<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p><strong>注意</strong></p><p>如果从这个 stdin 中退出（比如执行 exit 命令），会使容器停止运行</p>          </div><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>假设某一容器名为 <code>container</code>，可以通过如下方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> -it container<br>root@&lt;container-id&gt;:/<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p><code>-i</code> 参数表示我们与这个容器进行交互，由于没有分配伪终端，界面没有提示符，但是命令执行结果仍然可以返回</p><p><code>-t</code> 是为我们分配了一个伪终端</p><p><code>-i</code> <code>-t</code> 一起使用时，就可以看到命令提示符了</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yeasy.gitbook.io/docker_practice/container/attach_exec">进入容器 - Docker —— 从入门到实践</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 笔记 - 泛型</title>
    <link href="/2021/02/19/java-notes-generic/"/>
    <url>/2021/02/19/java-notes-generic/</url>
    
    <content type="html"><![CDATA[<p>Java 笔记 - 泛型</p><span id="more"></span><h2 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h2><p>泛型允许在定义类、接口时通过一个标识标识类中某个属性的类型或某个方法的返回时及参数类型，这个类型参数将在使用时（继承或实现这个接口，用这个类型声明变量、创建对象时）确定（传入实际类型的参数，也称为类型实参</p><h2 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h2><h3 id="在集合中使用泛型"><a href="#在集合中使用泛型" class="headerlink" title="在集合中使用泛型"></a>在集合中使用泛型</h3><ul><li>集合几口或集合类在 JDK5 时都修改为泛型的结构</li><li>在实例化集合类时，可以指明具体的泛型类型</li><li>指明完以后，在集合或接口中凡是定义类或接口时，内部结构使用到类的泛型的位置，都指定为实例化时泛型类型。</li><li>注意泛型的类型必须时类，不能是基本数据类型，需要用到基本数据类型的位置需要拿包装类</li><li>如果实例化时没指明泛型的类型，默认类型为 <code>java.lang.Object</code> 类型</li></ul><p>如果定义的类是有泛型的，建议在实例化时指明类的泛型</p><h3 id="自定义泛型结构举例"><a href="#自定义泛型结构举例" class="headerlink" title="自定义泛型结构举例"></a>自定义泛型结构举例</h3><p>泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span>&lt;T&gt; &#123;<br>    String orderName;<br>    <span class="hljs-type">int</span> orderId;<br><br>    T orderT;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Order</span><span class="hljs-params">(String orderName, <span class="hljs-type">int</span> orderId, T orderT)</span> &#123;<br>        <span class="hljs-built_in">this</span>.orderName = orderName;<br>        <span class="hljs-built_in">this</span>.orderId = orderId;<br>        <span class="hljs-built_in">this</span>.orderT = orderT;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getOrderT</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> orderT;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOrderT</span><span class="hljs-params">(T orderT)</span> &#123;<br>        <span class="hljs-built_in">this</span>.orderT = orderT;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubOrder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Order</span>&lt;Integer&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p><strong>注意</strong></p><p>子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不需要再指定泛型</p>          </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SubOrder&lt;T&gt; 仍然时泛型类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubOrder</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Order</span>&lt;T&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>泛型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span>&lt;T&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系</p><p>泛型方法可以声明为静态。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型使用注意事项"><a href="#泛型使用注意事项" class="headerlink" title="泛型使用注意事项"></a>泛型使用注意事项</h3><ol><li>泛型类可能有多个参数,此时应将多个参数一起放在尖括号内。比如 <code>&lt;E1, E2, E3&gt;</code></li><li>泛型类的构造器如下: <code>public Generic class()&#123;&#125;</code>，而下面是错误的: <code>public Generic Class&lt;E&gt;()&#123;&#125;</code></li><li>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。</li><li>泛型不同的引用不能相互赋值。<br>尽管在编译时 <code>ArrayList&lt;String&gt;</code> 和 <code>ArrayList&lt;Integer&gt;</code> 是两种类型,但是,在运行时只有<br>一个 <code>ArrayList</code> 被加载到 JVM 中</li><li>泛型如果不指定，将被擦除，泛型对应的类型均按照 <code>Object</code> 处理，但不等价于 <code>Object</code>。<br>经验：泛型要使用一路都用。要不用，一路都不要用。</li><li>如果泛型类是一个接口或抽象类，则不可创建泛型类的对象。</li><li>jdk1.7 中泛型的简化操作：<code>ArrayList&lt;Frut&gt; list = new ArrayList&lt;&gt;();</code></li><li>泛型的指定中不能使用基木数据类型，可以使用包装类替换。</li><li>在类接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。</li><li>异常类不能是泛型的</li><li>不能使用 <code>new E[]</code>。但是可以：<code>E[] elements = (E[]) new Object[capacity]</code><br>参考：<code>ArrayList</code> 源码中声明：<code>Object[] elementData</code>，而非泛型参数类型数组。</li><li>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：<br>子类不保留父类的泛型：按需实现<br>没有类型 擦除<br>具体类型<br>子类保留父类的泛型：泛型子类<br>全部保留<br>部分保留<br>结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型</li></ol><h2 id="泛型方法使用的情境"><a href="#泛型方法使用的情境" class="headerlink" title="泛型方法使用的情境"></a>泛型方法使用的情境</h2><p>Data Access Object 对特定数据类型增删改查方法的实现</p><h2 id="泛型在继承方面的体现"><a href="#泛型在继承方面的体现" class="headerlink" title="泛型在继承方面的体现"></a>泛型在继承方面的体现</h2><p>虽然类 <code>A</code> 是 类 <code>B</code> 的父类，<code>G&lt;A&gt;</code> 和 <code>G&lt;B&gt;</code> 二者不具备子父类关系</p><p>补充：类 <code>A</code> 是类 <code>B</code> 的父类，则 <code>A&lt;G&gt;</code> 是 <code>B&lt;G&gt;</code> 的父类</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><h3 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h3><p>通配符：<code>?</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Object&gt; list1 = <span class="hljs-literal">null</span>;<br>List&lt;String&gt; list2 = <span class="hljs-literal">null</span>;<br><br>List&lt;?&gt; list = <span class="hljs-literal">null</span>;<br>list = list1;<br>list = list2;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(List&lt;?&gt; list)</span> &#123;<br>    Iterator&lt;?&gt; it = list.iterator();<br>    <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> it.next();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用通配符后的数据读取和写入要求</p><p>添加：对于 <code>List&lt;?&gt;</code> 就不能向其内部添加数据，，除了添加 <code>null</code></p><p>允许读取数据，读取的数据类型为 <code>Object</code></p><h3 id="有限制条件的通配符的使用"><a href="#有限制条件的通配符的使用" class="headerlink" title="有限制条件的通配符的使用"></a>有限制条件的通配符的使用</h3><p>通配符指定上限</p><p>上限 <code>extends</code>：使用时指定的类型必须是继承某个类，或实现某个接口，即小于等于</p><p>通配符指定下限</p><p>下限 <code>super</code>：使用时指定的类型不能小于操作的类，即大于等于</p><p><code>&lt;? extends A&gt;</code> 可以作为 <code>G&lt;A&gt;</code> 和 <code>G&lt;B&gt;</code> 的父类的，其中 <code>B</code> 是 <code>A</code> 的子类</p><p><code>&lt;? super A&gt;</code> 可以作为 <code>G&lt;A&gt;</code> 和 <code>G&lt;B&gt;</code> 的父类的，其中 <code>B</code> 是 <code>A</code> 的父类</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 笔记 - 集合</title>
    <link href="/2021/02/18/java-notes-collection/"/>
    <url>/2021/02/18/java-notes-collection/</url>
    
    <content type="html"><![CDATA[<p>Java 笔记 - Collection</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一方面，面向对象语言对事物的体现都是以对象的形式,为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用 <code>Array</code> 存储对象方面具有一些弊端，而 Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。</p><p>数组在内存存储方面的特点：</p><ul><li>数组初始化以后，长度就确定了</li><li>数组声明的类型，就决定了进行元素初始化时的类型</li></ul><p>数组在存储数据方面的弊端：</p><ul><li>数组初始化以后，长度就不可变了，不便于扩展</li><li>数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的个数</li><li>数组存储的数据是有序的、可以重复的。存储数据的特点单一</li></ul><p>Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。</p><p>集合可以分为 Collection 和 Map 两种体系</p><ul><li>Collection 接口：单列数据，定义了存取一组对象的方法的集合<ul><li>List：元素有序，可重复的集合</li><li>Set：元素无需，不可重复的集合</li></ul></li><li>Map 接口：双列数据，保存具有映射关系的键值对集合</li></ul><p><img src="https://s3.ax1x.com/2021/02/18/yRjmMq.png" alt="Collection 接口的继承树"></p><p>Collection 接口的继承树</p><p><img src="https://s3.ax1x.com/2021/02/18/yRjJzR.png" alt="Map 接口的继承树"></p><p>Map 接口的继承树</p><h2 id="Collection-接口常用方法"><a href="#Collection-接口常用方法" class="headerlink" title="Collection 接口常用方法"></a>Collection 接口常用方法</h2><p>向 <code>Collection</code> 接口实现类的对象中添加数据时，要求数据所在的类要重写 <code>equals</code></p><ul><li><code>add(E e)</code>：将元素 e 添加到集合中</li><li><code>size()</code>：获取元素的个数</li><li><code>addAll(Collection&lt;? extends E&gt; coll)</code>：将 coll 中所有元素添加到集合中</li><li><code>isEmpty()</code>：判断当前集合是否为空</li><li><code>clear()</code>：清空集合元素</li><li><code>contains(E e)</code>：判断当前集合中是否包含 e（调用 e 的 <code>equals</code> 方法来判断）</li><li><code>containsAll(Collection&lt;?&gt; coll)</code>：判断 coll 中的所有元素是否都存在于当前集合中</li><li><code>remove(E e)</code>：从集合中移除 e，删除成功返回 <code>true</code>，删除失败返回 <code>false</code></li><li><code>removeAll(Collection&lt;?&gt; coll)</code>：从当前集合移除 coll 中的所有元素（差集）</li><li><code>retainAll(Collection&lt;?&gt; coll)</code>：交集，获取当前集合和 coll 集合的交集并返回给当前集合</li><li><code>equals(Object obj)</code>：判断当前集合和 obj 元素是否相同</li><li><code>hashCode()</code>：计算集合的哈希值</li><li><code>toArray()</code>：返回当前集合的 <code>Object</code> 数组</li></ul><p>扩展：数组到集合 <code>Arrays.asList(T... a)</code></p><ul><li><code>iterator()</code>：返回 <code>Iterator</code> 接口的实例，用于遍历集合元素。</li></ul><h2 id="使用-Iterator-遍历集合"><a href="#使用-Iterator-遍历集合" class="headerlink" title="使用 Iterator 遍历集合"></a>使用 <code>Iterator</code> 遍历集合</h2><p><code>Iterator</code> 对象称为迭代器（设计模式的一种），主要用于遍历 <code>Collection</code> 集合中的元素</p><p>GOF 给迭代器模式的定义为：提供一种方法访问一个容器（<code>container</code>）对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生</p><p><code>Collection</code> 接口继承了 <code>java.lang.Iterable</code> 接口，该接口有一个 <code>iterator</code> 方法，那么所有实现了 <code>Collection</code> 接口的集合类都有一个 <code>iterator</code> 方法，用以返回一个实现了 <code>Iterator</code> 接口的对象</p><p><code>Iterator</code> 仅用于遍历集合，<code>Iterator</code> 本身并不提供承装对象的能力。如果需要创建 <code>Iterator</code> 对象，则必须有一个被迭代的集合</p><p>集合对象每次调用 <code>iterator</code> 方法都得到一个全新的迭代器对象，默认游标都在<strong>集合的第一个元素之前</strong></p><p>方式一（不推荐）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> coll.iterator();<br>println(it.next());<br>println(it.next());<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>方式二（不推荐）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; coll.size(); i++) println(it.next());<br></code></pre></td></tr></table></figure><p>方式三（推荐）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(it.hasNext()) println(it.next());<br></code></pre></td></tr></table></figure><h3 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h3><p><code>hasNext()</code>：判断是否还有下一个元素</p><p><code>next()</code>：指针下移 → 将下移以后集合位置上的元素返回</p><h3 id="迭代器中的-remove"><a href="#迭代器中的-remove" class="headerlink" title="迭代器中的 remove"></a>迭代器中的 <code>remove</code></h3><p><code>remove</code> 方法可以帮你在迭代的时候删除一些元素</p><p>删除集合中 Tom</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(it.hasNext()) &#123;<br>    println(it.next());<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Tom&quot;</span>.equals(it)) it.remove();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>iterator</code> 可以删除集合的元素，但是是遍历过程中通过迭代器对象的 <code>remove</code> 方法，不是集合对象的 <code>remove</code> 方法<br>如果还未调用 <code>next</code> 或在上一次调用 next 之后已经调用了 <code>remove</code> 方法，再调用 <code>remove</code> 都会抛 <code>IllegalStateException</code></p><h2 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h2><p>Java5 提供了 foreach 循环迭代访问 Collection 和数组</p><p>遍历操作不需要获取 Collection 或数组的长度，无需使用索引访问元素</p><p>遍历集合的底层调用 Iterator 完成操作</p><p>foreach 可以用来遍历数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Person p : persons) println(p.getName());<br></code></pre></td></tr></table></figure><h2 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h2><p><code>List</code> 接口是 <code>Collection</code> 的子接口</p><p>鉴于 Java 中数组用来存储数据的局限性，通常用 <code>List</code> 替代数组</p><p><code>List</code> 集合类中元素<strong>有序</strong>且<strong>可重复</strong>，集合中每个元素都有其对应索引</p><p><code>List</code> 容器中的元素都对应一个整数型序号记载其在容器中的位置，可以根据序号存取容器中的元素</p><p>JDK API 中 <code>List</code> 接口的实现类常用的有：<code>ArrayList</code>、<code>LinkedList</code> 和 <code>Vector</code></p><p><code>ArrayList</code>、<code>LinkedList</code> 和 <code>Vector</code> 的异同：</p><p>相同：都是实现了 List 接口，存储数据的特点相同：存储有序的、可重复的数据</p><p>不同：</p><p><code>ArrayList</code>：作为 List 接口的主要实现类；线程不安全的，效率高；底层使用 <code>Object[]</code> 存储</p><p><code>LinkedList</code>：底层使用双向链表存储；对于频繁的插入和删除操作，使用此类效率比 <code>ArrayList</code> 高</p><p><code>Vector</code>：作为 List 接口的古老实现类；线程安全的，效率低；底层使用 <code>Object[]</code> 存储</p><h3 id="ArrayList-源码分析"><a href="#ArrayList-源码分析" class="headerlink" title="ArrayList 源码分析"></a>ArrayList 源码分析</h3><p>JDK7</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(); <span class="hljs-comment">// 创建了长度是 10 的 Object 数组 elementData</span><br>list.add(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// ...</span><br>list.add(<span class="hljs-number">11</span>); <span class="hljs-comment">// 如果添加导致底层 elementData 容量不够，则扩容</span><br><span class="hljs-comment">// 默认情况下扩容为原来的 1.5 倍</span><br><span class="hljs-comment">// 同时需要将原有数组中的数据复制到新的数组中</span><br><br></code></pre></td></tr></table></figure><p>建议开发中使用带参数的构造器：<code>new ArrayList(int initialCapacity)</code></p><p>JDK8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(); <span class="hljs-comment">// 底层 Object 数组初始化为 &#123;&#125;</span><br><span class="hljs-comment">// 并没有创建长度为 10 的数组</span><br>list.add(<span class="hljs-number">1</span>); <span class="hljs-comment">// 第一次调用 add 方法，底层才创建了长度为 10 的数组，并将 1 添加进去</span><br><span class="hljs-comment">// 后续添加和扩容操作和 jdk7 相同</span><br></code></pre></td></tr></table></figure><p>JDK7 中的 ArrayList 的创建类似与单例饿汉式，JDK8 中 ArrayList 的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省了内存</p><h3 id="LinkedList-源码分析"><a href="#LinkedList-源码分析" class="headerlink" title="LinkedList 源码分析"></a>LinkedList 源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LinkedList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(); <span class="hljs-comment">// 内部声明了 Node 类型的 first 和 last 属性</span><br><span class="hljs-comment">// 默认为 null</span><br>list.add(<span class="hljs-number">1</span>); <span class="hljs-comment">// 将 123 封装到 Node 中，创建 Node 对象</span><br></code></pre></td></tr></table></figure><p>Node 是普通双向链表的节点</p><h3 id="Vector-源码分析"><a href="#Vector-源码分析" class="headerlink" title="Vector 源码分析"></a>Vector 源码分析</h3><p>JDK7 和 8 中，通过 Vector() 创建对象时，底层都创建了长度为 10 的数组</p><p>在扩容方面，vector 默认扩容为原来数组长度的 2 倍</p><h3 id="List-接口中常用方法"><a href="#List-接口中常用方法" class="headerlink" title="List 接口中常用方法"></a>List 接口中常用方法</h3><ul><li><code>add(int inedx, E e)</code>：将 <code>e</code> 插入到 <code>index</code> 的位置</li><li><code>remove(int index)</code>：移除指定 <code>index</code> 位置的元素，并返回此元素</li><li><code>remove(E e)</code>：<code>Collection</code> 的方法</li><li><code>set(int index, E e)</code>：指定 <code>index</code> 位置的元素为 <code>e</code></li><li><code>get(int index)</code>：获取指定 <code>index</code> 位置的元素，如果越界则抛异常</li><li><code>size()</code>：返回长度</li><li><code>indexOf(E e)</code>：返回 <code>e</code> 在集合中首次出现的位置，如果不存在返回 -1</li><li><code>addAll(int index, Collection&lt;? extends E&gt; coll)</code>：从 <code>index</code> 位置开始将 <code>coll</code> 中的所有元素添加进来</li><li><code>lastIndexOf(E e)</code>：返回 <code>e</code> 在集合中末次出现的位置，如果不存在返回 -1</li><li><code>subList(int fromIndex, int toIndex)</code>：返回从 <code>fromIndex</code> 到 <code>toIndex</code> 位置（左闭右开）的子集合</li></ul><p>遍历：</p><ul><li>iterator 迭代器方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> list.iterator();<br><span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>    println(iterator.next());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>foreach 循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Object o : list) &#123;<br>    println(o);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>普通 for 循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>    println(list.get(i));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h2><p><code>HashSet</code>：作为 Set 接口的主要实现类；线程不安全；可存储 <code>null</code> 值</p><p><code>LinkedHashSet</code>：作为 HashSet 的子类；遍历其数据时，可以按照添加的顺序遍历</p><p><code>TreeSet</code>：可以按照添加对象的指定属性进行排序</p><h3 id="对-Set-无序性，不可重复的理解"><a href="#对-Set-无序性，不可重复的理解" class="headerlink" title="对 Set 无序性，不可重复的理解"></a>对 Set 无序性，不可重复的理解</h3><p>无序性</p><p>不等于随机性。存储的数据在数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的</p><p>不可重复性</p><p>保证添加的元素按照 equals 方法判断时，不能返回 true</p><h3 id="HashSet-中元素添加过程"><a href="#HashSet-中元素添加过程" class="headerlink" title="HashSet 中元素添加过程"></a>HashSet 中元素添加过程</h3><p>向 HashSet 中添加元素 <code>a</code>，首先调用 <code>a</code> 所在类的 <code>hashCode</code> 方法计算 <code>a</code> 的哈希值</p><p>此哈希值接着通过某种算法计算出在 <code>HashSet</code> 底层数组中的存放位置（即为索引位置）</p><p>判断数组此位置上是否已经有元素</p><p>如果此位置没有其他元素，则元素 <code>a</code> 添加成功</p><p>如有其他元素 <code>b</code>（或以链表形式存在的多个元素），则比较元素 <code>a</code> 与元素 <code>b</code> 的哈希值：</p><p>如果哈希值不相同，则元素 <code>a</code> 添加成功。如果哈希值相同，进而需要调用 <code>a</code> 所在类的 equals 方法</p><p>如果 <code>equals</code> 方法返回 <code>true</code>，元素 <code>a</code> 添加失败</p><p>如果 <code>equals</code> 返回 <code>false</code>，元素 <code>a</code> 添加成功</p><p>对于添加成功的情况，元素 <code>a</code> 与已经存在于指定索引位置上的数据以链表的方式存储</p><p>JDK7：元素 <code>a</code> 放到数组中，指向原来的元素</p><p>JDK8：原来的元素不动，指向元素 <code>a</code></p><p>数据在 HashSet 存储的结果是哈希链表</p><h3 id="hashCode-和-equals-方法的重写"><a href="#hashCode-和-equals-方法的重写" class="headerlink" title="hashCode 和 equals 方法的重写"></a><code>hashCode</code> 和 <code>equals</code> 方法的重写</h3><p>为什么 IDEA 中重写 hashCode 方法有 31 这个数字</p><ul><li>选择系数要选择尽量大的系数，因为计算出来的 hash 地址越大，所谓的冲突就越少，查找起来效率就越高</li><li>31 只占用了 5 bits，相乘造成数据溢出的概率较小</li><li>31 可以由 <code>i * 31 == (i &lt;&lt; 5) - 1</code> 来表示，现在很多虚拟机里面都有做相关优化</li><li>31 是一个素数，一个数字乘以素数最终结果只能被素数本身和 1 来整除</li></ul><p>向 Set 中添加的数据，其所在的类一定要重写 <code>hashCode</code> 和 <code>equals</code> 方法</p><h3 id="LinkedHashSet-的使用"><a href="#LinkedHashSet-的使用" class="headerlink" title="LinkedHashSet 的使用"></a><code>LinkedHashSet</code> 的使用</h3><p><code>LinkedHashSet</code> 作为 <code>HashSet</code> 的子类，在添加数据的同时，每个数据还维护了两个引用，记录了此数据的前一个数据和后一个数据</p><p>对于频繁的遍历操作，<code>LinkedHashSet</code> 效率高于 <code>HashSet</code></p><h3 id="TreeSet-的自然排序"><a href="#TreeSet-的自然排序" class="headerlink" title="TreeSet 的自然排序"></a><code>TreeSet</code> 的自然排序</h3><p>向 <code>TreeSet</code> 中添加的数据，要求是相同类的对象</p><p>两种排序方式：自然排序（实现 <code>Comparable</code> 接口）和定制排序（实现 <code>Comparator</code> 接口）</p><p>自然排序中，比较两个对象是否相同的标准为 <code>compareTo</code> 方法返回 <code>0</code>，不再是 <code>equals</code></p><p>定制排序中，比较两个对象是否相同的标准为 <code>compare</code> 方法返回 <code>0</code></p><h2 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h2><p><code>Map</code> 用来存储 <code>key-value</code> 对的数据</p><p><code>HashMap</code>：主要的实现类，线程不安全，效率高；存储 <code>null</code> 的 <code>key</code> 和 <code>value</code></p><p><code>LinkedHashMap</code>：保证遍历 <code>map</code> 元素时可以按照添加的顺序实现遍历。原理：在原有的 <code>HashMap</code> 底层结构基础上，添加了一对指针指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于 <code>HashMap</code></p><p><code>TreeMap</code>：保证按照添加的 <code>key-value</code> 对进行排序，实现排序遍历。此时考虑 <code>key</code> 的自然排序或定制排序。底层使用红黑树</p><p><code>Hashtable</code>：古老的实现类，线程安全，效率低；不能存储 <code>null</code> 的 <code>key</code> 和 <code>value</code></p><p><code>Properties</code>：常用来处理配置文件。<code>key</code> 和 <code>value</code> 都是 <code>String</code> 类型</p><p><code>HashMap</code> 底层：数组+链表（JDK7）数组+链表+红黑树（JDK8）</p><p>面试题：</p><ul><li><code>HashMap</code> 的底层实现原理</li><li><code>HashMap</code> 和 <code>HashTable</code> 的异同</li><li><code>CurrentHashMap</code> 与 <code>HashTable</code> 的区别</li></ul><h3 id="Map-结构的理解"><a href="#Map-结构的理解" class="headerlink" title="Map 结构的理解"></a>Map 结构的理解</h3><p>Map 中的 key 不可重复，无序，使用 Set 存储所有的 key。key 所在的类要重写 equals 和 hashCode 方法（以 HashMap 为例）</p><p>Map 中的 value 可重复，无序，使用 Collection 存储所有的 value。value 所在的类要重写 equals 方法</p><p>一个键值对：key-value 构成了一个 entry 对象</p><p>Map 中的 entry：无序的，不可重复的</p><h3 id="HashMap-的底层实现原理"><a href="#HashMap-的底层实现原理" class="headerlink" title="HashMap 的底层实现原理"></a>HashMap 的底层实现原理</h3><p>JDK7</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><span class="hljs-comment">// 在实例化以后，创建了长度是 16 的一维数组 Entry[] table</span><br>map.put(key1, value1);<br><span class="hljs-comment">// 调用 key1 所在类的 hashCode 计算 key1 的哈希值</span><br><span class="hljs-comment">// 此哈希值经过某种算法以后，得到在 Entry 数组中存放的位置</span><br><span class="hljs-comment">// 如果此位置上的数据为空，此时的 key1-value1 添加成功</span><br><span class="hljs-comment">// 如果此位置上的数据不为空，意味着此位置上存在一个或多个数据，以链表的形式存储</span><br><span class="hljs-comment">// 比较 key1 和已经存在的一个或多个数据的哈希值：</span><br><span class="hljs-comment">//   如果 key1 的哈希值与已经存在的数据的哈希值不相同，此时 key1-value1 添加成功</span><br><span class="hljs-comment">//   如果 key1 的哈希值与已经存在的某一个数据的哈希值相同</span><br><span class="hljs-comment">//     继续比较：调用 key1 所在类的 equals 方法，比较</span><br><span class="hljs-comment">//       如果 equals 方法返回 false，则 key1-value1 添加成功</span><br><span class="hljs-comment">//       如果 equals 方法返回 true，使用 value1 替换相同 key 的 value</span><br><span class="hljs-comment">// ... put 操作</span><br><span class="hljs-comment">// 在不断的添加过程中，会涉及到扩容问题。</span><br><span class="hljs-comment">// 默认的扩容方式：扩容为原来容量的 2 倍，并将原有数据复制过来</span><br></code></pre></td></tr></table></figure><p>在不断的添加过程中，会涉及到扩容问题，当<strong>超出临界值</strong>且<strong>要存放的位置非空</strong>时进行扩容，默认扩容为原来容量的 2 倍，并将原有数据复制过来</p><p>JDK8</p><p>JDK8 相较于 JDK7 在底层实现方面的不同</p><ul><li><code>new HashMap()</code> 没有创建一个长度为 16 的数组</li><li>底层的数组是 <code>Node[]</code> 而非 <code>Entry[]</code></li><li>首次调用 <code>put</code> 方法时，底层创建长度为 16 的数组</li><li>JDK7 底层结构只有数组和链表。JDK8 中底层结构：数组+链表+红黑树</li><li>当数组某一个索引位置上的元素以链表形式存在的数据个数大于 8 且当前数组长度大于 64，此时此索引位置上的所有数据改为使用红黑树存储</li></ul><p>一些重要的常量和变量</p><p><code>DEFAULT_INITIAL_CAPACITY</code>：默认容量：16</p><p><code>DEFAULT_LOAD_FACTOR</code>：HashMap 的默认加载因子：0.75</p><p><code>threshold</code>：扩容的临界值，&#x3D;容量 x 填充因子：默认为 16 x 0.75 &#x3D; 12</p><p><code>TREEIFY_THRESHOLD</code>：Bucket 中链表长度大于该默认值，转化为红黑树</p><p><code>MIN_TREEIFY_CAPACITY</code>：桶中的 Node 被树化时最小的 hash 表容量：64</p><h3 id="LinkedHashMap-的底层实现"><a href="#LinkedHashMap-的底层实现" class="headerlink" title="LinkedHashMap 的底层实现"></a>LinkedHashMap 的底层实现</h3><p>源码中的节点添加了两个引用 before、after，能够记录元素添加的先后顺序</p><h3 id="Map-中常用方法"><a href="#Map-中常用方法" class="headerlink" title="Map 中常用方法"></a>Map 中常用方法</h3><p>添加、删除、修改</p><ul><li><code>put(K key, V value)</code>：将键值对添加到（或修改）当前 <code>map</code> 对象</li><li><code>putAll(Map&lt;K, V&gt; m)</code>：将 <code>m</code> 中的所有键值对添加到当前 <code>map</code> 中</li><li><code>remove(K key)</code>：移除指定 <code>key</code> 值的键值对，返回 <code>value</code></li><li><code>clear()</code>：清空当前 <code>map</code> 中所有的数据</li></ul><p>查询</p><ul><li><code>get(K key)</code>：获取指定 <code>key</code> 对应的 <code>value</code></li><li><code>containsKey(K key)</code>：是否包含指定的 <code>key</code></li><li><code>containsValue(V value)</code>：是否包含指定的 <code>value</code></li><li><code>size()</code>：返回 <code>map</code> 中键值对的个数</li><li><code>isEmpty()</code>：判断当前 <code>map</code> 是否为空</li><li><code>equals(Object obj)</code>：判断当前 <code>map</code> 和参数对象 <code>obj</code> 是否相等</li></ul><p>视图操作</p><ul><li><code>keySet()</code>：返回所有 <code>key</code> 构成的 <code>Set</code> 集合</li><li><code>values()</code>：返回所有 <code>value</code> 构成的 <code>Collection</code> 集合</li><li><code>Set entrySet()</code>：返回所有键值对构成的 <code>Set</code> 集合</li></ul><h3 id="TreeMap-两种添加方式的使用"><a href="#TreeMap-两种添加方式的使用" class="headerlink" title="TreeMap 两种添加方式的使用"></a>TreeMap 两种添加方式的使用</h3><p>向 TreeMap 中添加键值对，要求 key 必须是由同一个类创建的对象</p><p>因为要按照 key 进行排序：自然排序、定制排序</p><h3 id="Properties-处理属性文件"><a href="#Properties-处理属性文件" class="headerlink" title="Properties 处理属性文件"></a>Properties 处理属性文件</h3><p>Properties 类是 HashTable 的子类，该类用于处理属性文件</p><p>由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型</p><p>存取数据时，建议使用 <code>setProperty(String key, String value)</code> 方法和 <code>getProperty(String key)</code> 方法</p><p>默认情况配置文件放在项目的根目录下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br><span class="hljs-type">FileInputSystem</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputSystem</span>(<span class="hljs-string">&quot;jdbc.properties&quot;</span>);<br>props.load(in);<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> props.getProperty(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> props.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h2><p>Collections 是一个操作 Set、List、Map 等集合的工具类</p><p>Collections 中提供了一系列的静态方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</p><h3 id="排序操作的静态方法"><a href="#排序操作的静态方法" class="headerlink" title="排序操作的静态方法"></a>排序操作的静态方法</h3><ul><li><code>reverse(List)</code>：反转 <code>List</code> 中元素的顺序</li><li><code>shuffle(List)</code>：对 <code>List</code> 集合元素进行随机排序</li><li><code>sort(List)</code>：根据元素的自然顺序对指定 <code>List</code> 集合元素按升序排序</li><li><code>sort(List, Comparator)</code>：根据指定的 <code>Comparator</code> 产生的顺序对 <code>List</code> 集合元素进行排序</li><li><code>swap(List, int, int)</code>：将指定 <code>List</code> 集合中的 i 处元素和 j 处元素进行交换</li></ul><h3 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h3><ul><li><code>max(Collection)</code>：根据元素的自然排序，返回给定集合中的最大元素</li><li><code>max(Collection, Comparator)</code>：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li><li><code>min(Collection)</code>：最小</li><li><code>min(Collection, Comparator)</code>：最小</li><li><code>frequency(Collection, Object)</code>：返回指定集合中指定元素出现的次数</li><li><code>copy(List dest, List src)</code>：将 src 中的内容复制到 dest 中，dest 的 size 必须要大于等于 src 的 size，否则会抛异常</li><li><code>replaceAll(List list, Object oldVal, Object newVal)</code>：使用新值替换 List 对象的所有旧值</li></ul><h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h3><p>Collections 中提供了多个 <code>synchronizedXxx</code> 方法，该方法可将指定集合包装成线程同步的集合，从而解决多线程兵法访问集合时的线程安全问题</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java 集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 笔记 - 注解</title>
    <link href="/2021/02/17/java-notes-annoation/"/>
    <url>/2021/02/17/java-notes-annoation/</url>
    
    <content type="html"><![CDATA[<p>Java 笔记 - 注解</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>注解是代码里的特殊标记，这些标记可以在编译、类加载和运行时被读取并执行相应的处理。通过使用注解，程序员可以在不改变程序原有逻辑的情况下在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署</p><p>注解可以像修饰符一样被树勇，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在注解的 <code>name=value</code> 对中</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>生成文档相关的注解</p><p>在编译时进行格式检查</p><p>JDK 内置三个注解</p><ul><li><code>@Override</code>：重写父类<strong>方法</strong></li><li><code>@Deprecated</code>：表示所修饰的元素已经过时</li><li><code>@SuppressWarnings</code>：抑制编译器警告</li></ul><p>跟踪代码依赖性，实现替代配置文件的功能</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><ul><li>定义新的 <code>Annotation</code> 类型使用 <code>@interface</code> 关键字</li><li>自定义注解自动继承了 <code>java.lang.annotation.Annotation</code> 接口</li><li><code>Annotation</code> 的成员变量在 <code>Annotation</code> 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、 <code>String</code> 类型、<code>Class</code> 类型、<code>enum</code> 类型、 <code>Annotation</code> 类型以上所有类型的数组。</li><li>可以在定义 <code>Annotation</code> 的成员变量时为其指定初始值，指定成员变量的初始值可使用 <code>default</code> 关键字</li><li>如果只有一个参数成员，建议使用参数名为 <code>value</code></li><li>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是<code>参数名=参数值</code>，如果只有一个参数成员，且名称为 <code>value</code>，可以省略 <code>value=</code></li><li>没有成员定义的 <code>Annotation</code> 称为标记；包含成员变量的 <code>Annotation</code> 称为元数据 <code>Annotation</code></li><li>注意：自定义注解必须配上注解的信息处理流程（使用反射）才有意义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>JDK 的元注解对现有的注解进行解释</p><p>JDK5 提供了四个标准的元注解类型，分别是</p><ul><li><code>Retention</code>：只能用于修饰一个 <code>Annotation</code> 定义，用于指定该 <code>Annotation</code> 的生命周期，<code>@Rentention</code> 包含一个 <code>RetentionPolicy</code> 类型的成员变量,使用 <code>@Rentention</code> 时必须为该 <code>value</code>成员变量指定值<ul><li><code>RetentionPolicy.SOURCE</code>：在源文件中有效（即源文件保留），编译器直接丢弃这种策眳的注释</li><li><code>RetentionPolicy.CLASS</code>：在 <code>class</code> 文件中有效（即 <code>class</code> 保留），当运行 Java 程序时，JVM 不会保留注解。这是默认值</li><li><code>RetentionPolicy.RUNTIME</code>：在运行时有效（即运行时保留），当运行 Java 程序时，JVM 会保留注释。程序可以通过反射获取该注释</li></ul></li><li><code>Target</code>：用于指定被修饰的注解能用于修饰哪些元素，包含一个名为 value 的成员变量，类型为 <code>ElementType</code> 数组<ul><li><code>CONSTRUCTOR</code>：用于描述构造器</li><li><code>FIELD</code>：用于描述字段</li><li><code>LOCAL_VARIABLE</code>：用于描述局部变量</li><li><code>METHOD</code>：用于描述方法</li><li><code>PACKAGE</code>：用于描述包</li><li><code>PARAMETER</code>：用于描述参数</li><li><code>TYPE</code>：用于描述类、接口（包括注解类型）或 <code>enum</code> 声明</li></ul></li><li><code>Documented</code>：用于指定被该元注解修饰的注解类将被 javadoc 工具提取成文档。默认情况下，<code>javadoc</code> 是不包括注解的。定义为 <code>Document</code> 的注解必须设置 <code>Retention</code> 值为 <code>RUNTIME</code></li><li><code>Inherited</code>：被它修饰的类具有继承性，如果某个类使用了被 <code>Inherited</code> 修饰的注解，则其子类自动具有该注解，实际使用中使用较少</li></ul><p>自定义注解通常会指明两个元注解：<code>Retention</code> 和 <code>Target</code></p><h2 id="JDK8-注解新特性"><a href="#JDK8-注解新特性" class="headerlink" title="JDK8 注解新特性"></a>JDK8 注解新特性</h2><h3 id="可重复注解"><a href="#可重复注解" class="headerlink" title="可重复注解"></a>可重复注解</h3><p>如果想使用两个相同的注解</p><ul><li>在 <code>MyAnnotation</code> 声明 <code>@Repeatable</code>，成员值为 <code>MyAnnotations.class</code></li><li><code>MyAnnotation</code> 的 <code>Target</code>、<code>Retention</code> 和 <code>Inherited</code> 必须和 <code>MyAnnotations</code> 的相同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// before jdk8</span><br><span class="hljs-comment">// err</span><br><span class="hljs-comment">// @MyAnnotation(&quot;hi&quot;)</span><br><span class="hljs-comment">// @Myannotation(&quot;abc&quot;)</span><br><span class="hljs-meta">@MyAnnotations(&#123;@MyAnnotation(&quot;hi&quot;), @Myannotation(&quot;abc&quot;)&#125;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span> &#123; <span class="hljs-comment">/* ... */</span>&#125;<br><br><span class="hljs-meta">@interface</span> MyAnnotation &#123; String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;hello&quot;</span>; &#125;<br><br><span class="hljs-meta">@interface</span> MyAnnotations &#123; MyAnnotation[] value(); &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// after jdk8</span><br><span class="hljs-meta">@MyAnnotation(&quot;hi&quot;)</span><br><span class="hljs-meta">@Myannotation(&quot;abc&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span> &#123; <span class="hljs-comment">/* ... */</span>&#125;<br><br><span class="hljs-meta">@Repeatable(MyAnnotations.class)</span><br><span class="hljs-meta">@interface</span> MyAnnotation &#123; String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;hello&quot;</span>; &#125;<br><br><span class="hljs-meta">@interface</span> MyAnnotations &#123; MyAnnotation[] value(); &#125;<br></code></pre></td></tr></table></figure><h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><p><code>ElementType</code> 里面多了两个：<code>TYPE_PARAMETER</code>，<code>TYPE_USE</code></p><p>在 Java8 之前，注解只能是在声明的地方使用，Java8 开始，注解可以应用在任何地方</p><ul><li><code>TYPE_PARAMETER</code>：表示该注解能写在类型变量的声明语句中（如泛型声明）</li><li><code>TYPE_USE</code>：表示该注解能写在使用类型的任何语句中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;<span class="hljs-meta">@TypeDefine()</span> U&gt; &#123;<br>    <span class="hljs-keyword">private</span> U u;<br>    <span class="hljs-keyword">public</span> &lt;<span class="hljs-meta">@TypeDefine()</span> T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE_PARAMETER&#125;)</span><br><span class="hljs-meta">@interface</span> TypeDefine &#123;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java 注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建 Docker 镜像</title>
    <link href="/2021/01/22/build-custom-docker-images/"/>
    <url>/2021/01/22/build-custom-docker-images/</url>
    
    <content type="html"><![CDATA[<p>构建 Docker 镜像的方法</p><span id="more"></span><p>构建 Docker 镜像可以让别人也可以构建出相同的环境</p><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><h3 id="查看更改"><a href="#查看更改" class="headerlink" title="查看更改"></a>查看更改</h3><p>在终端中输入 <code>docker diff CONTAINER</code> 来查看容器的变动，其中 A 是新增的文件，C 是修改的文件，D 是删除的文件</p><h3 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h3><p>在终端中输入 <code>docker commit CONTAINER username/image-name:tag</code> 来提交更改，username 是自己定义的用户名，image-name 是镜像名称，<code>tag</code> 是标签（版本号），可以是数字、字符串等</p><p>示例：<code>docker commit foobar mazixiang/foobar:0.1.0</code></p><p>之后就可以在本地看到提交的 Docker 镜像了</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>在项目文件夹下新建 Dockerfile 文件，然后添加字段</p><ul><li><code>FROM</code> 表示构建镜像的基础</li><li><code>RUN</code> 构建镜像时执行的命令</li><li><code>WORKDIR</code> 定义工作目录</li><li><code>COPY</code> 将本机文件拷贝到容器中</li><li><code>CMD</code> 指定容器运行时要执行什么命令，只能有一个</li></ul><p>在项目文件夹下执行 <code>docker build -t username/image-name:tag .</code> 来构建容器</p><p>例</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> ubuntu<br><span class="hljs-keyword">RUN</span><span class="language-bash"> sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt install nodejs -y</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;test.js&quot;</span>]</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile 参考文档</a></p><p><a href="https://www.bilibili.com/video/BV1v5411G7xc">BiliBili 自建 Docker 镜像 - CodingStartip</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础 Docker 命令</title>
    <link href="/2021/01/21/basic-docker-commands/"/>
    <url>/2021/01/21/basic-docker-commands/</url>
    
    <content type="html"><![CDATA[<p>介绍一些基础的 Docker 命令</p><span id="more"></span><h2 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a><code>docker ps</code></h2><p><code>ps</code> 命令用于查看正在运行的镜像的状态</p><p><code>ps -a</code> 命令可以查看所有容器</p><h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a><code>docker run</code></h2><p>run 命令用于建立并运行一个容器，常用参数有</p><ul><li><code>-i</code>：与这个容器互动</li><li><code>-t</code>：创建一个终端</li><li><code>--name 容器名称</code>：容器的名称</li><li><code>-p 本机端口:虚拟机端口</code>：容器的端口映射</li><li><code>-d</code>：启动为 detached 模式，不进入容器中</li><li><code>-v 本机路径:虚拟机路径</code>：将电脑中的文件映射到容器中，允许容器获取指定位置的文件</li></ul><p>例 <code>docker run -it --name ubuntu -p 8080:80 -v $(pwd):/app ubuntu:lts</code></p><h2 id="容器匹配"><a href="#容器匹配" class="headerlink" title="容器匹配"></a>容器匹配</h2><p>下面几个命令中的 CONTAINER 可以是：</p><ul><li>容器名称</li><li>容器 ID</li><li>容器 ID 的前几位，Docker 会进行模糊匹配</li></ul><h2 id="docker-start-CONTAINER"><a href="#docker-start-CONTAINER" class="headerlink" title="docker start CONTAINER"></a><code>docker start CONTAINER</code></h2><p><code>start</code> 命令用于启动一个已经停止的容器</p><h2 id="docker-stop-CONTAINER"><a href="#docker-stop-CONTAINER" class="headerlink" title="docker stop CONTAINER"></a><code>docker stop CONTAINER</code></h2><p><code>stop</code> 命令用于停止一个正在运行的容器</p><h2 id="docker-attach-CONTAINER"><a href="#docker-attach-CONTAINER" class="headerlink" title="docker attach CONTAINER"></a><code>docker attach CONTAINER</code></h2><p><code>attach</code> 命令用于进入到一个正在运行的容器中</p><h2 id="docker-rm-CONTAINER"><a href="#docker-rm-CONTAINER" class="headerlink" title="docker rm CONTAINER"></a><code>docker rm CONTAINER</code></h2><p><code>rm</code> 命令用于移除一个容器</p><h2 id="docker-image-ls"><a href="#docker-image-ls" class="headerlink" title="docker image ls"></a><code>docker image ls</code></h2><p><code>image ls</code> 命令可以查看所有本地镜像</p><h2 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a><code>docker rmi</code></h2><p><code>rmi</code> 命令可以删除指定的本地镜像，释放空间</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/BV1vD4y1X7ce">BiliBili 初探 Docker - CodingStartup</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 设置锐捷客户端为自启动</title>
    <link href="/2020/10/19/set-ruijie-client-to-self-start-on-ubuntu/"/>
    <url>/2020/10/19/set-ruijie-client-to-self-start-on-ubuntu/</url>
    
    <content type="html"><![CDATA[<p>如何用 Linux 的 systemd 让锐捷客户端自启动</p><span id="more"></span><h2 id="我为什么要换为-Ubuntu"><a href="#我为什么要换为-Ubuntu" class="headerlink" title="我为什么要换为 Ubuntu"></a>我为什么要换为 Ubuntu</h2><p>Windows 10 系统实在没法用来开发，最近遇到的问题：</p><ul><li>PowerShell Git 客户端显示 Git log 乱码，按照网上大多数教程都没用</li><li>PowerShell Python 下虚拟环境 Virtualenv 显示颜色过于鲜艳</li><li>没有原生 GCC、G++ 编译器，安装 MinGW 频繁报错</li><li>系统的大多数编程环境（如 Python）无法一键进行更新</li></ul><p>实在用不下去，添加了 Ubuntu 系统，和 Windows 10 组了一个双系统，总体来说兼容性很好，没有发生致命错误，小错误倒是一堆，而且还有很多必须要用但是不兼容的软件，例如本文章的锐捷客户端，所以来记录一下如何配置锐捷客户端并且设置为自启动</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>硬件环境：DELL G3 3579</p><p>操作系统：Ubuntu 20.04LTS</p><h2 id="官方客户端"><a href="#官方客户端" class="headerlink" title="官方客户端"></a>官方客户端</h2><p>锐捷的官方客户端需要网卡加载以后再运行，没法进行 <code>systemd</code> 配置，所以不使用官方客户端</p><h2 id="第三方客户端"><a href="#第三方客户端" class="headerlink" title="第三方客户端"></a>第三方客户端</h2><p>这里使用 minieap 作为认证客户端，minieap 的 <a href="https://github.com/updateing/minieap">GitHub 链接</a></p><p>首先，克隆仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/updateing/minieap.git<br><span class="hljs-comment"># clone github repo</span><br></code></pre></td></tr></table></figure><p>转到仓库 <code>cd minieap</code></p><p>安装依赖 <code>sudo apt install gcc g++ cmake</code></p><p>进行编译 <code>make</code></p><p>可以直接使用 <code>$&#123;你的 minieap 目录路径&#125;/minieap -h</code> 来查看文档，说明基本命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-variable">$&#123;你的 minieap 目录路径&#125;</span>/minieap -u <span class="hljs-variable">$&#123;你的用户名&#125;</span> -p <span class="hljs-variable">$&#123;你的密码&#125;</span> -n <span class="hljs-variable">$&#123;你的网卡名&#125;</span> -b 1<br><span class="hljs-comment"># -b 1 是在后台运行的意思</span><br></code></pre></td></tr></table></figure><p>就可以使用基本的认证功能了</p><h2 id="设置开机自启动"><a href="#设置开机自启动" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h2><h3 id="新方案"><a href="#新方案" class="headerlink" title="新方案"></a>新方案</h3><p>使用一段事件之后，发现旧办法似乎只能在重新启动时生效，在纯开机时无法生效，这里介绍一种新的办法：通过 systemd 系统服务管理来设置开机启动，下面介绍步骤：</p><p>使用管理员权限在 <code>/lib/systemd/system/</code> 下建立新文件 <code>minieap.service</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo <span class="hljs-built_in">touch</span> /lib/systemd/system/minieap.service<br><span class="hljs-comment"># create minieap.service in /lib/systemd/system/</span><br></code></pre></td></tr></table></figure><p>使用文本编辑器打开此文件，这里使用 vim 文本编辑器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo vim /lib/systemd/system/minieap.service<br><span class="hljs-comment"># edit /lib/systemd/system/minieap.service with vim</span><br></code></pre></td></tr></table></figure><p>输入如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">[Unit]<br>Description=Minieap authentication service<br>After=etcd.service<br><br>[Service]<br>Type=simple<br>ExecStart=sudo /opt/minieap/minieap<br>ExecStop=sudo /opt/minieap/minieap -k<br>RestartSec=10<br>Restart=on-failure<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>简单介绍一下各个字段</p><ul><li>Description：此服务单元的描述，可以随便写</li><li>After：在 etcd.service 服务之后启动</li><li>Type：此服务的类型，simple 是最普通的类型</li><li>ExecStart：启动此服务时候进行的脚本</li><li>ExecStop：停止此服务时候进行的脚本</li><li>RestartSec：systemd 重启服务之前，需要等待的秒数</li><li>Restart：sshd 退出知乎，systemd 的重启方式，on-failure 表示任何以外的失败，将重启 sshd，如果 sshd 正常停止，他就不会重启</li><li>WantedBy：表示该服务所在的 Target，systemd 的默认启动 Target 是 multi-user.target</li></ul><p>编辑完毕后执行 <code>sudo systemctl enable minieap.service</code> 命令设置开机自启动</p><h3 id="旧方案（可能会失效）"><a href="#旧方案（可能会失效）" class="headerlink" title="旧方案（可能会失效）"></a>旧方案（可能会失效）</h3><p>打开程序坞中的 <code>Startup Applications</code>，添加一条任务，名称是 minieap，命令是 <code>$&#123;你的 minieap 目录路径&#125;/minieap -u $&#123;你的用户名&#125; -p $&#123;你的密码&#125; -n $&#123;你的网卡名&#125; -b 1</code> 即可完成设置</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="minieap-用法"><a href="#minieap-用法" class="headerlink" title="minieap 用法"></a>minieap 用法</h3><p>minieap 的 <a href="https://github.com/updateing/minieap">GitHub 链接</a></p><h3 id="systemd-资料"><a href="#systemd-资料" class="headerlink" title="systemd 资料"></a>systemd 资料</h3><p><a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html">Systemd 入门教程：实战篇 - 阮一峰的网络日志</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PowerShell 快速复制文件内容到剪贴板</title>
    <link href="/2020/09/14/copy-file-content-with-powershell/"/>
    <url>/2020/09/14/copy-file-content-with-powershell/</url>
    
    <content type="html"><![CDATA[<p>介绍使用 Windows PowerShell 快速复制文件内容到剪贴板的方法</p><span id="more"></span><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>假设要复制当前目录下的 <code>file.txt</code>，打开 PowerShell，输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&gt; <span class="hljs-built_in">Get-Content</span> file.txt | clip<br></code></pre></td></tr></table></figure><p>即可将 <code>file.txt</code> 的内容复制到剪贴板</p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PowerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL Server 8 的远程连接错误 ERROR 2003 解决办法</title>
    <link href="/2020/09/12/mysql-remote-connection-error-2003/"/>
    <url>/2020/09/12/mysql-remote-connection-error-2003/</url>
    
    <content type="html"><![CDATA[<p>简单介绍 MySQL Server 8 的远程连接错误 ERROR 2003 解决办法</p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>购买了一台阿里云服务器，但是我的域名没法备案，无法用来存放网页，所以想将其作为数据库服务器，在服务器上运行了 MySQL Server 8.0 数据库软件，之后发现无法通过 DataGrip 软件连接，开始排查原因。</p><h2 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h2><p>服务器是阿里云的最低配服务器，安装的是 Ubuntu20.04 - LTS 系统，有基础的开发环境</p><h2 id="数据库用户问题"><a href="#数据库用户问题" class="headerlink" title="数据库用户问题"></a>数据库用户问题</h2><p>远程连接数据库并且通过 MySQL Shell 创建并授权一个用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;tone&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123123&#x27;</span>;<br><br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> privileges <span class="hljs-keyword">on</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;tone&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">grant</span> option;<br></code></pre></td></tr></table></figure><p>之后打开本地电脑上面的软件，发现 DataGrip 报错，输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>[08S01] Communications link failure<br><br>The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.<br>java.net.ConnectException: Connection refused: connect.<br></code></pre></td></tr></table></figure><p>怀疑是密码的问题，于是查看了一下，默认的密码格式为 <code>caching_sha2_password</code>，但 <code>root</code> 用户的密码格式为 <code>mysql_native_password</code>，所以进行了操作修改了密码格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;zhangsan&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;zhangsan111&#x27;</span>;<br></code></pre></td></tr></table></figure><p>发现仍然无法连接</p><h2 id="防火墙端口问题"><a href="#防火墙端口问题" class="headerlink" title="防火墙端口问题"></a>防火墙端口问题</h2><p>查阅网上对 <code>jdbc</code> 的 <code>java.net.ConnectException: Connection refused: connect.</code> 的说明，可能是端口问题，于是开始排查服务器的防火墙。</p><p>首先，打开阿里云控制台的安全组，将 MySQL 运行的端口（默认为 3306）对所有 IP 地址开放，还是无法连接，然后在 Linux 上安装 nmap 软件查看开放的端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt install nmap<br>...<br>$ nmap localhost<br>Starting Nmap 7.80 ( https://nmap.org ) at 2020-09-12 22:22 CST<br>Nmap scan report <span class="hljs-keyword">for</span> localhost (127.0.0.1)<br>Host is up (0.0000030s latency).<br>Other addresses <span class="hljs-keyword">for</span> localhost (not scanned): ::1<br>Not shown: 997 closed ports<br>PORT     STATE SERVICE<br>22/tcp   open  ssh<br>80/tcp   open  http<br>3306/tcp open  mysql<br><br>Nmap <span class="hljs-keyword">done</span>: 1 IP address (1 host up) scanned <span class="hljs-keyword">in</span> 0.05 seconds<br></code></pre></td></tr></table></figure><p>发现所有端口均开放正常，也没有防火墙之类的问题，于是继续排查问题</p><h2 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h2><p>为了更加精确地排查错误，我使用了 Ubuntu - WSL 安装了 MySQL-Client-8.0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt install mysql-client-8.0<br>...<br></code></pre></td></tr></table></figure><p>使用本地的 MySQL 客户端连接服务器后，才精准地定位到了错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">Enter password:<br>ERROR 2003 (HY000): Can&#x27;t connect to MySQL server on &#x27;47.101.58.125&#x27; (111)<br></code></pre></td></tr></table></figure><p>于是开始上网查找 ERROR 2003 的解决方法，发现了提示：ERROR 2003 有可能和服务器端的配置有关系，马上找到 <code>/etc/mysql/my.cnf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">!includedir /etc/mysql/conf.d/<br>!includedir /etc/mysql/mysql.conf.d/<br></code></pre></td></tr></table></figure><p>发现有两个目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">/etc/mysql/conf.d<br>├── mysql.cnf<br>└── mysqldump.cnf<br><br>/etc/mysql/mysql.conf.d<br>├── mysql.cnf<br>└── mysqld.cnf<br></code></pre></td></tr></table></figure><p>分别查看这四个文件，发现只有 <code>/etc/mysql/mysql.conf.d/mysqld.cnf</code> 有一些内容，其中，网上的资料说可能与 <code>bind-address=127.0.0.1</code> 有关系，而这个文件正好有一行，所以尝试修改为我的服务器的 IP 地址，发现不行。于是去查了一下有关这个属性的资料，得知，这个属性是指定 TCP&#x2F;IP 的配置，将其注释掉，重启 MySQL 服务，DataGrip 连接成功，MySQL 客户端连接成功。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我本以为远程连接服务器上的数据库是非常简单的，只需要一个用户和密码就可以连接了。但是，实际操作服务器时，还是有很多的细节没有注意，导致了多次的失败，所以对于任何事情一定要多去实践，只有多实践才能知道有哪些不足。纸上得来终觉浅，绝知此事要躬行。</p><p>许多事情，不要觉得简单就去用图形界面，拿这次举例，DataGrip 是 JetBrains 公司推出的带有图形界面的数据库管理软件，但是他连接失败只报出了 <code>java.net.ConnectException</code> 错误，导致我排查错误的方向不对，而命令行上面的 <code>mysql-client</code> 直接报告了错误的详细信息，让我有了更精准的排查方式。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="数据库用户"><a href="#数据库用户" class="headerlink" title="数据库用户"></a>数据库用户</h3><p>创建用户并授权：<a href="http://netsite.win/2018/06/13/mysql/mysql8%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%8F%8A%E6%8E%88%E6%9D%83-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5-%E5%9D%91/">mysql8 创建用户及授权-远程连接(坑) | 永无止境</a></p><p>修改密码格式：<a href="https://blog.csdn.net/qq_22860341/article/details/85061819">mysql8 创建用户并授权_飞奔的波大爷的博客-CSDN 博客</a></p><h3 id="防火墙和端口"><a href="#防火墙和端口" class="headerlink" title="防火墙和端口"></a>防火墙和端口</h3><p>对 <code>java.net.ConnectException: Connection refused: connect.</code> 错误的解决方法：<a href="https://blog.csdn.net/u011314442/article/details/80926682">解决： java.net.ConnectException: Connection refused: connect_愿我如星君如月 … 夜夜流光相皎洁 …-CSDN 博客</a></p><p>查看正在使用的端口：<a href="https://blog.csdn.net/q361239731/article/details/53180126">linux 如何查看正在使用的端口_萝卜 Master 的博客-CSDN 博客</a></p><p>查看开放的端口：<a href="https://www.cnblogs.com/kerrycode/p/5609010.html">Linux 查看服务器开放的端口号 - 潇湘隐者 - 博客园</a></p><h3 id="服务器端配置问题"><a href="#服务器端配置问题" class="headerlink" title="服务器端配置问题"></a>服务器端配置问题</h3><p>ERROR 2003 解决方法：<a href="https://blog.csdn.net/qustdjx/article/details/26937325">MySQL 远程连接 ERROR 2003 (HY000):Cant connect to MySQL server onXXXXX(111) 的问题_qustdjx 的博客-CSDN 博客</a></p><p>ERROR 2003 解决方法：<a href="https://blog.csdn.net/a5nan/article/details/72864249">MySQL 远程访问报错 ERROR 2003 (HY000):Cant connect to MySQL server onXXXXX(111)_没事就写点-CSDN 博客</a></p><h3 id="对-bind-address-属性的解释"><a href="#对-bind-address-属性的解释" class="headerlink" title="对 bind-address 属性的解释"></a>对 bind-address 属性的解释</h3><p>官方：<a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_tmpdir">MySQL :: MySQL 8.0 Reference Manual :: 5.1.8 Server System Variables</a>，Chrome 80 以上点击 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#docs-body:~:text=a-,bind_address%20system">此链接</a>，可以直达 <code>bind-address</code> 处</p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vimium 的介绍和使用</title>
    <link href="/2020/08/22/introduction-to-vimium/"/>
    <url>/2020/08/22/introduction-to-vimium/</url>
    
    <content type="html"><![CDATA[<p>介绍 Vimium 以及基本用法</p><span id="more"></span><h2 id="介绍-Vimium"><a href="#介绍-Vimium" class="headerlink" title="介绍 Vimium"></a>介绍 Vimium</h2><p>Vimium <a href="https://vimium.github.io/">官网链接</a></p><p><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb">插件 Chrome 商店地址</a></p><p>官网介绍：Vimium 是 Google Chrome 浏览器的扩展程序，它提供了 Vim 精神用于导航和控制的键盘快捷键。</p><p>对于一部分熟练使用 Vim 文本编辑器的程序员而言，这款插件可以极为简化浏览网页的过程。</p><p>你也可以自定义 Vimium 的所有快捷键</p><h2 id="默认快捷键表"><a href="#默认快捷键表" class="headerlink" title="默认快捷键表"></a>默认快捷键表</h2><p><img src="https://s1.ax1x.com/2020/08/23/dwEY2d.png" alt="Vimium 默认快捷键表"></p><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>介绍 Vimium 插件的基础使用</p><div class="note note-warning">            <p>注意：以下说明全部基于 Vimium 的默认快捷键，所有快捷键区分大小写</p>          </div><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>使用 <code>h</code>、<code>j</code>、<code>k</code>、<code>l</code> 来作为左、下、上、右的基础移动，使用 <code>gg</code>、<code>G</code>来访问网页的开头和结尾（和 <code>Vim</code> 编辑器相同）。</p><p>使用 <code>u</code> 和 <code>d</code> 来进行半页的向上、向下滚动。</p><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><p>使用 <code>H</code>、<code>L</code> 来进行页面的后退和前进</p><p>使用 <code>f</code> 来显示当前页面所有可跳转的 URL，选择后在当前页面跳转</p><p>使用 <code>F</code> 来显示当前页面所有可跳转的 URL，选择后在新标签页跳转</p><h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><p>使用 <code>t</code> 来新建标签页</p><p>使用 <code>J</code>（或者 <code>gT</code>）、<code>K</code>（或者 <code>gt</code>）来向左右选择标签页</p><p>使用 <code>x</code> 来关闭标签页</p><p>使用 <code>X</code> 来恢复上一个关闭的标签页</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>使用 <code>o</code> 来在当前页面打开 URL、书签或者历史</p><p>使用 <code>O</code> 来在新标签页打开 URL、书签或者历史</p><p>使用 <code>b</code> 来在当前页面打开书签</p><p>使用 <code>B</code> 来在新标签页打开书签</p><p>使用 <code>T</code> 来在已经打开的页面中搜索</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>使用 <code>/</code> 来进入查找模式</p><p>使用 <code>n</code> 来查看下一个匹配结果</p><p>使用 <code>N</code> 来查看上一个匹配结果</p><h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><p>使用 <code>r</code> 来刷新页面</p><h2 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h2><p>打开插件选项可以看到一系列配置</p><p><code>Excluded URLs and keys</code> 是在指定 URL 排除指定的按键</p><p><code>Custom key mappings</code> 是重新定义按键映射，示例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vimscript">&quot; 这是注释<br># 这也是注释<br><br># 将 j 键映射到向下滚动<br>map j scrollDown<br># 解除 j 键的绑定<br>unmap j<br># 解除所有键的绑定<br>unmapAll<br></code></pre></td></tr></table></figure><p>更多配置请自行探索</p><h2 id="另外的浏览器"><a href="#另外的浏览器" class="headerlink" title="另外的浏览器"></a>另外的浏览器</h2><p>QuteBrowser 同样是用 vim 的思想设计的浏览器，相关资料请移步其<a href="https://qutebrowser.org/">官方网站</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
      <tag>Chrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Cat 命令</title>
    <link href="/2020/07/30/linux-cat/"/>
    <url>/2020/07/30/linux-cat/</url>
    
    <content type="html"><![CDATA[<p>介绍 cat 命令的用法</p><span id="more"></span><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p><code>Linux</code> 中的 <code>cat</code> 命令用于输出文件内容，基础用法如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ([args]) [filename]<br></code></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><table><thead><tr><th align="center">短参数</th><th align="center">长参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>-A</code></td><td align="center"><code>--show-all</code></td><td align="center">等价于 <code>-vET</code></td></tr><tr><td align="center"><code>-b</code></td><td align="center"><code>--number-nonblank</code></td><td align="center">对非空行输出行编号</td></tr><tr><td align="center"><code>-e</code></td><td align="center"></td><td align="center">等价于 <code>-vE</code></td></tr><tr><td align="center"><code>-E</code></td><td align="center"><code>--show-ends</code></td><td align="center">在每行的结束处显示 <code>$</code></td></tr><tr><td align="center"><code>-n</code></td><td align="center"><code>--number</code></td><td align="center">输出所有的行的编号</td></tr><tr><td align="center"><code>-s</code></td><td align="center"><code>--sqeeze-black</code></td><td align="center">不输出多行空行</td></tr><tr><td align="center"><code>-t</code></td><td align="center"></td><td align="center">等价于 <code>-vT</code></td></tr><tr><td align="center"><code>-T</code></td><td align="center"><code>--show-tabs</code></td><td align="center">将跳格字符显示为 <code>^I</code></td></tr><tr><td align="center"><code>-V</code></td><td align="center"><code>--show-nonprinting</code></td><td align="center">使用 <code>^</code> 和 <code>M-</code> 引用，除了 <code>LFD</code> 和 <code>TAB</code> 之外</td></tr></tbody></table><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="输出文件内容"><a href="#输出文件内容" class="headerlink" title="输出文件内容"></a>输出文件内容</h3><p>显示文件 <code>FILE</code> 的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> FILE<br></code></pre></td></tr></table></figure><p>显示文件 <code>FILE</code> 的内容加上行号，需要加上参数 <code>-n</code>。行号从 <code>1</code> 开始。使用 <code>-n</code> 参数时，所有空行也会显示行号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> -n FILE<br></code></pre></td></tr></table></figure><p>忽略掉空行，用 <code>-b</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> -b FILE<br></code></pre></td></tr></table></figure><p>当遇到有连续两行以上的空白行，就代换为一行的空白行，可以使用 <code>-s</code> 参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> -s FILE<br></code></pre></td></tr></table></figure><h3 id="保存内容"><a href="#保存内容" class="headerlink" title="保存内容"></a>保存内容</h3><p>将标准输入保存到文件 <code>FILE</code> 中，如果文件已经存在，则覆盖掉原来的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &gt; FILE<br></code></pre></td></tr></table></figure><p>将标准输入追加到文件 <code>FILE</code> 末尾</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &gt;&gt; FILE<br></code></pre></td></tr></table></figure><h3 id="合并文件"><a href="#合并文件" class="headerlink" title="合并文件"></a>合并文件</h3><p>将两个文件 <code>FILE1</code> 和 <code>FILE2</code> 的内容合并为一个文件 <code>FILE</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> FILE1 FILE2 &gt; FILE<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://my.oschina.net/HJCui/blog/756476">HJCui,HJCui,Linux 中 用 cat 输出文件内容 - HJCui 嘀咕屋,OSCHINA 博客</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim 关闭自动插入注释</title>
    <link href="/2020/07/26/disable-auto-comments-in-vim/"/>
    <url>/2020/07/26/disable-auto-comments-in-vim/</url>
    
    <content type="html"><![CDATA[<p>介绍如何关闭 Vim 编辑器的自动插入注释功能</p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><code>Vim</code> 编辑器下，当你输入了一整行注释</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// This is the comment</span><br></code></pre></td></tr></table></figure><p>再按下回车，<code>Vim</code> 编辑器会自动给你在新的一行加上 <code>//</code>，这在有的时候非常不方便，我希望关闭这一项功能</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在你的 <code>.vimrc</code> 中加入</p><figure class="highlight vim"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">autocmd</span> FileType * <span class="hljs-keyword">setlocal</span> formatoptions-=<span class="hljs-keyword">c</span> formatoptions-=r formatoptions-=<span class="hljs-keyword">o</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://vim.fandom.com/wiki/Disable_automatic_comment_insertion">Disable automatic comment insertion | Vim Tips Wiki | Fandom</a></p><p>给出了更多种解决方案，包括针对单种编程语言</p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美化 PowerShell</title>
    <link href="/2020/07/20/beautify-powershell/"/>
    <url>/2020/07/20/beautify-powershell/</url>
    
    <content type="html"><![CDATA[<p>最近重装了一遍系统，记录一下每次重装系统反复配置的软件，本文记录如何用 oh-my-posh 美化 PowerShell</p><span id="more"></span><h2 id="开放许可"><a href="#开放许可" class="headerlink" title="开放许可"></a>开放许可</h2><p>首次在计算机上启动 <code>Windows PowerShell</code> 时，现用执行策略很可能是 Restricted（默认设置），这个策略是禁止运行任何脚本的，要想打开，只需在<strong>有管理员权限的</strong> <code>PowerShell</code> 下输入 <code>set-executionpolicy remotesigned</code>即可。</p><h2 id="安装-oh-my-posh"><a href="#安装-oh-my-posh" class="headerlink" title="安装 oh-my-posh"></a>安装 oh-my-posh</h2><p>根据 <a href="https://github.com/JanDeDobbeleer/oh-my-posh#installation">oh-my-posh 的说明</a>，执行以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&gt; <span class="hljs-built_in">Install-Module</span> posh<span class="hljs-literal">-git</span> <span class="hljs-literal">-Scope</span> CurrentUser<br>&gt; <span class="hljs-built_in">Install-Module</span> <span class="hljs-built_in">oh</span><span class="hljs-literal">-my-posh</span> <span class="hljs-literal">-Scope</span> CurrentUser<br></code></pre></td></tr></table></figure><p>如果有选项全通过就可以了</p><h2 id="配置-oh-my-posh"><a href="#配置-oh-my-posh" class="headerlink" title="配置 oh-my-posh"></a>配置 oh-my-posh</h2><p>在 powershell 中输入 <code>notepad $PROFILE</code>，用记事本打开配置文件，将如下文本添加到其中即可成功配置。</p><figure class="highlight plaintext"><figcaption><span>posh-git</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershellImport-Module">Import-Module oh-my-posh<br>Set-Theme Paradox<br></code></pre></td></tr></table></figure><h2 id="安装-PowerLine-字体"><a href="#安装-PowerLine-字体" class="headerlink" title="安装 PowerLine 字体"></a>安装 PowerLine 字体</h2><p>此时通过 Windows Terminal 等软件打开会出现无法显示字符的情况，需要从 <a href="https://github.com/microsoft/cascadia-code/releases">microsoft&#x2F;cascadia-code</a> 或者其他途径安装 <code>PowerLine</code> 字体，最后将终端软件（如 <code>Windows Terminal</code> 的字体配置改为你下载的那个字体。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;defaults&quot;</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// Put settings here that you want to apply to all profiles.</span><br>    <span class="hljs-attr">&quot;colorScheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Dracula&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;startingDirectory&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;.&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;fontFace&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Cascadia Mono PL&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>这里推荐一个字体网站 <a href="https://www.nerdfonts.com/">Nerd Fonts</a>，有很多 <code>PowerLine</code> 字体。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/zhaozhan/archive/2012/06/01/2529384.html">PowerShell 因为在此系统中禁止执行脚本解决方法 - Asharp - 博客园</a></p><p><a href="https://github.com/JanDeDobbeleer/oh-my-posh">JanDeDobbeleer&#x2F;oh-my-posh</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows/terminal/tutorials/powerline-setup">Microsoft - 教程：在 Windows 终端中设置 Powerline</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>美化</tag>
      
      <tag>PowerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Travis CI 的构建目录中添加文件</title>
    <link href="/2020/07/19/add-custom-files-in-travisci-building-directory/"/>
    <url>/2020/07/19/add-custom-files-in-travisci-building-directory/</url>
    
    <content type="html"><![CDATA[<p>在 Travis CI 的构建目录中添加文件的方法</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><code>GitHub Pages</code> 中，要自定义域名需要添加一个 <code>CNAME</code> 文件，内容是你的域名，但是 <code>Travis CI</code> 自动构建每次都是把所有文件删除再更新库，每次我都要手动添加 <code>CNAME</code> 文件？所以开始寻找构建目录添加自己的文件的方法</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><code>Travis CI</code> 的构建环境里面有一个环境变量 <code>$TRAVIS_BUILD_DIR</code>，这个环境变量就是构建的文件夹，首先我用 <code>ls</code> 命令查看了该文件夹下的内容，发现是博客 <code>GitHub</code> 仓库的 <code>source</code> 分支的文件</p><p>得出结论：CI 系统把构建目录下的 <code>public</code> 目录部署到 <code>GitHub Pages</code> 的主分支</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在 <code>.travis.yml</code> 文件的 <code>script</code> 项下添加命令即可，本例是 <code>Hexo</code> 的博客，要在生成目录也就是 <code>public</code> 文件夹下添加<code>CNAME</code> 文件，将 <code>script</code> 项改为如下所示即可达到目的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">script:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">&#x27;blog.mazixiang.me&#x27;</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-string">$TRAVIS_BUILD_DIR/public/CNAME</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kb.kutu66.com/travis-ci/post_1642424">emmby - travis-ci - Travis yml，我如何得到 Travis 的工作目录？</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Travis CI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置 Windows Terminal</title>
    <link href="/2020/07/18/configure-windows-terminal/"/>
    <url>/2020/07/18/configure-windows-terminal/</url>
    
    <content type="html"><![CDATA[<p>最近重装了一遍系统，记录一下每次重装系统反复配置的软件，本文记录如何配置与美化 Windows Terminal</p><span id="more"></span><h2 id="打开-Windows-Terminal-配置文件"><a href="#打开-Windows-Terminal-配置文件" class="headerlink" title="打开 Windows Terminal 配置文件"></a>打开 Windows Terminal 配置文件</h2><p>在 <code>Windows Terminal</code> 窗口下按 <code>Ctrl + ,</code> （或者点击新建标签页旁边的向下箭头-设置）来用编辑器打开配置文件，我的电脑中是用 <code>VS Code</code> 打开的</p><h2 id="Dracula-主题"><a href="#Dracula-主题" class="headerlink" title="Dracula 主题"></a>Dracula 主题</h2><p>去 <a href="https://draculatheme.com/windows-terminal">Dracula 主题网站的 Windows Terminal 页面</a>，将主题的配置复制到 <code>schemes</code> 项下面</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;schemes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Dracula&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;background&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#272935&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;black&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#21222C&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;blue&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#BD93F9&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;cyan&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#8BE9FD&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;foreground&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#F8F8F2&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;green&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#50FA7B&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;purple&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#FF79C6&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;red&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#FF5555&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;white&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#F8F8F2&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;yellow&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#FFB86C&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;brightBlack&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#6272A4&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;brightBlue&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#D6ACFF&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;brightCyan&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#A4FFFF&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;brightGreen&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#69FF94&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;brightPurple&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#FF92DF&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;brightRed&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#FF6E6E&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;brightWhite&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#F8F8F2&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;brightYellow&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#FFFFA5&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>之后在 <code>Profiles</code> 中的 <code>defaults</code> 下配置默认主题</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;defaults&quot;</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;colorScheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Dracula&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="添加到右键菜单"><a href="#添加到右键菜单" class="headerlink" title="添加到右键菜单"></a>添加到右键菜单</h2><h3 id="自动添加注册表"><a href="#自动添加注册表" class="headerlink" title="自动添加注册表"></a>自动添加注册表</h3><p>新建 <code>wt.reg</code> 文件，用记事本打开，将如下代码拷贝到其中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reg">Windows Registry Editor Version 5.00<br><br>[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]<br>@=&quot;Windows Terminal Here&quot;<br>&quot;Extended&quot;=&quot;&quot;<br><br>[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\command]<br>@=&quot;C:\\Users\\你的用户名\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;<br></code></pre></td></tr></table></figure><h3 id="手动添加注册表"><a href="#手动添加注册表" class="headerlink" title="手动添加注册表"></a>手动添加注册表</h3><p>按下 <code>Win + R</code> 打开运行，输入 <code>regedit</code> 打开注册表编辑器，找到 <code>HKEY_CLASSES_ROOT\Directory\Background\shell</code>，新建一项（名字随便起，这里叫做 wt）</p><p><img src="https://s1.ax1x.com/2020/07/19/UW3rz4.png" alt="新建 wt 项"></p><p>wt 项的默认值的数据就是右键菜单的文本内容，我将其配置为“通过 Terminal 打开”</p><p>再新建一个字符串值，名称为 <code>Icon</code>，数据是 Windows Terminal 图标的绝对路径（可以通过网上下载到 <code>Windows Terminal</code> 的图标</p><p>我的 wt 项配置如下</p><p><img src="https://s1.ax1x.com/2020/07/19/UW82cQ.png" alt="wt 项配置"></p><div class="note note-primary">            <p>如果想添加快捷键，新建的项默认值是 <code>通过 Terminal 打开 (&amp;T)</code>，其中， <code>&amp;</code> 后面是你想添加的快捷键</p>          </div><p>再在 wt 项下建立 command 项，默认值的数据是到达你的 <code>wt.exe</code> 的绝对路径，一般来说是 <code>C:\Users\[你的用户名]\AppData\Local\Microsoft\WindowsApps\wt.exe</code></p><h2 id="更改启动路径"><a href="#更改启动路径" class="headerlink" title="更改启动路径"></a>更改启动路径</h2><p>经过以上操作，完成了右键菜单的添加，这部分介绍如何更改默认的启动路径</p><p>在配置文件 <code>settings.json</code> 中，<code>Profiles</code> 下面的 <code>defaults</code> 下配置默认启动路径，让每次的启动路径都是右键点击的路径</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;defaults&quot;</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;colorScheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Dracula&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;startingDirectory&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;.&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这样 <code>Windows Terminal</code> 的美化和配置就完成了</p><h2 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h2><p>更多配置信息可以通过 <a href="https://docs.microsoft.com/zh-cn/windows/terminal/">Microsoft - Windows 终端</a> 去了解</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="draculatheme.com">Dracula 主题网站</a></p><p>自动添加注册表</p><p><a href="https://gist.github.com/Garwih/b4ec0d853e0f3093874e919ace7fce2f">Garwih - 将 Windows Terminal 添加到右键菜单</a></p><p>手动添加注册表</p><p><a href="https://blog.csdn.net/u011532601/article/details/106305373">Huelse - 将 Windows Terminal 添加到右键菜单</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows Terminal</tag>
      
      <tag>美化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我安装的 VSCode 插件</title>
    <link href="/2020/07/14/my-vscode-extensions/"/>
    <url>/2020/07/14/my-vscode-extensions/</url>
    
    <content type="html"><![CDATA[<p>我安装的 VSCode 插件及主要功能</p><span id="more"></span><h2 id="功能插件"><a href="#功能插件" class="headerlink" title="功能插件"></a>功能插件</h2><table><thead><tr><th align="center">插件</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=kevinkyang.auto-comment-blocks">Auto Comment Blocks</a></td><td align="center">自动生成注释块</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=aaron-bond.better-comments">Better Comments</a></td><td align="center">代码中的人性化注释，比如警告、质疑、高亮、TODO 等</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer-2">Bracket Pair Colorizer 2</a></td><td align="center">括号颜色高亮</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C&#x2F;C++</a></td><td align="center">C&#x2F;C++语法扩展</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=softwaredotcom.swdc-vscode">Code Time</a></td><td align="center">统计写代码的时间</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=ExodiusStudios.comment-anchors">Comment Anchors</a></td><td align="center">在评论或字符串中放置锚点,从而使导航大型文件更加容易。</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=stackbreak.comment-divider">Comment Divider</a></td><td align="center">快速分隔注释</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=RandomFractalsInc.vscode-data-preview">Data Preview</a></td><td align="center">用表格、文本、图标方式预览 json 等数据文件</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=docsmsft.docs-markdown">docs-markdown</a></td><td align="center">Markdown 写作帮助</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">ESLint</a></td><td align="center">ECMAScript 代码提示</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph">Git Graph</a></td><td align="center">Git 可视化显示</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens">GitLens</a></td><td align="center">Git 加强</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.jshint">jshint</a></td><td align="center">JavaScript 语言提示</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer">Live Server</a></td><td align="center">实时预览 Web 页面</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=MS-vsliveshare.vsliveshare">Live Share</a></td><td align="center">共享代码</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">Markdown All in One</a></td><td align="center">Markdown 写作工具</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced">Markdown Preview Enhanced</a></td><td align="center">更强力的 Markdown 预览</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint">markdownlint</a></td><td align="center">Markdown 写作提示</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense">npm Intellisense</a></td><td align="center">可自动完成导入语句中的 npm 模块</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense">Path Intellisense</a></td><td align="center">路径自动补全</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=pnp.polacode">Polacode</a></td><td align="center">将代码转换为图片</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">Prettier</a></td><td align="center">前端代码美化工具</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh">Remote - SSH</a></td><td align="center">SSH 远程开发</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl">Remote - WSL</a></td><td align="center">WSL 开发</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">Rust</a></td><td align="center">Rust 语言工具</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=Remisa.shellman">shellman</a></td><td align="center">Shell 脚本自动补全</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=Gruntfuggly.todo-tree">Todo Tree</a></td><td align="center">快速查看代码中的 TODO</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=shardulm94.trailing-spaces">Trailing Spaces</a></td><td align="center">突出显示代码后面多余的空格</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=WASTeamAccount.WebTemplateStudio-dev-nightly">Web Template Studio</a></td><td align="center">互联网应用框架脚手架，会捆绑安装 Azure 相关插件</td></tr></tbody></table><h2 id="主题插件"><a href="#主题插件" class="headerlink" title="主题插件"></a>主题插件</h2><table><thead><tr><th align="center">插件</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=dracula-theme.theme-dracula">Dracula Official</a></td><td align="center">Dracula 主题</td></tr><tr><td align="center"><a href="https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme">Material Icon Theme</a></td><td align="center">Material 图标风格</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一个 ns3 脚本</title>
    <link href="/2020/06/28/first-ns3-script/"/>
    <url>/2020/06/28/first-ns3-script/</url>
    
    <content type="html"><![CDATA[<p>你的第一个 ns3 脚本</p><span id="more"></span><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>这个脚本是 <code>ns-*/examples/first.cc</code>，是官方示例，本文对于这个脚本进行讲解，大部分是 Google 翻译的，来源见<a href="#%E5%8F%82%E8%80%83">参考</a></p><p>本文的 <code>ns3</code> 版本为 3.30.1，<strong>不同版本的脚本可能会不相同</strong>，请参考官方的最新文档</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>请确认你已经完成了 <code>./waf -d debug --enable-examples --enable-tests configure</code></p><p>为了配置项目以执行包含示例和测试的调试版本。还需要执行 <code>./waf</code> 来建立项目。因此，现在如果您查看目录 <code>../../build/debug/ns3</code>，您将找到<a href="#%E6%A8%A1%E5%9D%97%E5%8C%85%E5%90%AB">模块包含</a>中的四个模块包含文件。您可以查看这些文件的内容，发现它们确实在其各自的模块中包含了所有公共包含文件。</p><h2 id="模块包含"><a href="#模块包含" class="headerlink" title="模块包含"></a>模块包含</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ns3/core-module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ns3/network-module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ns3/internet-module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ns3/point-to-point-module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ns3/applications-module.h&quot;</span></span><br></code></pre></td></tr></table></figure><p>为了帮助我们的高级脚本用户处理系统中存在的大量包含文件，我们根据相对较大的模块对包含进行分组。我们提供了一个包含文件，该文件将递归加载每个模块中使用的所有包含文件。不必精确地查找所需的头文件，也不必正确地获取许多依赖关系，而是使您能够以较大的粒度加载一组文件。这不是最有效的方法，但是它无疑使编写脚本变得更加容易。</p><p>在构建过程中，每个 ns3 包含文件都放置在一个名为 <code>ns3</code> 的目录中（在构建目录下），以帮助避免包含文件名冲突。<code>ns3/core-module.h</code>文件与 ns3 模块相对应，您可以在下载的发行版本的 <code>src/core</code> 目录中找到该文件。如果列出此目录，则会发现大量的头文件。进行构建时，<code>Waf</code> 会根据您的配置将公共头文件放在相应的 <code>build/debug</code> 或 <code>build/optimized</code> 目录下的 <code>ns3</code> 目录中。<code>Waf</code> 还将自动生成一个模块包含文件，以加载所有公共头文件。</p><h2 id="ns3-命名空间"><a href="#ns3-命名空间" class="headerlink" title="ns3 命名空间"></a>ns3 命名空间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ns3;<br></code></pre></td></tr></table></figure><p><code>ns3</code> 的实现是在 <code>ns3</code> 的命名空间实现的，所以先导入命名空间，之后就不使用复杂的 <code>ns3::</code> 了。如果你不明白这个请参考 c++ 的 <code>using namespace std;</code></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">NS_LOG_COMPONENT_DEFINE</span> (<span class="hljs-string">&quot;FirstScriptExample&quot;</span>);<br></code></pre></td></tr></table></figure><p>可以查阅官方文档来了解函数的作用，这条语句是通过引用特定名称来启用和禁用控制台消息日志记录</p><h2 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h2><p>首先声明 main 函数，就像其他的 c++ 文件一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span></span><br><span class="hljs-function"><span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br></code></pre></td></tr></table></figure><p>将时间分辨率设置为 1 纳秒，同时 1 纳秒也是默认值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Time::<span class="hljs-built_in">SetResolution</span> (Time::NS);<br></code></pre></td></tr></table></figure><p>分辨率是可以表示的最小时间值（以及两个时间值之间的最小可表示差异）。您可以只更改一次分辨率。实现这种灵活性的机制有点占用内存，因此，在明确设置分辨率后，我们将释放内存，以防止进一步的更新。（如果未明确设置分辨率，则默认为一纳秒，并且在模拟开始时会释放内存。）</p><p>下两行用于启用 <code>Echo Client</code> 和 <code>Echo Server</code> 应用程序中内置的两个日志记录组件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">LogComponentEnable</span>(<span class="hljs-string">&quot;UdpEchoClientApplication&quot;</span>, LOG_LEVEL_INFO);<br><span class="hljs-built_in">LogComponentEnable</span>(<span class="hljs-string">&quot;UdpEchoServerApplication&quot;</span>, LOG_LEVEL_INFO);<br></code></pre></td></tr></table></figure><p>如果阅读了日志记录组件文档，会发现可以在每个组件上启用许多级别的日志记录详细程度&#x2F;详细信息。这两行代码为回显客户端和服务器启用了 INFO 级别的调试日志记录。这将让应用程序在仿真期间发送和接收数据包时打印出消息。</p><p>接下来，我们将直接从事创建拓扑和运行仿真的工作。我们使用拓扑帮助器对象使这项工作尽可能容易。</p><h2 id="拓补助手"><a href="#拓补助手" class="headerlink" title="拓补助手"></a>拓补助手</h2><h3 id="NodeContainer"><a href="#NodeContainer" class="headerlink" title="NodeContainer"></a>NodeContainer</h3><p>接下来两行代码实际上将创建 ns-3 Node 对象，该对象代表模拟中的计算机。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">NodeContainer nodes;<br>nodes.<span class="hljs-built_in">Create</span> (<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>在继续之前，让我们找到 <code>NodeContainer</code> 类的文档。进入给定类的文档的另一种方法是通过 <code>Doxygen</code> 页面中的 <code>Classes</code> 选项卡。应该看到出现了一组新的选项卡，其中一个是“类列表”。在该选项卡下，您将看到所有 ns-3 类的列表。向下滚动，找到 <code>ns3::NodeContainer</code>。</p><p>节点是我们的关键抽象之一。这表示一类的计算机，我们将向其中添加协议栈，应用程序和外围设备卡。<code>NodeContainer</code> 拓扑帮助器提供了一种方便的方法来创建，管理和访问我们为运行模拟而创建的任何 <code>Node</code> 对象。上面的第一行只声明了一个 <code>NodeContainer</code>，我们称之为节点。第二行在节点对象上调用 <code>Create</code> 方法，并要求容器创建两个节点。如文档中所述，这个容器将调用 <code>ns3</code> 系统，以适当地创建两个 <code>Node</code> 对象，并在内部存储指向这些对象的指针。</p><p>脚本中的节点不执行任何操作。构建拓扑的下一步是将我们的节点连接到网络中。我们支持的最简单的网络形式是两个节点之间的单点对点链接。我们将在此处构建这些链接之一。</p><h3 id="PointToPointHelper"><a href="#PointToPointHelper" class="headerlink" title="PointToPointHelper"></a>PointToPointHelper</h3><p>我们正在以一种您会非常熟悉的模式构建点对点连接，使用拓扑帮助器对象来完成将链接放在一起所需的低级工作。回想一下，我们的两个关键抽象是 <code>NetDevice</code> 和 <code>Channel</code>。在现实世界中，这些术语大致对应于外围卡和网络电缆。通常，这两件事紧密地绑在一起，不能互换，例如，以太网设备和无线通道。我们的拓扑助手遵循这种紧密的联系，因此您将使用单个 <code>PointToPointHelper</code> 在此脚本中配置和连接 <code>ns-3 PointToPointNetDevice</code> 和 <code>PointToPointChannel</code> 对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">PointToPointHelper pointToPoint;<br>pointToPoint.<span class="hljs-built_in">SetDeviceAttribute</span> (<span class="hljs-string">&quot;DataRate&quot;</span>, <span class="hljs-built_in">StringValue</span> (<span class="hljs-string">&quot;5Mbps&quot;</span>));<br>pointToPoint.<span class="hljs-built_in">SetChannelAttribute</span> (<span class="hljs-string">&quot;Delay&quot;</span>, <span class="hljs-built_in">StringValue</span> (<span class="hljs-string">&quot;2ms&quot;</span>));<br></code></pre></td></tr></table></figure><p>第一行，实例化堆栈上的 <code>PointToPointHelper</code> 对象。</p><p>第二行，告诉 <code>PointToPointHelper</code> 对象在创建 <code>PointToPointNetDevice</code> 对象时将值“5Mbps”（每秒 5 兆位）用作 <code>DataRate</code>。</p><p>从更详细的角度来看，字符串 <code>DataRate</code> 对应于我们所谓的 <code>PointToPointNetDevice</code> 的 <code>Attribute</code>。如果查看类 <code>ns3::PointToPointNetDevice</code> 的文档并找到 <code>GetTypeId</code> 方法的文档，则会找到为设备定义的属性列表。其中包括 <code>DataRate</code> 属性。大多数用户可见的 <code>ns3</code> 对象都有相似的属性列表。我们将使用此机制轻松配置仿真而无需重新编译。</p><p>第三行就是指定延迟属性，告诉 <code>PointToPointHelper</code> 使用值“2ms”（两毫秒）作为其随后创建的每个点对点通道的传播延迟的值。</p><h3 id="NetDeviceContainer"><a href="#NetDeviceContainer" class="headerlink" title="NetDeviceContainer"></a>NetDeviceContainer</h3><p>在脚本的这一点上，我们有一个包含两个节点的 <code>NodeContainer</code>。我们有一个准备好的 <code>PointToPointHelper</code>，可以用来制作 <code>PointToPointNetDevices</code> 并在它们之间连接 <code>PointToPointChannel</code> 对象。就像我们使用 <code>NodeContainer</code> 拓扑帮助对象创建用于仿真的节点一样，我们将要求 <code>PointToPointHelper</code> 完成为我们创建，配置和安装设备的工作。我们将需要具有所有已创建的 <code>NetDevice</code> 对象的列表，因此我们使用 <code>NetDeviceContainer</code> 来保存它们，就像使用 <code>NodeContainer</code> 来保存所创建的节点一样。以下两行代码，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">NetDeviceContainer devices;<br>devices = pointToPoint.<span class="hljs-built_in">Install</span> (nodes);<br></code></pre></td></tr></table></figure><p>将完成设备和通道的配置。第一行声明上述设备容器，第二行进行繁重的操作。<code>PointToPointHelper</code> 的 <code>Install</code> 方法将 <code>NodeContainer</code> 作为参数。在内部，将创建一个 <code>NetDeviceContainer</code>。对于 <code>NodeContainer</code> 中的每个节点（点对点链接必须恰好有两个），将创建一个 <code>PointToPointNetDevice</code> 并将其保存在设备容器中。创建一个 <code>PointToPointChannel</code> 并连接了两个 <code>PointToPointNetDevices</code>。当由 <code>PointToPointHelper</code> 创建对象时，先前在帮助器中设置的属性用于初始化创建的对象中的相应属性。</p><p>执行 <code>pointToPoint.Install (nodes)</code> 调用之后，我们将有两个节点，每个节点都具有一个已安装的点对点网络设备以及它们之间的单个点对点通道。两个设备都将配置为以每秒 5 兆位的速度在具有 2 毫秒传输延迟的通道上传输数据。</p><h3 id="InternetStackHelper"><a href="#InternetStackHelper" class="headerlink" title="InternetStackHelper"></a>InternetStackHelper</h3><p>现在，我们已经配置了节点和设备，但是我们的节点上没有安装任何协议栈。接下来的两行代码将解决这一问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">InternetStackHelper stack;<br>stack.<span class="hljs-built_in">Install</span> (nodes);<br></code></pre></td></tr></table></figure><p><code>InternetStackHelper</code> 是一个拓扑帮助程序，它用于 <code>Internet</code> 堆栈，而 <code>PointToPointHelper</code> 则是点对点网络设备。<code>Install</code> 方法将 <code>NodeContainer</code> 作为参数。执行后，它将在节点容器中的每个节点上安装 Internet 堆栈（TCP，UDP，IP 等）。</p><h3 id="Ipv4AddressHelper"><a href="#Ipv4AddressHelper" class="headerlink" title="Ipv4AddressHelper"></a>Ipv4AddressHelper</h3><p>接下来，我们需要将节点上的设备与 IP 地址相关联。我们提供了一个拓扑助手来管理 IP 地址的分配。唯一用户可见的 API 是设置在执行实际地址分配时使用的基本 IP 地址和网络掩码（这是在助手内部的较低级别完成的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Ipv4AddressHelper address;<br>address.<span class="hljs-built_in">SetBase</span> (<span class="hljs-string">&quot;10.1.1.0&quot;</span>, <span class="hljs-string">&quot;255.255.255.0&quot;</span>);<br>Ipv4InterfaceContainer interfaces = address.<span class="hljs-built_in">Assign</span> (devices);<br></code></pre></td></tr></table></figure><p>声明一个 <code>Ipv4AddressHelper</code> 对象，并告诉它应该开始使用掩码 <code>255.255.255.0</code> 从网络 <code>10.1.1.0</code> 分配 IP 地址，以定义可分配的位。默认情况下，分配的地址将从 1 开始并单调增加，因此从该基址分配的第一个地址将是 <code>10.1.1.1</code>，然后是 <code>10.1.1.2</code>，依此类推。底层 <code>ns3</code> 系统实际上会记住分配的所有 IP 地址，如果您不小心使同一地址产生两次，将会产生致命错误（顺便说一句，这很难调试）。</p><p>下一行，执行实际的地址分配。在 <code>ns3</code> 中，我们使用 <code>Ipv4Interface</code> 对象在 IP 地址和设备之间建立关联。就像有时我们需要由助手创建的网络设备列表以供将来参考时，有时我们也需要 <code>Ipv4Interface</code> 对象的列表。<code>Ipv4InterfaceContainer</code> 提供了此功能。</p><p>现在，我们已经建立了一个点对点网络，安装了堆栈并分配了 IP 地址。此时，我们需要生成流量的应用程序。</p><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><p>ns3 系统的另一个核心抽象是应用程序。在此脚本中，我们使用 ns3 核心应用程序类 <code>UdpEchoServerApplication</code> 和 <code>UdpEchoClientApplication</code> 的两个特化。就像前面的解释一样，我们使用辅助对象来帮助配置和管理基础对象。在这里，我们使用 <code>UdpEchoServerHelper</code> 和 <code>UdpEchoClientHelper</code> 对象来让模拟更简单。</p><h3 id="UdpEchoServerHelper"><a href="#UdpEchoServerHelper" class="headerlink" title="UdpEchoServerHelper"></a>UdpEchoServerHelper</h3><p>示例脚本 <code>first.cc</code> 中的以下代码行用于在我们先前创建的节点之一上设置 UDP 回显服务器应用程序（Udp echo server application）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">UdpEchoServerHelper <span class="hljs-title">echoServer</span> <span class="hljs-params">(<span class="hljs-number">9</span>)</span></span>;<br><br>ApplicationContainer serverApps = echoServer.<span class="hljs-built_in">Install</span> (nodes.<span class="hljs-built_in">Get</span> (<span class="hljs-number">1</span>));<br>serverApps.<span class="hljs-built_in">Start</span> (<span class="hljs-built_in">Seconds</span> (<span class="hljs-number">1.0</span>));<br>serverApps.<span class="hljs-built_in">Stop</span> (<span class="hljs-built_in">Seconds</span> (<span class="hljs-number">10.0</span>));<br></code></pre></td></tr></table></figure><p>上面代码段的第一行代码声明了 <code>UdpEchoServerHelper</code>。和往常一样，这不是应用程序本身，而是用于帮助我们创建实际应用程序的对象。我们的约定之一是将必需的属性放在辅助构造函数中。在这种情况下，除非提供了客户端也知道端口号，否则该帮助程序将无济于事。我们需要将端口号作为构造函数的参数，而不是只是选择一个并希望一切都能解决。反过来，构造函数只对传递的值执行 <code>SetAttribute</code>。如果需要，可以稍后使用 <code>SetAttribute</code> 将 <code>Port</code> 属性设置为另一个值。</p><p>与许多其他帮助器对象相似，<code>UdpEchoServerHelper</code> 对象具有 <code>Install</code> 方法。正是此方法的执行实际上导致实例化基础回显服务器应用程序并将其附加到节点。有趣的是，就像我们已经看到的其他 <code>Install</code> 方法一样，<code>Install</code> 方法将 <code>NodeContainter</code> 作为参数。这实际上是传递给方法的内容，即使在这种情况下看起来也不是这样。这里有一个 C++隐式转换正在工作，该转换获取 <code>node.Get(1)</code>的结果（返回指向节点对象的智能指针— <code>Ptr &lt;Node&gt;</code>），并将其用于构造函数中，然后传递给未命名的 <code>NodeContainer</code>。安装。如果您不知所措地在 C++代码中找到了可以编译并运行得很好的特定方法签名，请寻找这些隐式转换。</p><p>现在，我们看到 <code>echoServer.Install</code> 将在用于管理节点的 <code>NodeContainer</code> 的索引号为 1 的节点上安装 <code>UdpEchoServerApplication</code>。<code>Install</code> 将返回一个容器，该容器保存由助手创建的所有应用程序的指针（在本例中，因为我们传递了一个包含一个节点的 <code>NodeContainer</code>，所以指向一个应用程序）。</p><p>应用程序需要一些时间来“开始”生成流量，并且可能需要花费一些时间来“停止”。我们都提供。这些时间是使用 <code>ApplicationContainer</code> 方法 <code>Start</code> 和 <code>Stop</code> 设置的。这些方法采用时间参数。在这种情况下，我们使用显式的 C++ 转换序列获取 C++ 浮点数 1.0，并使用 <code>Seconds</code> 强制转换将其转换为 <code>ns3</code> 的 <code>Time</code>对象。请注意，转换规则可能由模型作者控制，并且 C++ 有其自己的规则，因此您不能总是仅假设参数将为您自动地转换。</p><p>第四行和第五行将导致回显服务器应用程序在仿真中的一秒钟启动（启用自身），并在仿真中的十秒钟停止（禁用自身）。由于我们已经声明了要在十秒执行的模拟事件（应用程序停止事件），因此模拟将至少持续十秒钟。</p><h3 id="UdpEchoClientHelper"><a href="#UdpEchoClientHelper" class="headerlink" title="UdpEchoClientHelper"></a>UdpEchoClientHelper</h3><p>回显客户端应用程序的建立方法与服务器类似。有一个由 <code>UdpEchoClientHelper</code> 管理的基础<code>UdpEchoClientApplication</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">UdpEchoClientHelper <span class="hljs-title">echoClient</span> <span class="hljs-params">(interfaces.GetAddress (<span class="hljs-number">1</span>), <span class="hljs-number">9</span>)</span></span>;<br>echoClient.<span class="hljs-built_in">SetAttribute</span> (<span class="hljs-string">&quot;MaxPackets&quot;</span>, <span class="hljs-built_in">UintegerValue</span> (<span class="hljs-number">1</span>));<br>echoClient.<span class="hljs-built_in">SetAttribute</span> (<span class="hljs-string">&quot;Interval&quot;</span>, <span class="hljs-built_in">TimeValue</span> (<span class="hljs-built_in">Seconds</span> (<span class="hljs-number">1.0</span>)));<br>echoClient.<span class="hljs-built_in">SetAttribute</span> (<span class="hljs-string">&quot;PacketSize&quot;</span>, <span class="hljs-built_in">UintegerValue</span> (<span class="hljs-number">1024</span>));<br><br>ApplicationContainer clientApps = echoClient.<span class="hljs-built_in">Install</span> (nodes.<span class="hljs-built_in">Get</span> (<span class="hljs-number">0</span>));<br>clientApps.<span class="hljs-built_in">Start</span> (<span class="hljs-built_in">Seconds</span> (<span class="hljs-number">2.0</span>));<br>clientApps.<span class="hljs-built_in">Stop</span> (<span class="hljs-built_in">Seconds</span> (<span class="hljs-number">10.0</span>));<br></code></pre></td></tr></table></figure><p>但是，对于回显应用程序的客户端，我们需要设置五个不同的属性。前两个属性是在构造 <code>UdpEchoClientHelper</code> 时设置的。我们将传递的参数（用于内部）传递给助手，以根据我们的约定设置 <code>RemoteAddress</code> 和 <code>RemotePort</code> 属性，以在助手构造函数中创建所需的 <code>Attributes</code> 参数。</p><p>我们已经使用了 <code>Ipv4InterfaceContainer</code> 来跟踪分配给设备的 IP 地址。接口容器中的第 0 个接口将与节点容器中的第 0 个节点的 IP 地址相对应。接口容器中的第一接口对应于节点容器中第一节点的 IP 地址。因此，在第一行代码中（从上面开始），我们正在创建帮助程序并告诉它，因此将客户端的远程地址设置为分配给服务器所在节点的 IP 地址。我们还告诉它安排将数据包发送到端口 9。</p><p><code>MaxPackets</code> 属性告诉客户端我们允许其在模拟过程中发送的最大数据包数。<code>Interval</code> 属性告诉客户端在数据包之间等待多长时间，<code>PacketSize</code> 属性告诉客户端其数据包有效载荷应该有多大。通过这种特殊的属性组合，我们告诉客户端发送一个 1024 字节的数据包。</p><p>与回显服务器端一样，我们告诉回显客户端启动和停止，但是在这里，我们在启用服务器后一秒钟（在仿真两秒钟后）启动客户端。</p><h2 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h2><p>此时，我们需要做的是实际运行仿真。这是使用全局函数 <code>Simulator::Run</code> 完成的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Simulator::<span class="hljs-built_in">Run</span> ();<br></code></pre></td></tr></table></figure><p>当我们之前调用方法 <code>serverApps.Start</code> <code>serverApps.Stop</code> <code>clientApps.Start</code> <code>clientApps.Stop</code> 时，我们实际上将模拟器中的事件开始时间安排为 1.0 秒，2.0 秒，将两个事件安排为 10.0 秒。调用 <code>Simulator::Run</code> 时，系统将开始浏览预定事件列表并执行它们。首先，它将在 1.0 秒处运行事件，这将启用回显服务器应用程序（此事件可能进而安排许多其他事件）。然后它将运行安排在 t &#x3D; 2.0 秒内的事件，这将启动回显客户端应用程序。同样，此事件可以安排更多事件。回显客户端应用程序中的开始事件实现将通过向服务器发送数据包来开始模拟的数据传输阶段。</p><p>将数据包发送到服务器的操作将触发一系列事件，这些事件将在后台自动安排，并将根据我们在脚本中设置的各种定时参数执行数据包回显的机制。</p><p>最终，由于我们只发送一个数据包（将 <code>MaxPackets</code> 属性设置为一个），因此由单个客户端回显请求触发的事件链将逐渐减少，并且模拟将进入空闲状态。一旦发生这种情况，剩下的事件将是服务器和客户端的 <code>Stop</code> 事件。当执行这些事件时，没有其他事件可处理，并且 <code>Simulator::Run</code> 返回。仿真完成。</p><p>剩下的就是清理。这是通过调用全局函数 <code>Simulator::Destroy</code> 来完成的。在执行辅助函数（或低级 <code>ns3</code> 代码）时，他们进行了排列，以便将钩子插入模拟器中以销毁所有已创建的对象。您不必自己跟踪任何这些对象-您要做的就是调用 <code>Simulator::Destroy</code> 并退出。<code>ns3</code> 系统为您处理了最困难的部分。我们第一个 <code>ns3</code> 脚本剩余的行 first.cc 就是这样做的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">  Simulator::<span class="hljs-built_in">Destroy</span> ();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模拟器什么时候会停止"><a href="#模拟器什么时候会停止" class="headerlink" title="模拟器什么时候会停止"></a>模拟器什么时候会停止</h2><p><code>ns3</code> 是离散事件（DE）模拟器。在这种模拟器中，每个事件都与其执行时间相关联，并且通过以模拟时间的时间顺序执行事件来进行模拟。事件可能会导致安排将来的事件（例如，计时器可能会将自己重新安排为在下一个时间间隔到期）。</p><p>初始事件通常由每个对象触发，例如，IPv6 将调度路由器广告，邻居请求等，应用程序调度第一个数据包发送事件等。</p><p>处理事件时，它可能会生成零个，一个或多个事件。在执行模拟时，将消耗事件，但是可能会（或可能不会）生成更多事件。当事件队列中没有其他事件时，或者发现特殊的 Stop 事件时，模拟将自动停止。<code>Stop</code> 事件是通过<code>Simulator::Stop(stopTime);</code>函数创建的。</p><p>在典型情况下，必须使用 <code>Simulator::Stop</code> 来停止模拟：发生自持事件时。自我维持（或重复发生）的事件是总是自行重新安排时间的事件。因此，它们始终将事件队列保持为非空。</p><p>有许多包含重复事件的协议和模块，例如：</p><ul><li>FlowMonitor-定期检查丢失的数据包</li><li>RIPng-定期广播路由表更新</li></ul><p>在这些情况下，必须使用 <code>Simulator::Stop</code> 才能正常停止模拟。另外，当 <code>ns3</code> 处于仿真模式时，使用 <code>RealtimeSimulator</code> 来使仿真时钟与机器时钟保持一致，并且 <code>Simulator::Stop</code> 是停止该过程所必需的。</p><p>本教程中的许多仿真程序都未明确调用 <code>Simulator::Stop</code>，因为事件队列将自动用尽事件。但是，这些程序还将接受对 <code>Simulator::Stop</code> 的调用。例如，第一个示例程序中的以下附加语句将安排在 11 秒时显式停止：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">+  Simulator::<span class="hljs-built_in">Stop</span> (<span class="hljs-built_in">Seconds</span> (<span class="hljs-number">11.0</span>));<br>   Simulator::<span class="hljs-built_in">Run</span> ();<br>   Simulator::<span class="hljs-built_in">Destroy</span> ();<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>上面的内容实际上不会改变此程序的行为，因为此特定的模拟自然会在 10 秒后结束。但是，如果要将以上语句中的停止时间从 11 秒更改为 1 秒，您会注意到模拟会在任何输出打印到屏幕之前停止（因为输出发生在模拟时间的 2 秒左右）。</p><p>重要的是在调用 <code>Simulator::Run</code> 之前先调用 <code>Simulator::Stop</code>否则，<code>Simulator::Run</code> 可能永远不会将控制权返回给主程序以执行停止！</p><h2 id="构建你的脚本"><a href="#构建你的脚本" class="headerlink" title="构建你的脚本"></a>构建你的脚本</h2><p>构建简单的脚本非常简单。您所要做的就是将脚本放到临时目录中，如果您运行 Waf，它将自动生成。试试吧切换回顶层目录后，将 <code>examples/tutorial/first.cc</code> 复制到 <code>scratch</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cp</span> examples/tutorial/first.cc scratch/myfirst.cc<br></code></pre></td></tr></table></figure><p>现在使用 waf 构建第一个示例脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./waf<br>Waf: Entering directory `/home/craigdo/repos/ns-3-allinone/ns-3-dev/build<span class="hljs-string">&#x27;</span><br><span class="hljs-string">[614/708] cxx: scratch/myfirst.cc -&gt; build/debug/scratch/myfirst_3.o</span><br><span class="hljs-string">[706/708] cxx_link: build/debug/scratch/myfirst_3.o -&gt; build/debug/scratch/myfirst</span><br><span class="hljs-string">Waf: Leaving directory `/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&#x27;</span><br><span class="hljs-string">&#x27;build&#x27;</span> finished successfully (2.357s)<br></code></pre></td></tr></table></figure><p>现在，您可以运行该示例（请注意，如果在 <code>scratch</code> 目录中构建程序，则必须在 <code>scratch</code> 目录<strong>外</strong>运行该程序）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./waf --run scratch/myfirst<br>Waf: Entering directory `/home/craigdo/repos/ns-3-allinone/ns-3-dev/build<span class="hljs-string">&#x27;</span><br><span class="hljs-string">Waf: Leaving directory `/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&#x27;</span><br><span class="hljs-string">&#x27;build&#x27;</span> finished successfully (0.418s)<br>Sent 1024 bytes to 10.1.1.2<br>Received 1024 bytes from 10.1.1.1<br>Received 1024 bytes from 10.1.1.2<br></code></pre></td></tr></table></figure><p>在这里，您会看到构建系统检查以确保已构建文件，然后运行它。您会看到 echo 客户端上的日志记录组件表明它已向 10.1.1.2 上的 Echo Server 发送了一个 1024 字节的数据包。您还可以看到回显服务器上的日志记录组件说它已从 10.1.1.1 接收到 1024 个字节。回显服务器以静默方式回显数据包，您会看到回显客户端日志，它已从服务器接收回数据包。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.nsnam.org/docs/release/3.30/tutorial/html/conceptual-overview.html#a-first-ns-3-script">Conceptual Overview — Tutorial</a></p><p><a href="https://blog.51cto.com/3240611/1641583">NS-3 入门[2]脚本与编译运行-针挑土-51CTO 博客</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>ns3 网络模拟软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>停止和删除 docker 所有的容器和镜像</title>
    <link href="/2020/06/27/stop-and-remove-all-docker-containers-and-images/"/>
    <url>/2020/06/27/stop-and-remove-all-docker-containers-and-images/</url>
    
    <content type="html"><![CDATA[<p>停止和删除 docker 所有的容器和镜像的简单方法，一句命令</p><span id="more"></span><h2 id="停止所有-Docker-容器"><a href="#停止所有-Docker-容器" class="headerlink" title="停止所有 Docker 容器"></a>停止所有 Docker 容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker stop $(docker ps -aq)<br><span class="hljs-comment"># 你的所有 Docker 容器的 ID</span><br></code></pre></td></tr></table></figure><p>其中 <code>docker ps -aq</code> 的作用是列出所有 <code>Docker</code> 容器的 ID</p><h2 id="删除所有-Docker-容器"><a href="#删除所有-Docker-容器" class="headerlink" title="删除所有 Docker 容器"></a>删除所有 Docker 容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">rm</span> $(docker ps -aq)<br><span class="hljs-comment"># 你的所有 Docker 容器的 ID</span><br></code></pre></td></tr></table></figure><h2 id="删除所有-Docker-镜像"><a href="#删除所有-Docker-镜像" class="headerlink" title="删除所有 Docker 镜像"></a>删除所有 Docker 镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker rmi $(docker images -aq)<br><span class="hljs-comment"># 你的所有 Docker 镜像的 ID</span><br></code></pre></td></tr></table></figure><p>其中 <code>docker images -aq</code> 的作用是列出所有 <code>Docker</code> 镜像的 ID</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://colobu.com/2018/05/15/Stop-and-remove-all-docker-containers-and-images/">停止、删除所有的 docker 容器和镜像 | 鸟窝</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ns3 网络模拟软件的安装和起步</title>
    <link href="/2020/06/24/ns3-getting-start/"/>
    <url>/2020/06/24/ns3-getting-start/</url>
    
    <content type="html"><![CDATA[<p>ns3 网络模拟软件的安装和使用</p><span id="more"></span><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>运行 <code>ns3</code> 需要安装 <code>Linux</code> 虚拟机或者是 <code>WSL</code>，Windows 无法直接跑，本文中使用 <code>VMWare Workstation 15.5</code> 的 <code>Ubuntu 20.04LTS</code> 为环境，其他 <code>Linux</code> 发行版本大同小异，请前往参考中的官网文档</p><p>建议用 <code>WSL</code> 跑，虚拟机会消耗一些性能</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先，进入<a href="https://www.nsnam.org/releases/">ns 的 release 网页（官方）</a></p><p><img src="https://s1.ax1x.com/2020/06/24/Nwenq1.png" alt="website"></p><p>下载最新版本的 tar 包，传入虚拟机中，使用 <code>tar -xvf</code> 命令解压文件，得到文件夹，我的是 <code>ns-allinone-3.30.1</code></p><h2 id="使用-apt-安装依赖"><a href="#使用-apt-安装依赖" class="headerlink" title="使用 apt 安装依赖"></a>使用 apt 安装依赖</h2><p>首先使用以下命令安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt install g++ python3<br>...<br>g++ is already the newest version (4:9.3.0-1ubuntu2).<br>python3 is already the newest version (3.8.2-0ubuntu2).<br>0 upgraded, 0 newly installed, 0 to remove and 9 not upgraded.<br></code></pre></td></tr></table></figure><p><code>Ununtu 20.04LTS</code> 版本中已经安装好了 <code>g++</code> 和 <code>Python3</code></p><h2 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h2><p>确保工作目录是在 <code>ns-allinone-3.30.1</code> 下，在命令行中执行如下命令开始构建，时间可能会很长，请耐心等待。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./build.py --enable-tests --enable-examples<br>...<br>Leaving directory `./ns-3.30.1<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p>得到以下输出，说明构建成功</p><p><img src="https://s1.ax1x.com/2020/06/24/Nwmb9S.jpg" alt="构建成功"></p><p>如果失败，请删除文件夹重新再来一遍（我就是这么做的，重来了几遍，最后可以正常运行了）</p><h2 id="进一步构建"><a href="#进一步构建" class="headerlink" title="进一步构建"></a>进一步构建</h2><p>据官方文档所说，上一步是构建好运行时需要的库，这一步是进行真实构建。</p><p>切换工作目录到文件夹中的 <code>ns-*</code> 目录（我的是 <code>ns-3.30.1</code>），在命令行中执行如下命令，向 Waf 解释它应该进行包括示例和测试的优化构建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./waf clean<br><span class="hljs-string">&#x27;clean&#x27;</span> finished successfully (0.398s)<br>$ ./waf configure --build-profile=optimized --enable-examples --enable-tests<br>...<br><span class="hljs-string">&#x27;configure&#x27;</span> finished successfully (2.899s)<br></code></pre></td></tr></table></figure><p>切换回包含示例和测试的调试（debug）版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./waf clean<br>$ ./waf configure --build-profile=debug --enable-examples --enable-tests<br>...<br><span class="hljs-string">&#x27;configure&#x27;</span> finished successfully (2.618s)<br></code></pre></td></tr></table></figure><p>开始构建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./waf<br>...<br><span class="hljs-string">&#x27;build&#x27;</span> finished successfully (20m15.146s)<br>...<br></code></pre></td></tr></table></figure><p>如果出现了下图的结果，说明构建成功</p><p><img src="https://s1.ax1x.com/2020/06/24/NwuTSS.jpg" alt="进一步构建成功"></p><h2 id="测试-ns3（可跳过）"><a href="#测试-ns3（可跳过）" class="headerlink" title="测试 ns3（可跳过）"></a>测试 ns3（可跳过）</h2><p>命令行中执行 <code>./test.py</code> 来运行测试脚本，出现一大堆 <code>PASS</code> 说明测试成功（图就不放了，太大了）</p><p>这个时间很长，如果没耐心可以跳过，基本上来说前几步正常进行的话都没问题</p><h2 id="运行一个脚本"><a href="#运行一个脚本" class="headerlink" title="运行一个脚本"></a>运行一个脚本</h2><p>命令行中执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./waf --run hello-simulator<br>Build commands will be stored <span class="hljs-keyword">in</span> build/compile_commands.json<br><span class="hljs-string">&#x27;build&#x27;</span> finished successfully (0.844s)<br>Hello Simulator<br></code></pre></td></tr></table></figure><p>出现和上面相同的结果说明运行成功，成功入门</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://www.cnblogs.com/jhcelue/p/6905943.html">NS3 网络仿真（2）：first.py - jhcelue - 博客园</a></p><p>这个是系列教程，作者很牛逼</p><p><a href="https://blog.csdn.net/deep_kang/article/details/73350350">NS3 网络仿真_deep_keng 的博客-CSDN 博客_ns3 使用 netanim 仿真 wifi 节点</a></p><p><a href="https://www.jianshu.com/p/fe77a15a1eb4">用 NS3 进行虚拟仿真 - 简书</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.nsnam.org/wiki/Installation">ns3 官方安装指南（英）</a></p><p><a href="https://www.nsnam.org/docs/release/3.30/tutorial/html/getting-started.html">ns3 官方构建文档（英）</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>ns3 网络模拟软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scanf 格式字符串中的空格</title>
    <link href="/2020/06/24/space-in-scanf/"/>
    <url>/2020/06/24/space-in-scanf/</url>
    
    <content type="html"><![CDATA[<p>scanf 语句中空格的问题</p><span id="more"></span><h2 id="格式说明符前"><a href="#格式说明符前" class="headerlink" title="格式说明符前"></a>格式说明符前</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>, &amp;c);<br></code></pre></td></tr></table></figure><p>第二行中 <code>%c</code> 前加空格，会消耗 <code>%d</code> 后的所有后继空白符，然后读取一个 <code>char</code></p><h2 id="格式说明符后"><a href="#格式说明符后" class="headerlink" title="格式说明符后"></a>格式说明符后</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d &quot;</span>, &amp;a);<br></code></pre></td></tr></table></figure><p>这种写法在你输入数字后，<code>scanf</code> 会<strong>跳过所有空格字符，包括回车符</strong>，直到遇到不是空格字符才退出，<strong>不建议这么写</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.cppreference.com/w/c/io/fscanf">zh.cpprefernce.com</a></p><p><a href="https://zhidao.baidu.com/question/620629950137762012.html">scanf 语句中%d 后面多加一个空格，为什么数据需要多输入一个？_百度知道</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C 语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 通过 apt 安装 nodejs</title>
    <link href="/2020/06/17/install-nodejs-on-ubuntu-with-apt/"/>
    <url>/2020/06/17/install-nodejs-on-ubuntu-with-apt/</url>
    
    <content type="html"><![CDATA[<p>Ubuntu 通过 apt 安装 nodejs 的方法</p><span id="more"></span><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>由于 Nodejs 更新速度较快，不建议使用此种方式，建议使用 <a href="https://github.com/nvm-sh/nvm">nvm</a> 或者 <a href="https://github.com/nodenv/nodenv">nodenv</a></p><p>官方文档不建议使用管理员权限进行安装，<a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally">Resolving EACCES permissions errors when installing packages globally</a></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="14-x"><a href="#14-x" class="headerlink" title="14.x"></a>14.x</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -<br>sudo apt-get install -y nodejs<br></code></pre></td></tr></table></figure><h3 id="12-x"><a href="#12-x" class="headerlink" title="12.x"></a>12.x</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -<br>sudo apt-get install -y nodejs<br></code></pre></td></tr></table></figure><h3 id="10-x"><a href="#10-x" class="headerlink" title="10.x"></a>10.x</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -<br>sudo apt-get install -y nodejs<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将 HTML 元素居中的方法</title>
    <link href="/2020/05/30/align-items-to-center-using-css/"/>
    <url>/2020/05/30/align-items-to-center-using-css/</url>
    
    <content type="html"><![CDATA[<p>三种将 HTML 元素居中的方法</p><span id="more"></span><h2 id="左右居中"><a href="#左右居中" class="headerlink" title="左右居中"></a>左右居中</h2><p>当元素的 <code>display</code> 属性为 <code>inline</code> 或者 <code>inline-block</code> 时，将<strong>父元素</strong>设定为 <code>text-align: center;</code> 即可左右居中</p><p>当元素的 <code>display</code> 属性为 <code>block</code> 时，将<strong>元素本身</strong>的 <code>margin-left</code> 和 <code>margin-right</code> 设定为 <code>auto</code> 即可左右居中</p><h2 id="上下居中"><a href="#上下居中" class="headerlink" title="上下居中"></a>上下居中</h2><h3 id="position-absolute"><a href="#position-absolute" class="headerlink" title="position: absolute"></a>position: absolute</h3><p>使用 <code>position: absolute</code> 时，可以参考如下代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-id">#center</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>) <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="flexbox"><a href="#flexbox" class="headerlink" title="flexbox"></a>flexbox</h3><p>flexbox 自带 <code>justify-content</code> 和 <code>align-items</code> 两个属性，分别设定主轴和交叉轴的对齐方式，将这两个属性都设置为 <code>center</code> 即可上下左右居中对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="display-table"><a href="#display-table" class="headerlink" title="display: table"></a>display: table</h3><p>HTML 的 <code>table</code> 元素有一个 <code>valign</code> 属性，是用来设定垂直方向的对齐，可以通过 CSS 将其他元素的 <code>display</code> 属性设定为 <code>table</code> 去将它当作一个 <code>table</code> 去显示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">display</span>: table;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;<br>&#125;<br><br># center &#123;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">vertical-align</span>: middle;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>position: absolute 方法是对其元素本身，调整元素本身的属性即可</p><p>flexbox、display: table 方法是对其元素内容，先将容器调整为与画面大小相同，然后再设定他的内容的对齐方式</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1o7411G7dq">CodingStartup - [HTML] 上下左右置中对齐的三种方法_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 从选择的文件中读取文本</title>
    <link href="/2020/05/30/read-text-from-files-with-javascript/"/>
    <url>/2020/05/30/read-text-from-files-with-javascript/</url>
    
    <content type="html"><![CDATA[<p>在开发词法分析器的前端页面时，需要允许用户从本地上传 c++ 文件，并将文件内容载入到编辑器中，本文介绍如何用 JavaScript 和 input 标签来实现网页加载文本文件内容（注意是加载内容）</p><span id="more"></span><h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><p>首先介绍一下 <code>FileReader</code>，FileReader 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 对象指定要读取的文件或数据，可以用 <code>const reader = new FileReader();</code> 来初始化，详细部分在<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader">FileReader - Web API 接口参考 | MDN</a>中</p><h2 id="读取-Input-标签文件内容"><a href="#读取-Input-标签文件内容" class="headerlink" title="读取 Input 标签文件内容"></a>读取 Input 标签文件内容</h2><p>以下是示例代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 获取 input 标签对应的元素</span><br><span class="hljs-keyword">const</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;file-input&quot;</span>);<br><span class="hljs-comment">// 读取文件</span><br><span class="hljs-keyword">const</span> file = fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;file-input&quot;</span>);<br><span class="hljs-keyword">let</span> file = fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">let</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();<br><span class="hljs-keyword">let</span> text;<br>reader.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;loadend&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  text = reader.<span class="hljs-property">result</span>;<br>&#125;);<br>reader.<span class="hljs-title function_">readAsText</span>(file);<br></code></pre></td></tr></table></figure><h2 id="在-React-有状态组件中实现"><a href="#在-React-有状态组件中实现" class="headerlink" title="在 React 有状态组件中实现"></a>在 React 有状态组件中实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">handleFileChange</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;file-input&quot;</span>);<br>  <span class="hljs-keyword">let</span> file = fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">let</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();<br>  reader.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;loadend&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      <span class="hljs-attr">text</span>: reader.<span class="hljs-property">result</span>,<br>    &#125;);<br>    fileInput.<span class="hljs-property">value</span> = <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;);<br>  reader.<span class="hljs-title function_">readAsText</span>(file);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：因为是加载文件，所以加载完一次后要清除所选文件，否则下次加载同样的文件无法触发 <code>handleFileCHange</code> 函数，无法使状态改变了</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader">FileReader - Web API 接口参考 | MDN</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023022494381696">操作文件 - 廖雪峰的官方网站</a></p><p><a href="https://blog.csdn.net/cuixiping/article/details/37526871">用 Javascript 清空(重置)文件类型的 INPUT 元素的值<em>javascript</em>无心的专栏-CSDN 博客</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 CentOS7 上安装 MySQL Community Server</title>
    <link href="/2020/05/29/install-mysql-community-server-on-centos7/"/>
    <url>/2020/05/29/install-mysql-community-server-on-centos7/</url>
    
    <content type="html"><![CDATA[<p>对<a href="https://juejin.im/post/5d07cf13f265da1bd522cfb6#heading-24">tianranll - CentOS 安装 MySQL 详解</a>的一些补充</p><span id="more"></span><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p><a href="https://juejin.im/post/5d07cf13f265da1bd522cfb6#heading-24">tianranll - CentOS 安装 MySQL 详解</a></p><p>这个人已经讲的很详细了，我就是补充一下，讲解一下踩到的坑，另外，我是用虚拟机的方式来测试环境的，下面的一切操作都是基于 CentOS 虚拟机的情况下中执行的，容错率比较高。</p><h2 id="MySQL-Yum-Repo-安装链接"><a href="#MySQL-Yum-Repo-安装链接" class="headerlink" title="MySQL Yum Repo 安装链接"></a>MySQL Yum Repo 安装链接</h2><p>这个链接是在 <a href="https://dev.mysql.com/downloads/repo/yum/">MySQL Community Downloads - MySQL Yum Repository</a> 下找到的，根据 Linux 版本来选取，比如说我安装的是 CentOS7 就选择 RedHat Enterprise Linux 7</p><p><img src="https://cdn.jsdelivr.net/gh/mazixiang/assets@master/picgo/20200528085819.png" alt="选择 RedHat Enterprise Linux 7"></p><p>点击之后出来的这个页面，复制下面的 <code>no thanks</code> 链接地址</p><p><img src="https://cdn.jsdelivr.net/gh/mazixiang/assets@master/picgo/20200528090827.png" alt="复制链接地址"></p><p>你的 <code>wget</code> 命令后面应该接的是这个复制的地址（如果你想安装最新的版本）</p><h2 id="远程连接问题"><a href="#远程连接问题" class="headerlink" title="远程连接问题"></a>远程连接问题</h2><p>对应文章的 6. 允许 root 远程访问</p><p><strong>从 MySQL 8.0 以后，不可以再直接使用 <code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;</code> 来给权限了，可以用下面的命令来代替</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 1. 使用alter user</span><br><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> user.host<span class="hljs-operator">=</span><span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">where</span> user.user<span class="hljs-operator">=</span><span class="hljs-string">&#x27;root&#x27;</span>;<br><span class="hljs-comment">-- 2. 使用create user</span><br><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;userName&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;your_password&#x27;</span>;<br></code></pre></td></tr></table></figure><p>我失败了之后查了好长一段时间，最后在<a href="https://www.jianshu.com/p/98a6d42e28c8">mysql8 grant 授权报错：ERROR 1410 (42000): You are not allowed to create a user with GRANT</a>找到了解决方案，但是原作者好像忘了写那个 <code>identified</code> 后面的 <code>by</code> 了……</p><h2 id="开启-CentOS7-的防火墙-3306-端口"><a href="#开启-CentOS7-的防火墙-3306-端口" class="headerlink" title="开启 CentOS7 的防火墙 3306 端口"></a>开启 CentOS7 的防火墙 3306 端口</h2><p>不开启端口，是无法使用远程连接的，参考<a href="https://blog.csdn.net/achang21/article/details/52538049">CentOS 7 开放防火墙端口命令</a>，在终端执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ firewall-cmd --zone=public --add-port=3306/tcp --permanent<br>success<br>$ firewall-cmd --reload<br>success<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5d07cf13f265da1bd522cfb6#heading-24">tianranll - CentOS 安装 MySQL 详解</a></p><p><a href="https://www.jianshu.com/p/98a6d42e28c8">mysql8 grant 授权报错：ERROR 1410 (42000): You are not allowed to create a user with GRANT</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 常用单位</title>
    <link href="/2020/05/28/commonly-used-css-units/"/>
    <url>/2020/05/28/commonly-used-css-units/</url>
    
    <content type="html"><![CDATA[<p>简单介绍 CSS 常用单位</p><span id="more"></span><h2 id="px"><a href="#px" class="headerlink" title="px"></a>px</h2><p><code>px</code> 是最常用的<strong>绝对单位</strong>，全称是 <code>pixel</code> ，代表屏幕上的像素点，用法如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="em"><a href="#em" class="headerlink" title="em"></a>em</h2><p><code>em</code> 是一个相对单位，代表相对父元素字体大小的倍数，用法如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.8em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时的 <code>div</code> 中的 <code>h1</code> 元素字体大小为 <code>20px * 0.8em = 16px</code></p><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p><code>rem</code> 也是一个相对单位，代表相对根（root）元素字体大小的倍数，用法如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.8rem</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时的 <code>div</code> 中的 <code>h1</code> 元素字体大小为 <code>10px * 0.8em = 8px</code>，并且不受父容器字体大小的限制</p><h2 id="vw-和-vh"><a href="#vw-和-vh" class="headerlink" title="vw 和 vh"></a>vw 和 vh</h2><p><code>vw</code> 和 <code>vh</code> 即是 <code>viewport width</code> 和 <code>viewport height</code> 的缩写，<code>viewport</code> 是目前看到的画面的大小，他们的值只能是 1 - 100，<code>50vw</code> 是占画面宽度的一半，<code>50vh</code> 是占画面高度的一半</p><p>经常用到的是 <code>100vh</code> 和 <code>100 vw</code>，用来做水平垂直居中都很方便</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1d441167e9">CodingStartup - 5 个常用的 CSS 单位</a></p><p><a href="https://zhuanlan.zhihu.com/p/28915418">知乎 - css 单位中 px 和 em,rem 的区别</a></p><p><a href="https://www.w3.org/Style/Examples/007/units.zh_CN.html">w3.org - 网页样式表 CSS 提示以及技巧</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Windows 上 git log 乱码</title>
    <link href="/2020/05/27/solution-to-git-log-garbled-on-windows/"/>
    <url>/2020/05/27/solution-to-git-log-garbled-on-windows/</url>
    
    <content type="html"><![CDATA[<p>解决大多数的 Windows 上 git log 乱码问题，注意是大多数问题</p><span id="more"></span><h2 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h2><p>Linux 系统上的环境变量需要使用 <code>export LANG=zh_CN.UTF-8</code> 来指定</p><p>永久写入需要把 <code>export</code> 语句直接写入 <code>.bashrc</code> 或者 <code>.zshrc</code> 中</p><h2 id="检查环境变量"><a href="#检查环境变量" class="headerlink" title="检查环境变量"></a>检查环境变量</h2><p>打开 cmd 或者 powershell，输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&gt; <span class="hljs-built_in">echo</span> %LANG%<br></code></pre></td></tr></table></figure><p>查看 <code>LANG</code> 变量，如果输出 <code>zh_CN.UTF-8</code> 则继续进行，如果输出别的，新建一个环境变量 <code>LANG</code>，值设为 <code>zh_CN.UTF-8</code>，重启 cmd</p><h2 id="修改-git-config"><a href="#修改-git-config" class="headerlink" title="修改 git config"></a>修改 git config</h2><p>在 cmd 或者 powershell 中，输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&gt; git config <span class="hljs-literal">--global</span> i18n.commitencoding utf<span class="hljs-literal">-8</span><br>&gt; git config <span class="hljs-literal">--global</span> i18n.logoutputencoding utf<span class="hljs-literal">-8</span><br></code></pre></td></tr></table></figure><p>并新建一条环境变量 <code>LESSCHARSET</code>，值设为 <code>utf-8</code></p><h2 id="暂时设置环境变量"><a href="#暂时设置环境变量" class="headerlink" title="暂时设置环境变量"></a>暂时设置环境变量</h2><p>在 cmd 或者 powershell 中输入 <code>set LANG=zh_CN.UTF-8</code>，可以暂时起作用，但重新启动后就没用了</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/fb47a39f3578">git log 中文乱码 - 简书</a></p><p><a href="https://blog.csdn.net/qianggezhishen/article/details/80865143">git log 乱码解决方法_git_qianggezhishen 的专栏-CSDN 博客</a></p><p><a href="https://www.cnblogs.com/zhangxiaoliu/p/9226197.html">git log 中文乱码的解决方案 - 张发财 - 博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 自定义类的排序</title>
    <link href="/2020/05/26/sorting-of-custom-classes/"/>
    <url>/2020/05/26/sorting-of-custom-classes/</url>
    
    <content type="html"><![CDATA[<p>两种 Java 自定义类的排序的方法</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Java 中，类的实例默认是不可以进行比较和排序的，本文将解决以下两个问题：</p><ul><li>如何比较类同一个类的两个实例的大小？</li><li>正常的 Java 数组是可以用 <code>Array.sort()</code> 进行排序的，前提是这些元素是可排序的，在自定义的类中怎么直接使用 <code>Array.sort()</code> 呢？</li></ul><h2 id="介绍-Comparable"><a href="#介绍-Comparable" class="headerlink" title="介绍 Comparable"></a>介绍 Comparable</h2><p>Comparabe 是一个排序接口，如果一个类支持 <code>Comparable</code> 接口，就意味着该类支持排序排序。实现了 <code>Comparable</code> 接口的类的对象的列表或数组可以通过 <code>Arrays.sort()</code> 进行自动排序，此外，实现此接口的对象可以用作有序映射中的键或有序集合中的集合，无需指定比较器。</p><h3 id="Comparable-的定义"><a href="#Comparable-的定义" class="headerlink" title="Comparable 的定义"></a>Comparable 的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Comparable-的说明"><a href="#Comparable-的说明" class="headerlink" title="Comparable 的说明"></a>Comparable 的说明</h3><ul><li>T 表示可以与此对象进行比较的对象的类型</li><li>此接口只有一个方法 <code>compareTo</code>，比较此对象与指定对象的顺序，小于返回负整数，大于返回正整数，等于返回 0</li></ul><h3 id="Comparable-的示例"><a href="#Comparable-的示例" class="headerlink" title="Comparable 的示例"></a>Comparable 的示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      Fruit[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fruit</span>[<span class="hljs-number">3</span>];<br>      a[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fruit</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>      a[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fruit</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>      a[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fruit</span>(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>      Arrays.sort(a);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        System.out.println(a[i].getWeight() + <span class="hljs-string">&quot; &quot;</span> + a[i].getSugar() + <span class="hljs-string">&quot; &quot;</span> + a[i].getPrice());<br>      &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Fruit&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> weight;  <span class="hljs-comment">// 重量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> sugar;  <span class="hljs-comment">// 含糖量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> price;  <span class="hljs-comment">// 价格</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Fruit</span><span class="hljs-params">(<span class="hljs-type">double</span> w, <span class="hljs-type">double</span> s, <span class="hljs-type">double</span> p)</span> &#123;<br>        weight = w;<br>        sugar = s;<br>        price = p;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Fruit a)</span> &#123;<br>        <span class="hljs-keyword">return</span> -Double.compare(<span class="hljs-built_in">this</span>.weight, a.weight);  <span class="hljs-comment">// 按照重量由大到小进行排序</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getWeight</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> weight;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getSugar</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sugar;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> price;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的程序输出为</p><blockquote><p>7.0 8.0 9.0<br>4.0 5.0 6.0<br>1.0 2.0 3.0</p></blockquote><p>说明排序成功</p><h2 id="介绍-Comparator"><a href="#介绍-Comparator" class="headerlink" title="介绍 Comparator"></a>介绍 Comparator</h2><p>Comparator 是一个比较接口，如果要控制某个类的次序，而该类本身不支持排序，那么可以建立一个“该类的比较器”来进行排序，这个比较器只需要实现 Comparator 接口即可。</p><h3 id="Comparator-的定义"><a href="#Comparator-的定义" class="headerlink" title="Comparator 的定义"></a>Comparator 的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparator</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(T o1, T o2)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-Comparator-的注意事项"><a href="#使用-Comparator-的注意事项" class="headerlink" title="使用 Comparator 的注意事项"></a>使用 Comparator 的注意事项</h3><ul><li>若一个类要实现 Comparator 接口，必须要有<code>compare</code>函数，<code>equals</code>函数可写可不写</li><li><code>int compare(T o1, T o2)</code>函数是比较 o1 和 o2 的大小，返回负数意味着 o1 比 o2 小，返回 0 意味着 o1 等于 o2，返回正数代表 o1 大于 o2</li></ul><h3 id="Comparator-的示例"><a href="#Comparator-的示例" class="headerlink" title="Comparator 的示例"></a>Comparator 的示例</h3><h2 id="Comparable-和-Comparator-的比较"><a href="#Comparable-和-Comparator-的比较" class="headerlink" title="Comparable 和 Comparator 的比较"></a>Comparable 和 Comparator 的比较</h2><p>Comparable 是排序接口，若一个类实现了 Comparable 接口，就意味着“该类支持排序”。</p><p>Comparator 是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p><p>Comparable 相当于“内部比较器”，而 Comparator 相当于“外部比较器”。</p><p>两种方法各有优劣， 用 Comparable 简单， 只要实现 Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。</p><p>用 Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在 Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。</p><p>比如你引入了别人写的一个类，需要对这个类的实例进行比较或者排序，若要使用实现 Comparable 接口的方法，则你需要对引入的类进行源代码的修改，而如果使用实现 Comparator 接口的方式，则不需要对引入的类进行修改，只需要重新写一个引入类的比较器类就可以了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/gaoBlog/p/10754935.html">java 学习–自定义类的实例的大小比较和排序</a></p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html?is-external=true">Comparable 官方文档</a></p><p><a href="https://docs.oracle.com/javase/1.5.0/docs/api/java/util/Comparator.html">Comparator 官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 常用解压命令</title>
    <link href="/2020/05/26/linux-unzip-commands/"/>
    <url>/2020/05/26/linux-unzip-commands/</url>
    
    <content type="html"><![CDATA[<p>Linux 常用的解压命令</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Linux 下常见的压缩包格式为 <code>zip tar.gz tar.bz2 tar.xz tar.Z</code><br>其中 <code>tar</code> 是打包格式，<code>gz2 bz2</code> 等后缀是指代压缩方式</p><h2 id="filename-zip"><a href="#filename-zip" class="headerlink" title="filename.zip"></a>filename.zip</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ unzip filename.zip<br></code></pre></td></tr></table></figure><h2 id="filename-tar-gz"><a href="#filename-tar-gz" class="headerlink" title="filename.tar.gz"></a>filename.tar.gz</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tar -zxvf filename.tar.gz<br></code></pre></td></tr></table></figure><p>-z：gzip - 压缩格式<br>-x：extract - 解压<br>-v：verbose - 详细信息<br>-f：file - 文件</p><h2 id="filename-tar-bz2"><a href="#filename-tar-bz2" class="headerlink" title="filename.tar.bz2"></a>filename.tar.bz2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tar -jxvf filename.tar.bz2<br></code></pre></td></tr></table></figure><p>-j：bz2 压缩方式</p><h2 id="filename-tar-xz"><a href="#filename-tar-xz" class="headerlink" title="filename.tar.xz"></a>filename.tar.xz</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tar -Jxvf filename.tar.xz<br></code></pre></td></tr></table></figure><p>注意 J 大写</p><h2 id="filename-tar-Z"><a href="#filename-tar-Z" class="headerlink" title="filename.tar.Z"></a>filename.tar.Z</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tar -Zxvf filename.tar.Z<br></code></pre></td></tr></table></figure><p>注意 Z 大写</p><h2 id="简便写法"><a href="#简便写法" class="headerlink" title="简便写法"></a>简便写法</h2><p>首先，使用 <code>tar --version</code> 查看版本，从 1.15 版本以后可以直接使用 <code>tar -xvf</code> 来智能识别格式</p><p>参考自<a href="https://www.cnblogs.com/cursorhu/p/5891699.html">Linux 下的解压命令小结 - cursorhu</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过 Travis CI 或者 GitHub Actions 将 Hexo 博客部署到 GitHub Pages</title>
    <link href="/2020/05/25/deploy-hexo-to-github-pages-with-travis-ci/"/>
    <url>/2020/05/25/deploy-hexo-to-github-pages-with-travis-ci/</url>
    
    <content type="html"><![CDATA[<p>纯萌新遇到的一些坑</p><span id="more"></span><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>目前，**<a href="https://hexo.io/docs/github-pages">Hexo 英文文档</a>**已经使用 <code>GitHub Actions</code> 来部署到 GitHub Pages 上了，但是中文文档没有同步更新，所以更新一下对应的方法</p><h3 id="预先检查"><a href="#预先检查" class="headerlink" title="预先检查"></a>预先检查</h3><p>首先，确定你项目的源文件全部在 source 分支上，然后进行对应的操作</p><h3 id="检查是否存在脚本"><a href="#检查是否存在脚本" class="headerlink" title="检查是否存在脚本"></a>检查是否存在脚本</h3><p>检查一下 <code>package.json</code> 文件下有没有如下两行，如果没有，添加进去</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo generate&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><h3 id="推送到-GitHub-分支"><a href="#推送到-GitHub-分支" class="headerlink" title="推送到 GitHub 分支"></a>推送到 GitHub 分支</h3><p>在你的项目目录下面运行如下命令，将你博客的 source 分支推送到远程的对应分支上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push -u origin <span class="hljs-built_in">source</span><br>...<br></code></pre></td></tr></table></figure><h3 id="新建-GitHub-Workflow"><a href="#新建-GitHub-Workflow" class="headerlink" title="新建 GitHub Workflow"></a>新建 GitHub Workflow</h3><p>在你的项目文件夹下新建 <code>.github/workflows/pages.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">source</span> <span class="hljs-comment"># 默认部署分支</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">pages:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span> <span class="hljs-number">14</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;14&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">NPM</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">node_modules</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.OS</span> <span class="hljs-string">&#125;&#125;-npm-cache</span><br>          <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|</span><br><span class="hljs-string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">github_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITHUB_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">publish_dir:</span> <span class="hljs-string">./public</span><br>          <span class="hljs-attr">publish_branch:</span> <span class="hljs-string">master</span> <span class="hljs-comment"># 部署到的分支</span><br></code></pre></td></tr></table></figure><h3 id="更改-GitHub-仓库设置"><a href="#更改-GitHub-仓库设置" class="headerlink" title="更改 GitHub 仓库设置"></a>更改 GitHub 仓库设置</h3><p>更改你的 GitHub 仓库设置，到 <code>GitHub Pages</code> 部分，将 <code>source</code> 分支改为 <code>master</code></p><p>注意：如果你有自定义域名，请将 <code>CNAME</code> 文件放入 <code>source</code> 文件夹</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>使用 Hexo 搭建完博客之后，翻了一下官网，结果发现还可以用 <code>Travis CI</code> 来做自动生成部署啊！正好今天整了一天的 <code>Travis CI</code>，也差不多熟悉了，就直接按照官方文档去照着做了</p><h2 id="Travis-CI-介绍"><a href="#Travis-CI-介绍" class="headerlink" title="Travis CI 介绍"></a>Travis CI 介绍</h2><p>Travis CI 是一个持续集成工具，因为我只使用了一天，还不太了解。详细原理可以去搜一下，这里就简单讲一下：就是你提交了一次 <code>commit</code> 后，这个工具按照你的 repo 里的 <code>.travis.yml</code> 来自动执行一些操作，如果构建通过了显示 <code>passing</code>，不通过显示 <code>failing</code>。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a href="https://hexo.io/zh-cn/docs/github-pages">Hexo 官方的使用 Travis CI 教程</a>有点小坑啊，现在的 <code>GitHub Pages</code> 的部署分支必须是 <code>master</code> 分支了，但是官网的教程是部署到 <code>gh-pages</code> 分支上的，官网说可以切换 <code>GitHub Pages</code> 部署分支到 <code>gh-pages</code> 分支上，<strong>完全没说别的</strong>，作为刚使用一天的选手，我就是想把生成的分支改为 <code>master</code>，但是我在官方给的配置文件中根本没找到 <code>gh-pages</code>！，这里附带官网的配置文件（其中还要添加 <code>GH_TOKEN</code> 环境变量，这里就不展开说了）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sudo:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">node_js</span><br><span class="hljs-attr">node_js:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 使用 nodejs 的长期支持版本</span><br><span class="hljs-attr">cache:</span> <span class="hljs-string">npm</span><br><span class="hljs-attr">branches:</span><br>  <span class="hljs-attr">only:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span> <span class="hljs-comment"># 仅仅构建 master 分支</span><br><span class="hljs-attr">script:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span> <span class="hljs-comment"># 生成静态文件</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">provider:</span> <span class="hljs-string">pages</span><br>  <span class="hljs-attr">skip-cleanup:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">github-token:</span> <span class="hljs-string">$GH_TOKEN</span><br>  <span class="hljs-attr">keep-history:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">on:</span><br>    <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br>  <span class="hljs-attr">local-dir:</span> <span class="hljs-string">public</span><br></code></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>我去网上找来找去，找到了几个类似的解决办法：</p><ul><li><a href="https://garryshield.github.io/2019/04/08/travis-ci/">通过 Travis CI 自动部署 Hexo 到 Github</a> - 这个实现方法，和官方的实现方法不太一样，我一般比较喜欢官方的实现方法，要是实在找不到解决办法才会用</li><li><a href="https://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/">使用 Travis CI 自动更新 GitHub Pages</a> - 这个说的也和官方的不太一样</li></ul><p>找来找去，结果在 <a href="https://docs.travis-ci.com/user/deployment/pages/">官方 pages 部署的文档</a> 里面找到了，原来这个部署的默认分支就是 <code>gh-pages</code>！可以通过进一步配置 <code>target_branch</code> 来修改！所以我把所有的源代码移到了 <code>source</code> 分支上，然后将配置文件改成了下面这样，就可以正常访问了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sudo:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">node_js</span><br><span class="hljs-attr">node_js:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 使用 nodejs 的长期支持版本</span><br><span class="hljs-attr">cache:</span> <span class="hljs-string">npm</span><br><span class="hljs-attr">branches:</span><br>  <span class="hljs-attr">only:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">source</span> <span class="hljs-comment"># 仅仅构建 source 分支</span><br><span class="hljs-attr">script:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span> <span class="hljs-comment"># 生成静态文件</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">provider:</span> <span class="hljs-string">pages</span><br>  <span class="hljs-attr">skip-cleanup:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">github-token:</span> <span class="hljs-string">$GH_TOKEN</span><br>  <span class="hljs-attr">keep-history:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">on:</span><br>    <span class="hljs-attr">branch:</span> <span class="hljs-string">source</span><br>  <span class="hljs-attr">local-dir:</span> <span class="hljs-string">public</span><br>  <span class="hljs-attr">target_branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Travis CI</tag>
      
      <tag>GitHub Actions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程中的 KISS 原则</title>
    <link href="/2020/05/25/the-kiss-rules-in-programming/"/>
    <url>/2020/05/25/the-kiss-rules-in-programming/</url>
    
    <content type="html"><![CDATA[<p>参考<a href="https://zhuanlan.zhihu.com/p/110031390">知乎文章 - 编程中的 kiss 原则是什么</a></p><span id="more"></span><h2 id="KISS-表示的是什么"><a href="#KISS-表示的是什么" class="headerlink" title="KISS 表示的是什么"></a>KISS 表示的是什么</h2><p>KISS 是 Keep It Stupid Simple 或 Keep It Simple,Stupid 的缩写。</p><h2 id="KISS-的含义"><a href="#KISS-的含义" class="headerlink" title="KISS 的含义"></a>KISS 的含义</h2><p>该原则在<a href="https://www.zhihu.com/people/san-guo-you-xi-da-shi">作者</a>的多年的软件工程生涯中取得关键、巨大的成功。当今的软件工程师和开发者们有个共同的问题，那就是他们总是慢慢地使得问题复杂化。正确的做法应该是当开发者遇到一个问题后，把问题拆分成一个个能够明白的小块，然后进入编码阶段。<br><a href="https://www.zhihu.com/people/san-guo-you-xi-da-shi">作者</a>认为，10 个开发者中有 8 个或 9 个都没有把问题分解成足够小或可以理解的足够小的部分。这就导致了即使是一个非常简单的问题最后也变成了非常复杂的实现，另外一个副作用就是意大利面代码，在 BASIC 里只是一个 goto 语句的事情，在 Java 中却需要 500 到 1000 行代码，每个方法都有几百行代码。</p><p>你需要先想好问题的解决步骤一共分为几步，然后再进入编码。而不是拿到需求后，就开始一边写代码一边去满足需求。这样做的好处就是你的代码会变的足够容易理解和足够清晰。</p><h2 id="我们能从-KISS-中获取到什么好处"><a href="#我们能从-KISS-中获取到什么好处" class="headerlink" title="我们能从 KISS 中获取到什么好处"></a>我们能从 KISS 中获取到什么好处</h2><ul><li>你可以更好地解决更多问题。</li><li>你将可以通过很少的几行代码去解决复杂的问题。</li><li>你将可以产出高质量的代码。</li><li>你将可以构建更大更易维护的系统。</li><li>当新的需求来了后，你的代码将会更加的灵活，易于扩展、易于修改和重构。</li><li>你将完成比你想象得更多的事情。</li><li>你将能够工作在一个大型开发团队和大型项目中，因为所有的代码都是 stupid simple。</li></ul><h2 id="我如何把-KISS-原则用到我的工作中"><a href="#我如何把-KISS-原则用到我的工作中" class="headerlink" title="我如何把 KISS 原则用到我的工作中"></a>我如何把 KISS 原则用到我的工作中</h2><p><a href="https://www.zhihu.com/people/san-guo-you-xi-da-shi">作者</a>推荐了几个简单的步骤可供执行，但有一定挑战。就像说起来的那么简单，keep it simple，主要是需要耐心，更多的靠你自己。</p><ul><li>要谦虚，不要认为自己是个天才，这是你第一个误解。只有谦虚了，你才能真正达到超级天才的水平，即使不行，who cares！你的代码那么 stupid simple，所以你<strong>不需要是个天才</strong>！</li><li>将你的任务分解为 4 - 12 小时的子任务。</li><li>把你的问题拆分成多个小问题。每个问题用一个或者很少的几个类来解决掉。</li><li>保持你的方法足够小，每个方法永远不要超过 30 - 40 行代码。每个方法都应该只处理一个小小的问题，不要搞太多 uses case 进去。如果你的方法中有多个分支，尝试把他们拆分成多个小的方法。这样不仅容易阅读和维护，找 bug 也更快。慢慢的你将学会爱。</li><li>让你的类也小点，原则和上面的方法是一样的。</li><li>先解决问题，然后开始编码。不要一边编码，一边解决问题。这样做也没什么错，但你有能力提前把事情切分成多个小的块，然后开始编码可能是比较好的。但也请你不要害怕一遍遍重构你的代码。另外行数还不是为了衡量质量的标准，只是有个基本的尺子而已。</li><li>不要害怕干掉代码。重构和重做是两个非常重要的方面。如果你遵循上面的建议，重写代码的数量将会最小化，如果你不遵循，那么代码很可能会被重写。</li><li>其他的任何场景，都请你尝试尽可能的简单，simple，这也是最难的一步，但一旦你拥有了它，你再回头看，就会说，之前的事情就是一坨屎。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/110031390">知乎文章 - 编程中的 kiss 原则是什么</a></p>]]></content>
    
    
    <categories>
      
      <category>思想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KISS</tag>
      
      <tag>编程原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity 2D 平台跳跃游戏角色转身</title>
    <link href="/2019/10/19/unity-character-turn-around/"/>
    <url>/2019/10/19/unity-character-turn-around/</url>
    
    <content type="html"><![CDATA[<p>Unity 2D 平台跳跃游戏角色转身的一些方法</p><span id="more"></span><h2 id="方法-1-设置-Transform-中-Scale-属性为-1"><a href="#方法-1-设置-Transform-中-Scale-属性为-1" class="headerlink" title="方法 1 - 设置 Transform 中 Scale 属性为-1"></a>方法 1 - 设置 Transform 中 Scale 属性为-1</h2><p>具体实现方法如下</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> faceDirection = Input.GetAxisRaw(<span class="hljs-string">&quot;horizontal&quot;</span>);<br><span class="hljs-keyword">if</span> (!Mathf.Approximately(faceDirection, <span class="hljs-number">0.0f</span>))<br>&#123;<br>    transform.localScale = <span class="hljs-keyword">new</span> Vector3(faceDirection, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法-2-在动画器中新建相反方向的动画"><a href="#方法-2-在动画器中新建相反方向的动画" class="headerlink" title="方法 2 - 在动画器中新建相反方向的动画"></a>方法 2 - 在动画器中新建相反方向的动画</h2><p>在动画控制器中，新建一个 x 轴反转的属性，在我之前学习的教程中有具体描述</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>哔哩哔哩作者 <a href="https://space.bilibili.com/370283072/">M_studio</a> 的视频</p><p><a href="https://www.bilibili.com/video/BV154411f7Pa">Unity 教程 Your First Game|入门 Tutorial:05 角色方向&amp;跳跃</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity 游戏引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对单例模式的理解</title>
    <link href="/2019/10/11/some-understanding-to-singleton-pattern/"/>
    <url>/2019/10/11/some-understanding-to-singleton-pattern/</url>
    
    <content type="html"><![CDATA[<p>对单例模式的一些理解</p><span id="more"></span><h2 id="单例模式概述"><a href="#单例模式概述" class="headerlink" title="单例模式概述"></a>单例模式概述</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p>注意：</p><ul><li>单例类只能有一个实例</li><li>单例类必须创建自己的唯一实例</li><li>单例类必须给所有其他对象提供这一实例</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h3 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h3><p>一个全局使用的类频繁地创建与销毁。</p><h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><p>当您想控制实例数目，节省系统资源的时候。</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><p>构造函数是私有的。</p><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><ol><li>一个班级只有一个班主任</li><li>Windows是多进程多线程的，在操作一个文件的时候，就不可避免的出现多个进程或线程同时操作一个文件的情况，所以所有文件的处理必须通过唯一实例运行</li><li>设备管理器经常设计为单例模式，比如一个电脑有两个打印机，在输出的时候不能两台打印机处理同一文件</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>避免对资源的多重占用（比如写文件操作）。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><p>要求生产唯一序列号。</p></li><li><p>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</p></li><li><p>创建的一个对象需要消耗的资源过多，比如 I&#x2F;O 与数据库的连接等。</p></li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">_instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> _instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">_instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton2</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (_instance != <span class="hljs-literal">null</span>) &#123;<br>            _instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> _instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">runoob.com - 单例模式</a></p><p><a href="https://refactoringguru.cn/design-patterns/singleton">refactoringguru.cn - 单例设计模式</a></p>]]></content>
    
    
    <categories>
      
      <category>实用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
